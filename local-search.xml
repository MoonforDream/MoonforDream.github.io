<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux网络编程</title>
    <link href="/2024/05/20/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/20/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-C-C-网络编程"><a href="#Linux-C-C-网络编程" class="headerlink" title="Linux C&#x2F;C++网络编程"></a>Linux C&#x2F;C++网络编程</h1><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><p><strong>概念</strong>：</p><ul><li><p><code>socket(套接字)</code>可以看成是用户进程与内核网络协议栈的编程接口</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052943.png" alt="image-20240420192138215"></p></li><li><p>socket不仅可以<strong>用于本机的进程间通信</strong>，还可以<strong>用于网络上不同主机的进程间通信</strong></p></li><li><p>socket(套接字)<strong>一定是成对出现的</strong></p></li><li><p><strong>一个套接字其实就是由一个文件描述符指向的</strong>(原理图中的sfd和cfd表示的就是文件描述符)，因此<strong>socket通信中也可以使用I&#x2F;O方法和函数</strong></p></li><li><p><code>文件描述符</code>：</p><blockquote><ol><li>是一个非负整数，<strong>并且用于代表一个打开的文件</strong></li><li><strong>文件描述符默认产生3个分别为0：STDIN_FILENO(标准输入)、1：STDOUT_FILENO(标准输出)、2：STDERR_FILENO(标准错误)</strong></li><li><strong>遵循新建文件描述符时选择最小可选择的</strong>，因此在没有新建文件描述符的打开一个文件产生的是fd为3的文件描述符</li><li><strong>总共最多1024个文件描述符</strong>。也就是1023为最后一个文件描述符</li></ol></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052945.png" alt="image-20240420190544388"></p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p><strong>概念</strong>：</p><ul><li><code>字节序</code>是<strong>存储数据所遵循的一套规则</strong></li><li>字节序<strong>分为大端序和小端序</strong></li><li>当我们传输数据时如果双方的<strong>字节序的不同就会造成发送的数据和接收数据不一致</strong>，所以我们<strong>得去关注字节序问题</strong></li><li>字节序问题是一个历史遗留的问题，当年IBM也就是第一个数据存储公司，采用了大端序作为数据存储的规则，而Intel公司想要不一样导致了Intel使用了小端序的方法，因此导致了现在使用Intel、AMD等CPU的主机使用的是小端序存储，而网络协议族(TCP、IP等)使用大端序存储，导致网络通信上主机发送数据到网络上导致数据的不一致问题！</li><li><code>网络字节序</code>：<strong>规定为大端序</strong>，也就是网络中存储采用的字节序方法</li><li><code>主机字节序</code>：<strong>根据CPU决定，一般为小端序，Intel、AMD采用的是小端序</strong>，表示主机存储采用的字节序方法</li><li><strong>当主机字节序和网络字节序不同时，要传输数据就需要进行字节序的转换</strong></li></ul><p><strong>字节序</strong>：</p><ul><li><p><code>大端序</code>：<strong>高位字节存在低位地址，低位字节存在高位地址</strong></p><blockquote><p>例如：有一个十六位进制数0x12345678，利用大端序来存储</p><p>0x00000001(低位地址)存0x12(高位字节)</p><p>0x00000002存0x34</p><p>….</p></blockquote></li><li><p><code>小端序</code>：<strong>高位字节存在高位地址，低位字节存在低位地址</strong></p><blockquote><p>例如：有一个十六位进制数0x12345678，利用小端序来存储</p><p>0x00000001(低位地址)存0x78(低位字节)</p><p>0x00000002存0x56</p><p>….</p></blockquote></li></ul><p><strong>字节序转换函数</strong>：</p><ul><li><p><code>uint32_t htonl(uint32_t hostlong)</code>：<strong>将主机字节序转网络字节序</strong>(也就是小端序转大端序)，<strong>用来进行转换IP地址的字节序</strong>(针对IP协议)，无符号32位整型数通常对应着ip地址，<strong>对于一般的点分10进数的ip地址</strong>(例如192.168.1.110)是string类型需要用atoi()转换为无符号整型，所以<strong>不推荐使用这个转换函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span></span>;<br>hostlong-&gt;表示要转换的主机字节序形式的IP<br></code></pre></td></tr></table></figure></li><li><p><code>uint16_t htons(uint16_t hostshort)</code>：也是<strong>将主机字节序转换为网络字节序</strong>，但是<strong>用来进行转换端口号的字节序</strong>(针对端口号)，无符号16位整型数通常对应端口号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span></span>;<br>hostlong-&gt;表示要转换的主机字节序形式的端口<br></code></pre></td></tr></table></figure></li><li><p><code>uint32_t ntohl(uint32_t netlong)</code>：将<strong>网络字节序转换为主机字节序</strong>(也就是大端序转换为小端序)，<strong>用来进行转化IP地址的字节序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span></span>;<br>netlong-&gt;表示要转换的网络字节序形式的IP<br></code></pre></td></tr></table></figure></li><li><p><code>uint16_t ntohs(uint16_t netshort)</code>：也是<strong>将网络字节序转换为主机字节序</strong>，但是<strong>用来进行转化端口号字节序的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span></span>;<br>netshort-&gt;表示要转换的网络字节序形式的端口号<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>注：</p><ul><li>使用以上函数需要包含头文件<code>#include &lt;arpa/inet.h&gt;</code></li><li><strong>h表示host(主机)，n表示network(网络)，l表示32为长整数，s表示16位短整数</strong></li></ul></blockquote><p><strong>IP地址转换函数</strong>：</p><ul><li><p><code>int inet_pton(int af,const char *src,void *dst)</code>：用于<strong>将点分十进制的IP地址转换为网络字节序的IP地址</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *src,<span class="hljs-type">void</span> *dst)</span></span>;<br><br><span class="hljs-comment">//参数：</span><br>af:表示IP协议(ipv4,ipv6)，填<span class="hljs-built_in">AF_INET</span>(IPv4)或<span class="hljs-built_in">AF_INET6</span>(IPv6);<br>src:传入，IP地址(点分十进制);<br>dst:传出，转换后的网络字节序的IP地址;<br><br><span class="hljs-comment">//返回值：</span><br><span class="hljs-number">1</span>:转换成功;<br><span class="hljs-number">0</span>:转换异常，说明src指向的不是一个有效的IP地址;<br><span class="hljs-number">-1</span>:转换失败;<br></code></pre></td></tr></table></figure></li><li><p><code>const char *inet_ntop(int af,const void *src,char *dst,socklen_t size)</code>：用于<strong>将网络字节序的IP地址转换为主机字节序的点分十进制IP地址</strong>(也就是string类型的)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *src,<span class="hljs-type">char</span> *dst,<span class="hljs-type">socklen_t</span> size)</span></span>;<br><br><span class="hljs-comment">//参数：</span><br>af:表示IP协议(ipv4,ipv6)，填<span class="hljs-built_in">AF_INET</span>(IPv4)或<span class="hljs-built_in">AF_INET6</span>(IPv6);<br>src:网络字节序IP地址;<br>dst:传出，主机字节序IP地址(string);<br>size:dst的大小;<br><br><span class="hljs-comment">//返回值：</span><br>dst:转换成功返回;<br><span class="hljs-literal">NULL</span>:转换失败返回;<br></code></pre></td></tr></table></figure></li><li><p><code>struct hostent *gethostbyname(const char *name)</code>：用于<strong>将域名、主机名、字符串IP转换为网络字节序IP地址</strong>，用于客户端程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *<span class="hljs-built_in">gethostbyname</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name);<br>name-&gt;IP地址<br><br><span class="hljs-comment">//返回一个hostent结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span>&#123;<br>    <span class="hljs-type">char</span> *h_name;  <span class="hljs-comment">//主机名</span><br>    <span class="hljs-type">char</span> **h_aliases;   <span class="hljs-comment">//主机所有别名构成的字符串数组，同一IP可绑定多个域名</span><br>    <span class="hljs-type">short</span> h_addrtype;  <span class="hljs-comment">//主机IP地址的类型</span><br>    <span class="hljs-type">short</span> h_length;  <span class="hljs-comment">//主机IP地址长度，IPv4为4,IPv6为6</span><br>    <span class="hljs-type">char</span> **h_addr_list;  <span class="hljs-comment">//主机的IP地址，以网络字节序存储</span><br>&#125;;<br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-literal">nullptr</span>:转换失败;<br>hostent结构体:转换成功<br><br><br><span class="hljs-comment">//客户端通信使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> h_addr h_addr_list[0]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> s;<br><span class="hljs-comment">//将转换后的网络字节序IP地址复制到sockaddr_in结构体的sin_addr成员中</span><br><span class="hljs-built_in">memcpy</span>(&amp;s.sin_addr,h-&gt;h_addr,h-&gt;h_length);<br></code></pre></td></tr></table></figure></li><li><p><code>in_addr_t inet_addr(const char *cp)</code>：将<strong>字符串格式也就是点分十进制的IP地址转换为网络字节序IP地址</strong></p></li><li><p><code>char *inet_ntoa(struct in_addr in)</code>：<strong>将网络字节序的IP地址转换为字符串格式IP地址</strong>，用于服务端解析客户段IP地址</p></li></ul><h3 id="sockaddr数据结构"><a href="#sockaddr数据结构" class="headerlink" title="sockaddr数据结构"></a>sockaddr数据结构</h3><p><strong>概念</strong>：</p><ul><li>在实现网络通信中的接口时，我们常常得使用他们给定的特定结构体作为参数进行传入，而<strong>sockaddr结构体就是最早的结构体</strong></li></ul><p><strong>网络结构体</strong>：</p><ul><li><p><code>sockaddr结构体</code>：<strong>用于存放协议族、端口和地址信息的结构体</strong>，客户端和服务端中的接口函数需要使用这个结构体，但是<strong>这个结构体将端口和地址信息都用同一个变量进行存储</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span>&#123;<br>    <span class="hljs-type">sa_family_t</span> sin_family;  <span class="hljs-comment">//协议族，一般填AF_INET，IPv6填AF_INET6</span><br>    <span class="hljs-type">char</span> sa_daat[<span class="hljs-number">14</span>];  <span class="hljs-comment">//14字节，包含目标地址和端口号</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>sockaddr_in结构体</code>：<strong>现在一般都使用这个结构体</strong>，他和sockaddr结构体的大小一样，只是<strong>将目标IP地址和端口号单独分出来</strong>，但是网络通信的接口都是用sockaddr作为参数，因此需要强转为sockaddr结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span>&#123;<br>    <span class="hljs-type">sa_family_t</span> sin_family;  <span class="hljs-comment">//协议族，一般填AF_INET，IPv6填AF_INET6</span><br>    <span class="hljs-type">in_port_t</span> sin_port;   <span class="hljs-comment">//网络字节序的端口号</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> sin_addr;  <span class="hljs-comment">//网络字节序的IP地址</span><br>    <span class="hljs-type">char</span> sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">//未使用，为了保持与sockaddr一样的长度所添加的</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>    <span class="hljs-type">uint32_t</span> s_addr;  <span class="hljs-comment">//网络字节序的IP地址，32位地址</span><br>&#125;;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> s;<br>s.sin_family=AF_INET <span class="hljs-keyword">or</span> AF_INET6;<br>s.sin_port=<span class="hljs-built_in">htons</span>(port);   <span class="hljs-comment">//将主机字节序端口转换为网络字节序再赋值</span><br><span class="hljs-comment">//如果IP地址是整形的主机字节序IP地址</span><br>s.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(IP);<br><span class="hljs-comment">//如果IP地址是整形的点分十进制IP地址</span><br><span class="hljs-type">int</span> dst;<br><span class="hljs-built_in">inet_pton</span>(AF_INET,IP,(<span class="hljs-type">void</span> *)&amp;dst);<br>s.sin_addr.s_addr=dst;<br>或<br>s.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(IP);<br><br>&gt;&gt;重点<br><span class="hljs-comment">/*【重点】*/</span><br><span class="hljs-comment">//无论IP地址啥格式直接使用下面这段代替</span><br><span class="hljs-comment">//使用宏INADDR_ANY,会自动取出系统中有效的任意IP地址，是主机字节序形式的</span><br>s.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);  <span class="hljs-comment">//将主机字节序转换为网络字节序</span><br><br><br><span class="hljs-comment">//强转sockaddr</span><br>(<span class="hljs-keyword">struct</span> sockaddr *)&amp;s;<br></code></pre></td></tr></table></figure></li><li><p><code>sockaddr_in6</code>：IPv6的sockaddr_in结构体</p></li><li><p><code>sockaddr_un</code>：本地套接字所用</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052946.png" alt="image-20240421163807676"></p><h3 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h3><h4 id="socket模型创建流程"><a href="#socket模型创建流程" class="headerlink" title="socket模型创建流程"></a>socket模型创建流程</h4><p><strong>服务端流程</strong>：</p><ol><li><strong>socket()创建一个套接字</strong>s1</li><li>使用<strong>bind()函数绑定IP地址和port端口号</strong></li><li>使用<strong>listen()设置同时与服务器建立连接的上限</strong></li><li><strong>accept()阻塞监听客户端连接</strong>，如果连接成功，释放s1,让s1继续监听客户端连接，返回一个新的套接字s2</li><li>使用<strong>read()、recv()读取客户端发送过来的请求与数据</strong></li><li>使用<strong>write()、send()回应客户端请求与数据</strong></li><li>当<strong>read()函数读到0时终止与客户端的连接</strong></li><li>使用<strong>close()关闭服务端连接</strong></li></ol><p><strong>客户端流程</strong>：</p><ol><li><strong>socket()创建套接字</strong>s3</li><li>使用<strong>connect()将套接字s3绑定IP地址和port端口，并与客户端连接</strong></li><li>使用<strong>write()、send()向服务端发送请求和数据</strong></li><li>使用<strong>read()、recv()接收服务端的响应和回应</strong></li><li>使用close()关闭连接</li></ol><p><strong>socket模型创建总体流程</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052947.png" alt="image-20240421171012820"></p><blockquote><p>注：</p><ul><li>总体流程一共创建了3个socket套接字</li><li><strong>read和write函数是对文件IO的API，send和recv是socket编程的API，因为socket实质也是一个文件描述符，所以也可以使用read和write进行发送以及接收数据</strong></li></ul></blockquote><h4 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h4><p><strong>概念</strong>：网络通信所需要使用的函数和接口</p><p><strong>函数和方法</strong></p><ul><li><code>int socket(int domain,int type,int protocol)</code>：<strong>创建一个套接字</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>domain:指定IP地址协议，取值为：<span class="hljs-built_in">AF_INET</span>(IPv4)、<span class="hljs-built_in">AF_INET6</span>(IPv6)、<span class="hljs-built_in">AF_UNIX</span>(本地套接字);<br><br>type:选用的数据传输协议，取值为：<span class="hljs-built_in">SOCK_STREAM</span>(流式传输)、<span class="hljs-built_in">SOCK_DGRAM</span>(报式传输);<br><br>protocol:表示选用的协议当中代表协议，一般传<span class="hljs-number">0</span>,流式传输协议代表协议为TCP，报式传输协议代表为UDP,也可以直接填IPPROTO_TCP或者IPPROTO_UDP;<br><br><span class="hljs-comment">//返回值</span><br>成功:新套接字所对应的文件描述符;<br><br>失败:<span class="hljs-number">-1</span> errno;<br></code></pre></td></tr></table></figure><ul><li><code>int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen)</code>：<strong>给socket套接字绑定一个地址结构(IP地址+端口号)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>sockfd:要绑定的socket的文件描述符，也就是<span class="hljs-built_in">socket</span>()返回的值;<br><br>addr:传入参数，sockaddr结构体，用于传入要绑定的IP地址和端口号，但是我们一般使用sockaddr_in所以需要强转，(<span class="hljs-keyword">struct</span> sockaddr *)&amp;s来强转;<br><br>addrlen:地址结构体(addr)的大小;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int listen(int sockfd,int backlog)</code>：<strong>设置同时与服务器建立连接的上限数</strong>(同时进行3次握手的客户端数量)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> backlog)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>sockfd:要绑定的socket的文件描述符，也就是<span class="hljs-built_in">socket</span>()返回的值;<br><br>backlog:上限数值，最大值<span class="hljs-number">128</span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li>【重<em>点】<code>int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen)</code>：*<em>阻塞等待客户端建立连接，成功返回一个与客户端连接的sockfd</em></em>(socket文件描述符)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sockfd:socket的文件描述符，也就是<span class="hljs-built_in">socket</span>()返回的值;<br><br>addr:传出参数，sockaddr结构体，用于传出成功与服务器建立连接的那个客户端的地址结构(IP地址和端口号);<br><br>addrlen:传入传出参数，传入是地址结构体(addr)的大小，传出是客户端addr实际大小;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回一个与客户端连接的sockfd;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int connect(int sockfd,const struct sockaddr *addr,socklen_t addrlen)</code>：<strong>客户端</strong>使用函数，<strong>使用现有的socket与服务器建立连接</strong>，<strong>可以不需要使用bind函数</strong>绑定客户端地址结构，因为<strong>他会采用”隐式绑定”地址结构</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>sockfd:客户端的socket的文件描述符，也就是<span class="hljs-built_in">socket</span>()返回的值;<br><br>addr:传入参数，要连接的服务器的地址结构(IP+port);<br><br>addrlen:服务器地址结构的大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>ssize_t read(int fd,void *buf,size_t count)</code>：原本<strong>是用于文件读取的操作，但是也可以用与socket的接收以及读取数据的操作</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:是一个指向读或写数据的缓冲区指针;<br><br>count:缓冲区长度;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回读到的字节数,<span class="hljs-number">0</span>，表示已经到达文件末尾;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br><span class="hljs-number">-1</span>:如果read返回<span class="hljs-number">-1</span>并且errno等于EAGIN或EWOULDBLOCK,说明不是read失败而是read以非阻塞读文件并且文件无数据<br><br><br><span class="hljs-comment">//创建缓冲区，可以使用BUFSIZ，BUFSIZ=4096</span><br><span class="hljs-type">char</span> buf[BUFSIZ];<br></code></pre></td></tr></table></figure><ul><li><code>ssize_t write(int fd,const void *buf,size_t count)</code>：<strong>用于进行文件写数据的操作</strong>，但是<strong>也可以用于socket通信的发送以及写数据的操作</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:待写出数据的缓冲区;<br><br>count:数据大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回写入的字节数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>ssize_t send(int sockfd,const void *buf,size_t len,int flags)</code>：<strong>用于网络套接字上发送数据和请求</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>sockfd:要发送数据或请求的socket文件描述符;<br><br>buf:是一个指向读或写数据的缓冲区指针;<br><br>len:缓冲区长度;<br><br>flags:是一组标志参数，控制着函数的行为，一般都置为<span class="hljs-number">0</span>;<br><span class="hljs-comment">//send()常用标志参数:</span><br>- MSG_DONTWAIT:非阻塞发送数据;<br>- MSG_MORE:告诉内核还有更多数据需要发送;<br>- MSG_NOSIGNAL:在发送数据时忽略SIGPIPE信号;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回指定长度的字节数;<br><br>失败:返回小于指定长度的字节数，errno;<br></code></pre></td></tr></table></figure><ul><li><code>ssize_t recv(int sockfd,void *buf,size_t len,int flags)</code>：<strong>用于在网络套接字接收数据或请求</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//参数</span><br><span class="hljs-comment">//参数</span><br>sockfd:要接收数据或请求的socket文件描述符;<br><br>buf:是一个指向读或写数据的缓冲区指针;<br><br>len:缓冲区长度;<br><br>flags:是一组标志参数，控制着函数的行为，一般都置为<span class="hljs-number">0</span>;<br><span class="hljs-comment">//recv()常用标志参数</span><br>- MSG_WAITALL:阻塞等待直到接收到指定长度的数据;<br>- MSG_PEEK:接收数据但不从接收缓冲区中删除数据;<br>- MSG_OOB:接收带外数据;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>，表示连接已经关闭;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int shutdown(int sockfd,int how)</code>：<strong>跟close函数差不多的功能，但是shutdown不考虑描述符的引用计数，直接关闭描述符，并且可以选择关闭读端还是写端还是读写端</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> how)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sockfd:套接字文件描述符;<br><br>how:允许为shutdown操作选择参数;<br><span class="hljs-comment">//选择</span><br><span class="hljs-built_in">SHUT_RD</span>(<span class="hljs-number">0</span>):关闭sockfd上的读端,任何当前在套接字接收缓冲区的数据将会被无声丢弃掉;<br><span class="hljs-built_in">SHUT_WR</span>(<span class="hljs-number">1</span>):关闭sockfd上的写端;<br><span class="hljs-built_in">SHUT_RDWR</span>(<span class="hljs-number">2</span>):关闭sockfd的读写端;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><strong>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接.</strong></li><li><strong>shutdown不考虑描述符的引用计数，直接关闭描述符.</strong></li><li>例如当我们使用dup2进行文件描述符重定向时，使用close源文件描述符并不能阻止其他指向源文件的文件描述符操作，而shutdown会关闭全部.</li></ul></blockquote><h3 id="C-S模型-TCP"><a href="#C-S模型-TCP" class="headerlink" title="C&#x2F;S模型 -TCP"></a>C&#x2F;S模型 -TCP</h3><h4 id="server的实现"><a href="#server的实现" class="headerlink" title="server的实现"></a>server的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 封装报错函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sys_err</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-built_in">perror</span>(str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//定义需要的变量</span><br>    <span class="hljs-type">int</span> sfd,cfd,ret;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addrlen;<br>    <span class="hljs-type">char</span> buf[BUFSIZ],cli_IP[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">//创建服务器socket</span><br>    sfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sfd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;socket error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将服务端地址结构初始化，服务器绑定地址结构</span><br>    serv_addr.sin_family=AF_INET;<br>    serv_addr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">5003</span>);<br>    serv_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="hljs-built_in">sizeof</span>(serv_addr))==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;bind error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//设置同时建立连接上限</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(sfd, <span class="hljs-number">128</span>)==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;listen error&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//阻塞等待客户端连接</span><br>    cli_addrlen=<span class="hljs-keyword">sizeof</span> cli_addr;<br>    cfd=<span class="hljs-built_in">accept</span>(sfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addrlen);<br><br>    <span class="hljs-keyword">if</span>(cfd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;accept error&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//输出客户端IP地址和端口号</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;client ip:&quot;</span>&lt;&lt;<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr)&lt;&lt;<span class="hljs-string">&quot; port:&quot;</span>&lt;&lt;<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port)&lt;&lt;std::endl;  <span class="hljs-comment">//以前的使用方法inet_ntoa</span><br>    <span class="hljs-comment">//或者：</span><br>    <span class="hljs-comment">//std::cout&lt;&lt;&quot;client ip:&quot;&lt;&lt;inet_ntop(AF_INET,&amp;cli_addr.sin_addr.s_addr,cli_IP,sizeof(cli_IP))&lt;&lt;&quot; port:&quot;&lt;&lt;ntohs(cli_addr.sin_port)&lt;&lt;std::endl;  //现在的使用方法inet_ntop</span><br>    <br>    <span class="hljs-comment">//开始发送数据以及接收数据操作</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        ret=<span class="hljs-built_in">read</span>(cfd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,ret);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ret;++i)&#123;<br>            buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>        &#125;<br>        n=<span class="hljs-built_in">write</span>(cfd,buf,ret);<br>    &#125;<br>    <br>    <span class="hljs-comment">//关闭连接</span><br>    <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-built_in">close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="client的实现"><a href="#client的实现" class="headerlink" title="client的实现"></a>client的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-comment">//封装报错函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sys_err</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-built_in">perror</span>(str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//定义所需变量</span><br>    <span class="hljs-type">int</span> cfd;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-comment">//初始化服务端地址结构</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    serv_addr.sin_family=AF_INET;<br>    serv_addr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">5003</span>);<br>    <span class="hljs-comment">// serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br>    serv_addr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>); <span class="hljs-comment">//以前使用</span><br>    <span class="hljs-comment">//或者:</span><br>    <span class="hljs-comment">// inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;serv_addr.sin_addr.s_addr); //现在使用的</span><br>    <br>    <span class="hljs-comment">//创建客户端socket</span><br>    cfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(cfd==<span class="hljs-number">-1</span>) <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;socket error&quot;</span>);<br>    <br>    <span class="hljs-comment">//进行与服务端连接</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(cfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="hljs-built_in">sizeof</span>(serv_addr))==<span class="hljs-number">-1</span>) <span class="hljs-built_in">sys_err</span>(<span class="hljs-string">&quot;connect error&quot;</span>);<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//与服务端通信</span><br>    <span class="hljs-keyword">while</span> (--count) &#123;<br>        <span class="hljs-built_in">write</span>(cfd,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">read</span>(cfd,buf,<span class="hljs-keyword">sizeof</span> buf);<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,ret);<br>        std::cout&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//关闭客户端连接</span><br>    <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TCP状态时序图"><a href="#TCP状态时序图" class="headerlink" title="TCP状态时序图"></a>TCP状态时序图</h4><p><strong>TCP状态转换图</strong>：</p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052948.jpeg"  /><p><strong>TCP各阶段状态图</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200052949.jpeg" alt="TCP各阶段状态图"></p><h3 id="出错处理函数封装"><a href="#出错处理函数封装" class="headerlink" title="出错处理函数封装"></a>出错处理函数封装</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>wrap.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _WRAP_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WRAP_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perr_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Accept</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-keyword">struct</span> sockaddr *sa,<span class="hljs-type">socklen_t</span> *salenptr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa,<span class="hljs-type">socklen_t</span> salen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa,<span class="hljs-type">socklen_t</span> salen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *ptr,<span class="hljs-type">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr,<span class="hljs-type">size_t</span> nbytes)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *vptr,<span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *vptr,<span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">my_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">char</span> *ptr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readline</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *vptr,<span class="hljs-type">size_t</span> maxlen)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="具体函数封装"><a href="#具体函数封装" class="headerlink" title="具体函数封装"></a>具体函数封装</h4><p>wrap.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perr_exit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>&#123;<br>    <span class="hljs-built_in">perror</span>(s);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Accept</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> *salenptr)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>again:<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">accept</span>(fd,sa,salenptr))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//ECONNABORTED表示连接被本地软件意外中断</span><br>        <span class="hljs-comment">//EINTR表示一个被阻塞的系统调用(如read,write,accept,connect等)被signal打断了</span><br>        <span class="hljs-keyword">if</span>((errno==ECONNABORTED)||(errno==EINTR)) <span class="hljs-keyword">goto</span> again;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 暂时没有新的连接请求到达，返回-1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;accept error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">bind</span>(fd,sa,salen))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;bind error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">connect</span>(fd,sa,salen))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;connect error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> backlog)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">listen</span>(fd,backlog))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;listen error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">socket</span>(family,type,protocol))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;socket error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span></span>&#123;<br>    <span class="hljs-type">ssize_t</span> n;<br><br>again:<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">read</span>(fd,ptr,nbytes))==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(errno==EINTR) <span class="hljs-keyword">goto</span> again;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> nbytes)</span></span>&#123;<br>    <span class="hljs-type">ssize_t</span> n;<br><br>again:<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">write</span>(fd,ptr,nbytes))==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(errno==EINTR) <span class="hljs-keyword">goto</span> again;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">close</span>(fd))==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;close error&quot;</span>);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">//参数三：是应该读取的字节数</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> nleft;<br>    <span class="hljs-type">ssize_t</span> nread;<br>    <span class="hljs-type">char</span> *ptr;<br><br>    ptr=(<span class="hljs-type">char</span> *)vptr;<br>    nleft=n;<br><br>    <span class="hljs-keyword">while</span> (nleft&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>((nread=<span class="hljs-built_in">read</span>(fd,ptr,nleft))&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(errno==EINTR) nread=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        nleft-=nread;<br>        ptr+=nread;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n-nleft;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> nleft;<br>    <span class="hljs-type">ssize_t</span> nwritten;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr;<br><br>    ptr=(<span class="hljs-type">char</span>*)vptr;<br>    nleft=n;<br>    <span class="hljs-keyword">while</span> (nleft&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>((nwritten=<span class="hljs-built_in">write</span>(fd,ptr,nleft))&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nwritten&lt;<span class="hljs-number">0</span>&amp;&amp;errno==EINTR) nwritten=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        nleft-=nwritten;<br>        ptr+=nwritten;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">my_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *ptr)</span></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> read_cnt;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> *read_ptr;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> read_buf[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-keyword">if</span>(read_cnt&lt;=<span class="hljs-number">0</span>)&#123;<br>again:<br>        <span class="hljs-keyword">if</span>((read_cnt=<span class="hljs-built_in">read</span>(fd,read_buf,<span class="hljs-built_in">sizeof</span>(read_buf)))&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(errno==EINTR) <span class="hljs-keyword">goto</span> again;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_cnt==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        read_ptr=read_buf;<br>    &#125;<br>    read_cnt--;<br>    *ptr=*read_ptr++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//readline ---fgets</span><br><span class="hljs-comment">//传出参数 vptr</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Readline</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *vptr, <span class="hljs-type">size_t</span> maxlen)</span></span>&#123;<br>    <span class="hljs-type">ssize_t</span> n,rc;<br>    <span class="hljs-type">char</span> c,*ptr;<br>    ptr=(<span class="hljs-type">char</span>*)vptr;<br><br>    <span class="hljs-keyword">for</span>(n=<span class="hljs-number">1</span>;n&lt;maxlen;++n)&#123;<br>        <span class="hljs-keyword">if</span>((rc=<span class="hljs-built_in">my_read</span>(fd, &amp;c))==<span class="hljs-number">1</span>)&#123;<br>            *ptr++=c;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rc==<span class="hljs-number">0</span>)&#123;<br>            *ptr=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    *ptr=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新client"><a href="#新client" class="headerlink" title="新client"></a>新client</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//定义所需变量</span><br>    <span class="hljs-type">int</span> cfd,n;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> ser_addr;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-comment">//初始化服务端地址结构</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    serv_addr.sin_family=AF_INET;<br>    serv_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    <span class="hljs-comment">// serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br>    serv_addr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    <span class="hljs-comment">//或者:</span><br>    <span class="hljs-comment">// inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;serv_addr.sin_addr.s_addr);</span><br>    <br>    <span class="hljs-comment">//创建客户端socket</span><br>    cfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//进行与服务端连接</span><br>    <span class="hljs-built_in">Connect</span>(cfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="hljs-built_in">sizeof</span>(serv_addr));<br><br>    <span class="hljs-comment">//与服务端通信</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fgets</span>(buf,BUFSIZ,stdin)!=<span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">Write</span>(cfd,buf,<span class="hljs-built_in">strlen</span>(buf));<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">Read</span>(cfd,buf,BUFSIZ);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the other side has been closed.\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,ret);<br>    &#125;<br>    <span class="hljs-comment">//关闭客户端连接</span><br>    <span class="hljs-built_in">Close</span>(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新server"><a href="#新server" class="headerlink" title="新server"></a>新server</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//定义需要的变量</span><br>    <span class="hljs-type">int</span> sfd,cfd,ret;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addrlen;<br>    <span class="hljs-type">char</span> buf[BUFSIZ],cli_IP[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-comment">//创建服务器socket</span><br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//将服务端地址结构初始化，服务器绑定地址结构</span><br>    serv_addr.sin_family=AF_INET;<br>    serv_addr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">5003</span>);<br>    serv_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="hljs-built_in">sizeof</span>(serv_addr));<br><br>    <span class="hljs-comment">//设置同时建立连接上限</span><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br>    <br>    <span class="hljs-comment">//阻塞等待客户端连接</span><br>    cli_addrlen=<span class="hljs-keyword">sizeof</span> cli_addr;<br>    cfd=<span class="hljs-built_in">Accept</span>(sfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addrlen);<br><br>    <span class="hljs-comment">//输出客户端IP地址和端口号</span><br>    <span class="hljs-comment">// std::cout&lt;&lt;&quot;client ip:&quot;&lt;&lt;inet_ntoa(cli_addr.sin_addr)&lt;&lt;&quot; port:&quot;&lt;&lt;ntohs(cli_addr.sin_port)&lt;&lt;std::endl;</span><br>    <span class="hljs-comment">//或者：</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;client ip:&quot;</span>&lt;&lt;<span class="hljs-built_in">inet_ntop</span>(AF_INET,&amp;cli_addr.sin_addr.s_addr,cli_IP,<span class="hljs-built_in">sizeof</span>(cli_IP))&lt;&lt;<span class="hljs-string">&quot; port:&quot;</span>&lt;&lt;<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port)&lt;&lt;std::endl;<br>    <span class="hljs-comment">//开始发送数据以及接收数据操作</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        ret=<span class="hljs-built_in">Read</span>(cfd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,ret);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ret;++i)&#123;<br>            buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>        &#125;<br>        n=<span class="hljs-built_in">Write</span>(cfd,buf,ret);<br>    &#125;<br>    <br>    <span class="hljs-comment">//关闭连接</span><br>    <span class="hljs-built_in">Close</span>(cfd);<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p><strong>概念</strong>：</p><ul><li><p><code>端口复用</code>：<strong>解决服务端先关闭导致服务端并未真正关闭，导致端口被占用需要等待2MSL(40s左右)才能重新启动同一端口的服务端程序问题</strong>，使端口复用！</p></li><li><blockquote><p>端口复用解决的具体问题产生原因：</p><p><strong>当我们每次先关闭服务端程序运行再关闭客户端的时候，我们会发现再次启动服务端程序会发现报错说端口正在被使用</strong>，这涉及到了TCP中的连接问题，<strong>在TCP的四次挥手中，TCP会提供客户端未收到服务端的FIN包的等待重传机制</strong>(这个时候服务端并未真正处于CLOSED状态)，将会<strong>导致客户端不知道服务端是否收到导致ack包到底发不发的问题，因此TCP设置让客户端等待2MSL(40多s)后再继续重发机制！而这个2MSL中服务端是处于TIME_WAIT状态，并未真正关闭</strong>，因此我们需要等待2MSL时间才能成功启动服务端程序</p></blockquote></li></ul><p><strong>函数原型</strong>：</p><p><code>int setsockopt(int sockfd,int level,int optname,const void *optval,socklen_t optlen)</code>：<strong>套接字设置函数，可以设置套接字的选项以及属性(选项很多复杂)，我们这里用来进行端口复用</strong>，这里只讨论端口复用如何使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> level,<span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval,<span class="hljs-type">socklen_t</span> optlen)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sockfd:套接字文件描述符;<br><br>level:给套接字设置的选项的级别;<br><span class="hljs-comment">//端口复用选择</span><br>SOL_SOCKET;<br><br>optname:设置的选项;<br><span class="hljs-comment">//选择</span><br>SO_REUSEADDR:允许复用本地地址,数据类型为<span class="hljs-type">int</span>;<br>SO_REUSEPORT:允许复用本地端口,数据类型为<span class="hljs-type">int</span>;<br><br>optval:选项值设置;<br><span class="hljs-number">1</span>:端口复用;<br><span class="hljs-number">0</span>:不使用端口复用;<br><br>optlen:选项值长度;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br><br><br><span class="hljs-comment">//端口复用使用示例</span><br><span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;    <span class="hljs-comment">//设置端口复用</span><br><span class="hljs-built_in">setsockopt</span>(sfd,SOL_SOCKET,SO_REUSEPORT,(<span class="hljs-type">void</span> *)&amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br></code></pre></td></tr></table></figure><blockquote><p>注：需要在socket函数和bind函数之间进行执行！</p></blockquote><h2 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h2><p><strong>实现思路</strong>：</p><ol><li><strong>创建监听套接字sfd</strong>，Socket()</li><li><strong>绑定地址结构sockaddr_in并强转成sockaddr</strong>，Bind()</li><li><strong>设置监听上限</strong>，Listen()</li><li><strong>父进程(pid&gt;0)进行监听，创建cfd与子进程(pid&#x3D;&#x3D;0)，注册信号捕捉函数非阻塞回收子进程，父进程关闭通信套接字cfd</strong>，Accept()，fork()，close(cfd)，SIGCHLD，waitpid()。</li><li><strong>子进程接收客户端连接请求以及执行服务端代码，子进程关闭监听套接字</strong>sfd，close(sfd)，read()</li></ol><p><strong>实现示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">catch_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,WNOHANG)&gt;<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,cfd,pid,ret,i;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br><br>    <span class="hljs-comment">//将地址结构清0</span><br>    <span class="hljs-comment">// memset(&amp;ser_addr,0,sizeof(ser_addr));</span><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    <br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd, <span class="hljs-number">128</span>);<br>    <br>    cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);<br><br>        <span class="hljs-comment">//创建子进程</span><br>        pid=fork();<br>        <span class="hljs-keyword">if</span>(pid&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//子进程</span><br>            <span class="hljs-built_in">close</span>(sfd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;                  <span class="hljs-comment">//父进程</span><br>            <span class="hljs-keyword">struct</span> sigaction act;<br>            act.sa_handler=catch_child;<br>            <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>            act.sa_flags=<span class="hljs-number">0</span>;<br>            ret=<span class="hljs-built_in">sigaction</span>(SIGCHLD,&amp;act,<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;sigaction error&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">close</span>(cfd);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//子进程主体代码</span><br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            ret=<span class="hljs-built_in">Read</span>(cfd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>            <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">close</span>(cfd);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;ret;++i)&#123;<br>                buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>            &#125;<br>            <span class="hljs-built_in">Write</span>(cfd,buf,ret);<br>            <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,ret);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//编译</span><br>g++ process_server.cpp wrap.cpp -o process_server<br><br>    <br><span class="hljs-comment">//运行</span><br>./process_server<br><span class="hljs-comment">//开多个终端连接服务端</span><br>nc <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">5005</span><br></code></pre></td></tr></table></figure><blockquote><p>可以使用<code>scp -r 本地代码目录 目标服务器用户名@公网IP地址:要存入的路径</code>，将代码上传到服务器上测试</p></blockquote><h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h2><p><strong>实现思路</strong>：</p><ol><li><strong>创建监听套接字sfd</strong>，Socket()</li><li><strong>绑定地址结构sockaddr_in并强转成sockaddr</strong>，Bind()</li><li><strong>设置监听上限</strong>，Listen()</li><li><strong>父线程进行监听，创建子线程和cfd，使用线程分离非阻塞回收子线程(如果需要返回值，则需要创建一个专门子线程回收子线程，pthread_join回收子线程退出值)，父线程关闭通信套接字cfd</strong>，Accept()，pthread_create()，pthread_detach，close(cfd)，</li><li><strong>子线程接收客户端请求并执行服务端代码，子线程关闭监听套接字sfd</strong>，close(sfd)，read()</li></ol><p><strong>实现示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 8192</span><br><br><br><span class="hljs-comment">//定义一个结构体，将地址结构跟cfd捆绑，也可以不使用</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s_info</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cli_addr;<br>    <span class="hljs-type">int</span> cfd;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">do_work</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> n,i;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">s_info</span> *ts=(<span class="hljs-keyword">struct</span> s_info*)arg;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">char</span> str[INET_ADDRSTRLEN];   <span class="hljs-comment">//INET_ADDRSTRLEN=16</span><br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//读客户端</span><br>        n=<span class="hljs-built_in">Read</span>(ts-&gt;cfd,buf,MAXLINE);<br>        <span class="hljs-comment">//读完跳出循环，关闭cfd</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the client %d closed ...\n&quot;</span>,ts-&gt;cfd);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//打印客户端信息</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recevied from %s at PORT %d\n&quot;</span>,<span class="hljs-built_in">inet_ntoa</span>(ts-&gt;cli_addr.sin_addr),<span class="hljs-built_in">ntohs</span>((*ts).cli_addr.sin_port));   <span class="hljs-comment">//以前使用的</span><br>        <span class="hljs-comment">// printf(&quot;recevied from %s at PORT %d\n&quot;,inet_ntop(AF_INET,&amp;ts-&gt;cli_addr.sin_addr,str,sizeof(str)),ntohs((*ts).cli_addr.sin_port));   //现在使用的</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>        &#125;<br>        <span class="hljs-comment">//写数据</span><br>        <span class="hljs-built_in">Write</span>(ts-&gt;cfd,buf,n);<br>        <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,n);<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(ts-&gt;cfd);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;   <span class="hljs-comment">//pthread_exit(0);</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    <span class="hljs-type">int</span> sfd,cfd;<br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">s_info</span> ts[<span class="hljs-number">256</span>];  <span class="hljs-comment">//创建结构体数组</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//地址结构清0</span><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr, <span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br><br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepting client connect ...\n&quot;</span>);<br>    cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//阻塞监听客户端连接请求</span><br>        cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);<br>        ts[i].cli_addr=cli_addr;<br>        ts[i].cfd=cfd;<br>        <span class="hljs-comment">//创建子线程来执行服务端代码</span><br>        <span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,do_work,(<span class="hljs-type">void</span> *)&amp;ts[i]);<br>        <span class="hljs-comment">//子线程分离，进行子线程回收，防止僵尸线程产生</span><br>        <span class="hljs-built_in">pthread_detach</span>(tid);<br>        ++i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多路I-O转接服务器"><a href="#多路I-O转接服务器" class="headerlink" title="多路I&#x2F;O转接服务器"></a>多路I&#x2F;O转接服务器</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>之前讲的服务端程序使用的方式就是阻塞模式或者非阻塞忙轮询模式，而这些模式的效率很低，因此我们引入了响应式的多路IO转接模式</li><li><code>阻塞</code>：<strong>一直等待事件发生</strong></li><li><code>非阻塞忙轮询</code>：<strong>就是不阻塞</strong>，但是<strong>会一直循环查看事件是否发生</strong></li><li><code>多路I/O转接</code>：<strong>响应式，当事件发生就唤醒服务端</strong></li><li>多路IO转接服务器也叫做多任务IO服务器，这类服务器实现的主旨思想是，不再游应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件</li></ul><h3 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h3><p><strong>概念</strong>：</p><ul><li><code>select模型</code>：<strong>采用内核作为代理代替应用程序进行轮询，解决了accept监听阻塞等待问题，并没有解决客户端与服务端通信之间的阻塞</strong></li><li>在非阻塞忙轮询的模式中，我们的应用程序需要不断地轮询(polling)获得客户端的请求，而每次轮询就是一次系统调用，这样的效率不够好，而在select模型中，我们选择使用内核作为代理代替应用程序去轮询</li></ul><p><strong>select模型原理</strong>：</p><ol><li><strong>select作为内核代理，将会持有原先服务端的监听套接字sfd</strong>，来监听客户端，解放服务端程序</li><li><strong>对于多个客户端连接套接字cfd(文件描述符)，select会将其放入一个等待队列中</strong></li><li>然后<strong>select调用的时候会遍历队列，如果客户端发送请求或数据，会调用服务端程序的回调事件</strong>(也就是服务端和客户端还是直接通信，select并未进行协助)</li><li>当<strong>遍历结束之后，如果仍然没有一个可用的文件描述符(也就是客户端没有请求)，select会让用户进程睡眠，直到等待资源可用的时候(也就是客户端有请求时)再唤醒用户进程并返回对应的文件描述符</strong>(调用应用进程的回调事件)</li></ol><p><strong>优点</strong>：</p><ul><li><strong>跨平台进行文件描述符监听</strong>，例如windows、macos、linux、Unix、类Unix、mipe系统都可以使用</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>监听上限受文件描述符限制，最大1024个</strong></li><li><strong>select模型需要遍历所有文件描述符队列</strong>，没有监听或者事件发生的文件描述符也被遍历，导致效率不够理想</li><li><strong>select的每次调用都需要重复的复制集合，而且在select内部需要将集合从用户区复制到内核区，等有事件来又需要将数据从内核区复制到用户区</strong>，导致select的性能受限</li></ul><p><strong>函数</strong>：</p><ul><li><code>int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)</code>:<strong>创建select</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,<span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span>&#123;<br>    <span class="hljs-type">long</span> tv_sec;  <span class="hljs-comment">//秒</span><br>    <span class="hljs-type">long</span> tv_usec;  <span class="hljs-comment">//微妙</span><br>&#125;;<br><br><br><span class="hljs-comment">//参数</span><br>nfds:所监听的所有文件描述符当中最大的文件描述符+<span class="hljs-number">1</span>，也就是等待队列长度;<br><br>readfds:传入传出参数，传入要监听读事件的文件描述符集合，传出刚刚传入的集合中发生读事件的文件描述符集合,没有传<span class="hljs-literal">NULL</span>;<br><br>writefds:传入传出参数，传入要监听写事件的文件描述符集合，传出刚刚传入的集合中发生写事件的文件描述符集合,没有传<span class="hljs-literal">NULL</span>;<br><br>exceptfds:传入传出参数，传入要监听异常事件的文件描述符集合，传出刚刚传入的集合中发生异常事件的文件描述符集合,没有传<span class="hljs-literal">NULL</span>;<br><br>timeout:定时阻塞监控时间;<br><span class="hljs-comment">//选择</span><br><span class="hljs-literal">NULL</span>:阻塞监听;<br>&gt;<span class="hljs-number">0</span>:设置监听超时时长;<br><span class="hljs-number">0</span>:非阻塞监听,轮询;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回满足对应监听事件的文件描述符总个数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>void FD_ZERO(fd_set *set)</code>：<strong>把文件描述符集合(监听集合)清空</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>set:要清空的文件描述符集合;<br></code></pre></td></tr></table></figure><ul><li><code>void FD_CLR(int fd,fd_set *set)</code>：<strong>把文件描述符集合某个文件描述符从监听集合中移除</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,fd_set *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要移除的文件描述符;<br><br>set:文件描述符集合;<br></code></pre></td></tr></table></figure><ul><li><code>void FD_SET(int fd,fd_set *set)</code>：<strong>将fd文件描述符添加到set监听集合中</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,fd_set *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要添加的文件描述符;<br><br>set:文件描述符集合;<br></code></pre></td></tr></table></figure><ul><li><code>int FD_ISSET(int fd,fd_set *set)</code>：<strong>判断fd文件描述符是否存在于set监听集合中</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,fd_set *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要判断的文件描述符;<br><br>set:文件描述符集合;<br><br><br><span class="hljs-comment">//返回值</span><br>&gt;<span class="hljs-number">0</span>:说明fd存在于set集合;<br><br>=<span class="hljs-number">0</span>:说明fd不存在于set集合;<br></code></pre></td></tr></table></figure><p><strong>select实现多路IO转接服务器</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,ret,cfd,n;<br>    <span class="hljs-type">int</span> mfd=<span class="hljs-number">0</span>;  <span class="hljs-comment">//最大文件描述符</span><br>    sockaddr_in ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    <br>    <span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;<br>    ret=<span class="hljs-built_in">setsockopt</span>(sfd,SOL_SOCKET,SO_REUSEPORT,&amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;setsockopt error&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br><br>    <span class="hljs-comment">//构造select监听文件描述符集合</span><br>    fd_set rset,allset;   <span class="hljs-comment">//rset读事件文件描述符集合，allset用来暂存</span><br><br>    mfd=sfd;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;allset);   <span class="hljs-comment">//集合清空;</span><br>    <span class="hljs-built_in">FD_SET</span>(sfd,&amp;allset);   <span class="hljs-comment">//添加sfd到read集合;</span><br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        rset=allset;    <span class="hljs-comment">//每次循环都更新设置select监控集合</span><br>        <span class="hljs-type">int</span> nready=<span class="hljs-built_in">select</span>(mfd+<span class="hljs-number">1</span>,&amp;rset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(nready&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;select error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//说明有新的客户端连接请求</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(sfd, &amp;rset))&#123;<br>            cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>            cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);   <span class="hljs-comment">//不会阻塞</span><br>            <span class="hljs-built_in">FD_SET</span>(cfd, &amp;allset);        <span class="hljs-comment">//向监控集合添加新客户端的文件描述符</span><br>            <span class="hljs-keyword">if</span>(mfd&lt;cfd)&#123;            <span class="hljs-comment">//更新最大文件描述符</span><br>                mfd=cfd;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>==--nready)&#123;         <span class="hljs-comment">//只有sfd有事件(也就是客户端文件描述符没有事件)，后续的for不需要执行</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//等价于</span><br>            <span class="hljs-comment">// if(1==nready) continue;</span><br>        &#125;<br>        <span class="hljs-comment">//检测哪个客户端需要发送数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sfd+<span class="hljs-number">1</span>;i&lt;=mfd;++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(i, &amp;rset))&#123;<br>                <span class="hljs-comment">//当客户端关闭连接时，服务端也关闭对应连接</span><br>                <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">Read</span>(i,buf,<span class="hljs-built_in">sizeof</span>(buf)))==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">Close</span>(i);<br>                    <span class="hljs-built_in">FD_CLR</span>(i, &amp;allset);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                    buf[j]=<span class="hljs-built_in">toupper</span>(buf[j]);<br>                &#125;<br>                <span class="hljs-built_in">Write</span>(i,buf,n);<br>                <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,n);<br>            &#125;<br>       &#125;<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化</strong>：</p><ul><li><strong>对于select模型需要遍历不必遍历的文件描述符而造成的效率丢失</strong>，我们可以<strong>使用一个自定义数组用于存储客户端的文件描述符来提高效率</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,ret,cfd,clifd,n;<br>    <span class="hljs-type">int</span> mfd=<span class="hljs-number">0</span>;  <span class="hljs-comment">//最大文件描述符</span><br>    sockaddr_in ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    <br>    <span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;<br>    ret=<span class="hljs-built_in">setsockopt</span>(sfd,SOL_SOCKET,SO_REUSEPORT,&amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;setsockopt error&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br><br>    <span class="hljs-comment">//构造select监听文件描述符集合</span><br>    fd_set rset,allset;   <span class="hljs-comment">//rset读事件文件描述符集合，allset用来暂存</span><br><br>    mfd=sfd;<br>    <span class="hljs-type">int</span> maxi=<span class="hljs-number">-1</span>,cli[FD_SETSIZE];   <span class="hljs-comment">//自定义数组cli,FD_SETSIZE默认为1024</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;FD_SETSIZE;++i)&#123;<br>        cli[i]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;allset);   <span class="hljs-comment">//集合清空;</span><br>    <span class="hljs-built_in">FD_SET</span>(sfd,&amp;allset);   <span class="hljs-comment">//添加sfd到read集合;</span><br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        rset=allset;    <span class="hljs-comment">//每次循环都更新设置select监控集合</span><br>        <span class="hljs-type">int</span> nready=<span class="hljs-built_in">select</span>(mfd+<span class="hljs-number">1</span>,&amp;rset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(nready&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;select error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//说明有新的客户端连接请求</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(sfd, &amp;rset))&#123;<br>            cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>            cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);   <span class="hljs-comment">//不会阻塞</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recevied from %s at PROT %d\n&quot;</span>,<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr),<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port));<br>            <span class="hljs-type">int</span> k;<br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;FD_SETSIZE;++k)&#123;<br>                <span class="hljs-keyword">if</span>(cli[k]&lt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//找cli[]中没有使用的位置</span><br>                    cli[k]=cfd;   <span class="hljs-comment">//保存accept返回的文件描述符到cli</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k==FD_SETSIZE)&#123;<br>                <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;too many clients\n&quot;</span>,stderr);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-built_in">FD_SET</span>(cfd, &amp;allset);        <span class="hljs-comment">//向监控集合添加新客户端的文件描述符</span><br>            <span class="hljs-keyword">if</span>(mfd&lt;cfd)&#123;            <span class="hljs-comment">//更新最大文件描述符</span><br>                mfd=cfd;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(k&gt;maxi)&#123;<br>                maxi=k;     <span class="hljs-comment">//保证maxi存的总是cli[]最后一个元素下标</span><br>            &#125;<br><br><br>            <span class="hljs-keyword">if</span>(--nready&lt;=<span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//只有sfd有事件(也就是客户端文件描述符没有事件)，后续的for不需要执行</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//等价于</span><br>            <span class="hljs-comment">// if(1==nready) continue;</span><br>        &#125;<br>        <span class="hljs-comment">//检测哪个客户端需要发送数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=maxi;++i)&#123;<br>            <span class="hljs-keyword">if</span>((clifd=cli[i])&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(clifd, &amp;rset))&#123;<br>                <span class="hljs-comment">//当客户端关闭连接时，服务端也关闭对应连接</span><br>                <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">Read</span>(clifd,buf,<span class="hljs-built_in">sizeof</span>(buf)))==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                    <span class="hljs-built_in">FD_CLR</span>(clifd, &amp;allset);<br>                    cli[i]=<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                    buf[j]=<span class="hljs-built_in">toupper</span>(buf[j]);<br>                &#125;<br>                <span class="hljs-built_in">Write</span>(clifd,buf,n);<br>                <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,n);<br>                <span class="hljs-comment">//将满足事件发生的文件描述符的事件处理完后就可以跳出for循环，继续监听事件发生</span><br>                <span class="hljs-keyword">if</span>(--nready&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//跳出for循环</span><br>            &#125;<br>       &#125;<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="poll模型"><a href="#poll模型" class="headerlink" title="poll模型"></a>poll模型</h3><p><strong>概念</strong>：</p><ul><li><strong>poll本质上是对select的改进，但是由于一些原因，poll并没有解决性能问题，只是在参数层面做了优化和解除了通过宏定义来设置的限制</strong>。因此poll只能说是一个半成品</li></ul><p><strong>函数原型</strong>：</p><p><code>int poll(struct pollfd *fds,nfds_t nfds,int timeout)</code>：<strong>创建poll</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br>   <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">//待监听的文件描述符</span><br>   <span class="hljs-type">short</span> events;     <span class="hljs-comment">//待监听的事件(读、写、异常)</span><br>   <span class="hljs-comment">//events取值：读POLLIN、写POLLOUT、异常POLLERR</span><br>   <span class="hljs-type">short</span> revents;    <span class="hljs-comment">//返回监听事件触发事件次数，传入要传0,如果传出非0就监听事件触发</span><br>&#125;;<br><br><span class="hljs-comment">//参数</span><br>fds:要监听的文件描述符[数组];<br><br>nfds:监听数组的实际有效监听个数;<br><br>timeout:监听超时时长;<br><span class="hljs-comment">//以毫秒为单位</span><br><span class="hljs-number">-1</span>:阻塞等待;<br><span class="hljs-number">0</span>:立即返回，非阻塞;<br>&gt;<span class="hljs-number">0</span>:等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回满足对应监听事件的文件描述符总个数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ul><li><strong>自带数组结构</strong></li><li>可以<strong>将监听事件集合和返回事件集合分离</strong>，无需每次调用时，重新设定监听事件</li><li><code>可以拓展监听上限</code>，超出1024上限</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不能跨平台</strong>，只能在Linux系统下使用</li><li><strong>无法直接定位满足监听事件的文件描述符，需要挨个轮询</strong></li></ul><p><strong>poll实现多路IO转接服务器</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPENMAX 1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,cfd,clifd,ret,n;<br>    sockaddr_in ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> cli[OPENMAX];<br><br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr, <span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br><br><br>    <span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;<br>    ret=<span class="hljs-built_in">setsockopt</span>(sfd,SOL_SOCKET,SO_REUSEPORT,&amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br>    <span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;setsockopt error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br><br>    cli[<span class="hljs-number">0</span>].fd=sfd;       <span class="hljs-comment">//将服务端监听文件描述符加入监听数组</span><br>    cli[<span class="hljs-number">0</span>].events=POLLIN;    <span class="hljs-comment">//监听事件是读事件</span><br>    <span class="hljs-comment">// cli[0].revents=0;       //默认为0</span><br>    cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;OPENMAX;++i)&#123;<br>        cli[i].fd=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> maxi=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> nready=<span class="hljs-built_in">poll</span>(cli,maxi+<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);   <span class="hljs-comment">//阻塞监听是否有客户端链接请求</span><br>        <span class="hljs-keyword">if</span>(nready&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;poll error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//sfd有读事件就绪</span><br>        <span class="hljs-keyword">if</span>(cli[<span class="hljs-number">0</span>].revents&amp;POLLIN)&#123;<br>            cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;received from %s at PORT %d\n&quot;</span>,<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr),<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port));<br>            <span class="hljs-type">int</span> k;<br>            <span class="hljs-comment">//找到cli[]中空闲位置，存放新客户端的cfd</span><br>            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;OPENMAX;++k)&#123;<br>                <span class="hljs-keyword">if</span>(cli[k].fd&lt;<span class="hljs-number">0</span>)&#123;<br>                    cli[k].fd=cfd;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//达到来最大客户端数</span><br>            <span class="hljs-keyword">if</span>(k==OPENMAX)&#123;<br>                <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;too many clients&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//设置新客户端的监听事件</span><br>            cli[k].events=POLLIN;<br>            <span class="hljs-comment">//更新cli[]中最大元素下标</span><br>            <span class="hljs-keyword">if</span>(k&gt;maxi)&#123;<br>                maxi=k;<br>            &#125;<br>            <span class="hljs-comment">//没有事件发生，继续回到poll阻塞监听</span><br>            <span class="hljs-keyword">if</span>(--nready&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//查看是否有客户端事件就绪</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxi;++i)&#123;<br>            <span class="hljs-keyword">if</span>((clifd=cli[i].fd)&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(cli[i].revents&amp;POLLIN)&#123;<br>                <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">Read</span>(clifd,buf,<span class="hljs-built_in">sizeof</span>(buf)))&lt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//受到RST标志,客户端异常退出</span><br>                    <span class="hljs-keyword">if</span>(errno==ECONNRESET)&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] aborted connection\n&quot;</span>,i);<br>                        <span class="hljs-built_in">Close</span>(clifd);<br>                        cli[i].fd=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//将其移除监听数组</span><br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">//客户端先关闭连接</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] closed connection\n&quot;</span>,i);<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                    cli[i].fd=<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                        buf[j]=<span class="hljs-built_in">toupper</span>(buf[j]);<br>                    &#125;<br>                    <span class="hljs-built_in">Writen</span>(clifd,buf,n);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(--nready&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><p><strong>概念</strong>：</p><ul><li><p><code>epoll</code><strong>复用了等待队列，并且添加了就绪列表</strong>，当监听事件发生时，进行回传通知，而<strong>事件通知的时机又提供了水平触发(LT)和边缘触发(ET)</strong></p></li><li><p>epoll既<strong>提供了select&#x2F;poll的IO事件的水平触发(LT)，也提供了边缘触发(ET)机制</strong>，这就使得用户空间程序有可能缓存IO状态，减少epoll_wait&#x2F;epoll_pwait的使用，提供应用程序效率</p></li><li><p><code>等待队列</code>：<strong>采用红黑树进行存储被监听的客户端文件描述符</strong></p></li><li><p><code>就绪列表</code>：<strong>使用双向链表进行存储事件触发就绪的文件描述符</strong></p></li><li><p><strong>epoll是Linux下多路复用IO接口select&#x2F;poll的增强版本</strong>，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率</p><blockquote><p><strong>原因</strong>：</p><ol><li>因为<strong>它会复用文件描述符集合(等待队列)来传递结果</strong>而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合</li><li><strong>无须遍历整个被侦听的描述符集</strong>，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的文件描述符集合即可</li></ol></blockquote></li></ul><p><strong>ET和LT模式</strong>：</p><ul><li><p><code>边缘触发(ET)</code>：全名edge trigger，<strong>只有事件触发，或是timeout时epoll_wait才会回传，不管缓冲区是否还有数据</strong>，<code>只支持非阻塞socket</code>，使用fcntl函数设置非阻塞套接字</p><blockquote><p>优点：<strong>开销小</strong>，不用过度处理消息</p><p>缺点：编码难度大，<strong>需要注意事件无法一次性处理完，导致下次触发事件却处理着上次事件剩下的数据(遗漏事件处理)</strong></p></blockquote></li><li><p><code>水平触发(LT)</code>：默认采用模式，全名level trigger，<strong>epoll_wait在事件状态未变更前都会回传，只要缓冲区有数据都会触发</strong></p><blockquote><p>优点：编码难度较简单，不会遗漏事件处理</p><p>缺点：开销较大</p></blockquote></li></ul><p><strong>注意</strong>：</p><ul><li>epoll的本质就是监听文件描述符，因此<strong>epoll不仅可以用来监听套接字，也可用于管道、fifo、mmap映射等</strong></li></ul><p><strong>突破1024文件描述符限制</strong>：</p><ul><li>可以使用cat命令查看当前计算机可以打开的socket描述符上限，受硬件影响</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/sys/fs/file-max<br></code></pre></td></tr></table></figure><ul><li>使用ulimit命令查看当前用户下的进程，默认打开文件描述符上限，缺省为1024</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ulimit -a<br></code></pre></td></tr></table></figure><ul><li>修改配置文件修改上限值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nvim /etc/security/limits.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在文件尾部<span class="hljs-comment">#end of file之前写下以下配置，soft为软限制，hard为硬限制</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">soft为默认值，可以使用命令修改，但是不能超过hard值</span><br>*softnofile65536<br>*hardnofile100000<br></code></pre></td></tr></table></figure><p><strong>工作流程</strong>：</p><ol><li>epoll<strong>维护一个等待队列(红黑树)和一个就绪列表(链表)</strong></li><li>然后<strong>需要监听的socket文件描述符就添加到等待队列中</strong></li><li>当哪个客户端<strong>socket有事件触发，就将其加入到就绪列表中</strong></li><li>然后<strong>回传通知给服务端，服务端直接遍历就绪列表中，挨个处理即可</strong></li></ol><p><strong>函数原型</strong>：</p><ul><li><code>int epoll_create(int size)</code>：<strong>创建epoll文件描述符,也就是指向红黑树根节点的文件描述符</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>size:创建的红黑树的监听节点数量.(仅供内核参考);<br><br><span class="hljs-comment">//返回值</span><br>成功:epoll文件描述符,也就是指向红黑树根节点的文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)</code>：<strong>用来控制红黑树</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd,<span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span>&#123;<br>    <span class="hljs-type">uint32_t</span> events;    <span class="hljs-comment">//事件类型</span><br>    <span class="hljs-type">epoll_data_t</span> data;  <span class="hljs-comment">//数据</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">union</span> epoll_data&#123;<br>    <span class="hljs-type">void</span> *ptr;   <span class="hljs-comment">//指定与fd相关的用户数据 </span><br>    <span class="hljs-type">int</span> fd;    <span class="hljs-comment">//对应监听事件的fd</span><br>    <span class="hljs-type">uint32_t</span> u32;    <span class="hljs-comment">//不用</span><br>    <span class="hljs-type">uint64_t</span> u64;    <span class="hljs-comment">//不用</span><br>&#125;<span class="hljs-type">epoll_data_t</span>;<br><br><br><span class="hljs-comment">//参数</span><br>epfd:epoll文件描述符;<br><br>op:对该监听红黑树所做的操作参数;<br><span class="hljs-comment">//选择：</span><br>EPOLL_CTL_ADD:添加一个节点到红黑树上;<br>EPOLL_CTL_MOD:修改红黑树上节点的监听事件;<br>EPOLL_CTL_DEL:将fd从红黑树上移除;<br><br>fd:待监听文件描述符;<br><br>event:要设定监听事件参数,本质为epoll_event结构体;<br><span class="hljs-comment">//成员：</span><br>events:传事件类型，默认为LT机制，要想使用ET就需要或上EPOLLET;<br><span class="hljs-comment">//读EPOLLIN、写EPOLLOUT、异常EPOLLERR</span><br><br>data:存储用户数据，<span class="hljs-type">epoll_data_t</span> 联合体;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout)</code>：<strong>监听等待队列的客户端socket是否有监听事件触发</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events,<span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span>&#123;<br>    <span class="hljs-type">uint32_t</span> events;    <span class="hljs-comment">//事件类型</span><br>    <span class="hljs-type">epoll_data_t</span> data;  <span class="hljs-comment">//数据</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">union</span> epoll_data&#123;<br>    <span class="hljs-type">void</span> *ptr;   <span class="hljs-comment">//指定与fd相关的用户数据 </span><br>    <span class="hljs-type">int</span> fd;    <span class="hljs-comment">//对应监听事件的fd</span><br>    <span class="hljs-type">uint32_t</span> u32;    <span class="hljs-comment">//不用</span><br>    <span class="hljs-type">uint64_t</span> u64;    <span class="hljs-comment">//不用</span><br>&#125;<span class="hljs-type">epoll_data_t</span>;<br><br><br><span class="hljs-comment">//参数</span><br>epfd:epoll文件描述符;<br><br>events:传出参数，传出监听事件被触发或者就绪的结构体列表，【数组】;<br><br>maxevents:events数组元素的总个数;<br><br>timeout:设置超时事件;<br><span class="hljs-number">-1</span>:阻塞;<br><span class="hljs-number">0</span>:非阻塞;<br>&gt;<span class="hljs-number">0</span>:设定的超时时长(单位毫秒);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回监听事件就绪的文件描述符个数，可以用作循环上限;<br>超时:<span class="hljs-number">0</span>;<br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>epoll实现多路IO转接服务器</strong>：</p><ul><li><code>LT模式</code>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_MAX 5000</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,cfd,clifd,i,epfd;<br>    <span class="hljs-type">int</span> n,ret,num=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    sockaddr_in ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    epoll_event tep,ep[OPEN_MAX];   <span class="hljs-comment">//tep:epolL_ctl参数，ep[]:epoll_wait参数</span><br><br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr, <span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br><br>    <span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;<br>    ret=<span class="hljs-built_in">setsockopt</span>(sfd,SOL_SOCKET,SO_REUSEPORT,&amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br>    <span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;setsockopt error&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br><br>    epfd=<span class="hljs-built_in">epoll_create</span>(OPEN_MAX);   <span class="hljs-comment">//创建epoll模型</span><br>    <span class="hljs-keyword">if</span>(epfd==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;epoll_create error&quot;</span>);<br><br>    tep.events=EPOLLIN;     <span class="hljs-comment">//指定sfd监听事件为读</span><br>    tep.data.fd=sfd;<br>    ret=<span class="hljs-built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,sfd,&amp;tep);     <span class="hljs-comment">//将sfd结构体节点加入到监听红黑树中</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;epoll_ctl error&quot;</span>);<br>    <br>    cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//epoll为server阻塞监听事件，ep为epoll_event类型数组，OPEN_MAX为数组容量，-1表永久阻塞</span><br>        <span class="hljs-type">int</span> nready=<span class="hljs-built_in">epoll_wait</span>(epfd,ep,OPEN_MAX,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(nready==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;epoll_wait error&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nready;++i)&#123;<br>            <span class="hljs-comment">//如果不是读事件继续循环</span><br>            <span class="hljs-keyword">if</span>(!(ep[i].events&amp;EPOLLIN)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//判断就绪事件的是不是监听文件描述符sfd</span><br>            <span class="hljs-keyword">if</span>(ep[i].data.fd==sfd)&#123;<br>                cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;received from %s at PORT %d\n&quot;</span>,<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr),<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cfd %d---client %d\n&quot;</span>,cfd,++num);<br><br>                tep.events=EPOLLIN;<br>                tep.data.fd=cfd;<br>                ret=<span class="hljs-built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,cfd,&amp;tep);<br>                <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_ADD error&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;     <span class="hljs-comment">//不是sfd,是客户端文件描述符</span><br>                clifd=ep[i].data.fd;<br>                n=<span class="hljs-built_in">Read</span>(clifd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//读到0说明客户端先关闭连接</span><br>                    ret=<span class="hljs-built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,clifd,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//删除监听节点</span><br>                    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_DEL error&quot;</span>);<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] closed connection\n&quot;</span>,clifd);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//出错</span><br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read n&lt;0 error&quot;</span>);<br>                    ret=<span class="hljs-built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,clifd,<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//删除监听节点</span><br>                    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_DEL error&quot;</span>);<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>                        buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>                    &#125;<br>                    <span class="hljs-built_in">Write</span>(clifd,buf,n);<br>                    <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-built_in">Close</span>(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>ET模式</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wrap.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SER_PORT 5005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPEN_MAX 5000</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> sfd,cfd,clifd,efd;<br>    <span class="hljs-type">int</span> n,ret,num=<span class="hljs-number">0</span>,flag;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    sockaddr_in ser_addr,cli_addr;<br>    <span class="hljs-type">socklen_t</span> cli_addr_len;<br>    epoll_event tep,ep[OPEN_MAX];<br><br>    sfd=<span class="hljs-built_in">Socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br><br>    flag=<span class="hljs-built_in">fcntl</span>(sfd, F_GETFL);<br>    flag|=O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(sfd,F_SETFL,flag);<br><br>    <span class="hljs-built_in">bzero</span>(&amp;ser_addr, <span class="hljs-built_in">sizeof</span>(ser_addr));<br>    ser_addr.sin_family=AF_INET;<br>    ser_addr.sin_port=<span class="hljs-built_in">htons</span>(SER_PORT);<br>    ser_addr.sin_addr.s_addr=<span class="hljs-built_in">htonl</span>(INADDR_ANY);<br><br>    <span class="hljs-type">int</span> opt=<span class="hljs-number">1</span>;<br>    ret=<span class="hljs-built_in">setsockopt</span>(sfd, SOL_SOCKET,SO_REUSEPORT, &amp;opt,<span class="hljs-built_in">sizeof</span>(opt));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;setsockopt error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">Bind</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;ser_addr,<span class="hljs-built_in">sizeof</span>(ser_addr));<br><br>    <span class="hljs-built_in">Listen</span>(sfd,<span class="hljs-number">128</span>);<br>    efd=<span class="hljs-built_in">epoll_create</span>(OPEN_MAX);<br>    <span class="hljs-keyword">if</span>(efd==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;epoll_create error&quot;</span>);<br><br>    tep.events=EPOLLIN|EPOLLET;<br>    tep.data.fd=sfd;<br>    ret=<span class="hljs-built_in">epoll_ctl</span>(efd,EPOLL_CTL_ADD,sfd,&amp;tep);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_ADD error&quot;</span>);<br>    <br>    cli_addr_len=<span class="hljs-built_in">sizeof</span>(cli_addr);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> nready=<span class="hljs-built_in">epoll_wait</span>(efd,ep,OPEN_MAX,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(nready==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;epoll_wait error&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nready;++i)&#123;<br>            <span class="hljs-keyword">if</span>(!(ep[i].events&amp;EPOLLIN)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(ep[i].data.fd==sfd)&#123;<br>                <span class="hljs-comment">// 多个连接同时到达，服务器的 TCP 就绪队列瞬间积累多个就绪</span><br>                <span class="hljs-comment">// 连接，由于是边缘触发模式，epoll 只会通知一次，accept 只处理一个连接，导致 TCP 就绪队列中剩下的连接都得不到处理。</span><br>                <span class="hljs-comment">// 解决办法是用 while 循环抱住 accept 调用，处理完 TCP 就绪队列中的所有连接后再退出循环。</span><br>                <span class="hljs-keyword">while</span>((cfd=<span class="hljs-built_in">Accept</span>(sfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;cli_addr,&amp;cli_addr_len))&gt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recevied from %s at port %d\n&quot;</span>,<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr),<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port));<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cfd %d --------client %d\n&quot;</span>,cfd,++num);<br>                    <span class="hljs-comment">//使用ET模式</span><br>                    tep.events=EPOLLIN|EPOLLET;<br>                    tep.data.fd=cfd;<br>                    <span class="hljs-comment">//设置非阻塞</span><br>                    flag=<span class="hljs-built_in">fcntl</span>(cfd,F_GETFL);<br>                    flag|=O_NONBLOCK;<br>                    <span class="hljs-built_in">fcntl</span>(cfd,F_SETFL,flag);<br>                    <br>                    ret=<span class="hljs-built_in">epoll_ctl</span>(efd,EPOLL_CTL_ADD,cfd,&amp;tep);<br>                    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_ADD error&quot;</span>);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                clifd=ep[i].data.fd;<br>                n=<span class="hljs-built_in">Read</span>(clifd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>                    ret=<span class="hljs-built_in">epoll_ctl</span>(efd,EPOLL_CTL_DEL,clifd,<span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_DEL error&quot;</span>);<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client[%d] closed connection\n&quot;</span>,clifd);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read n&lt;0 error\n&quot;</span>);<br>                    ret=<span class="hljs-built_in">epoll_ctl</span>(efd,EPOLL_CTL_DEL,clifd,<span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>) <span class="hljs-built_in">perr_exit</span>(<span class="hljs-string">&quot;EPOLL_CTL_DEL error&quot;</span>);<br>                    <span class="hljs-built_in">Close</span>(clifd);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>                        buf[i]=<span class="hljs-built_in">toupper</span>(buf[i]);<br>                    &#125;<br>                    <span class="hljs-built_in">Write</span>(clifd,buf,n);<br>                    <span class="hljs-built_in">Write</span>(STDOUT_FILENO,buf,n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Close</span>(sfd);<br>    <span class="hljs-built_in">Close</span>(efd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>后台开发</tag>
      
      <tag>Linux</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux根目录扩容</title>
    <link href="/2024/05/19/Arch-Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/"/>
    <url>/2024/05/19/Arch-Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Arch-Linux根目录扩容"><a href="#Arch-Linux根目录扩容" class="headerlink" title="Arch Linux根目录扩容"></a>Arch Linux根目录扩容</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>开始进入archlinux时，还只是抱着试试的心态入手了arch系统，当时也就分配了70g的空间给根目录，当我成功配置成功后，用的久了，发现已经不想回到windows系统，而我的根目录的空间已经不够了，这期讲述<strong>使用其他带gparted的Linux系统USB驱动来进行扩容</strong>，这个方法很简单也很快，虽然不需要将数据移来移去，但是建议以免你自己的误操作还是先备份一下</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>需要自备一个U盘(8G就够了)</li><li>安装制作系统驱动的制作软件<a href="https://rufus.ie/en/">rufus</a>，点击跳转下载对应系统架构的程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405192230580.png" alt="image-20240519223019731"></p><ul><li>一个带Gparted软件的Linux系统映像，这边我是使用pop os，下载地址：<a href="https://pop.system76.com/%EF%BC%8C%E9%80%89%E6%8B%A9LTS%E7%89%88%E6%9C%AC(%E7%AC%AC%E4%B8%80%E4%B8%AA)%E5%B0%B1%E8%A1%8C">https://pop.system76.com/，选择LTS版本(第一个)就行</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010361.png" alt="image-20240519223740926"></p><ul><li>用来windows分区的软件，我这里是使用傲梅分区助手(<a href="https://www.disktool.cn/)%E6%88%96%E8%80%85MiniTool">https://www.disktool.cn/)或者MiniTool</a> Partition Wizard(<a href="https://www.partitionwizard.com/)%EF%BC%8C%E6%88%91%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%82%B2%E6%A2%85%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E4%BB%A5%E4%B8%8B%E6%BC%94%E7%A4%BA%E7%A4%BA%E4%BE%8B%E6%98%AF%E4%BB%A5mini">https://www.partitionwizard.com/)，我实际使用的是傲梅，但是我以下演示示例是以mini</a> tool的，但是操作基本一样</li></ul><h3 id="分出空闲空间"><a href="#分出空闲空间" class="headerlink" title="分出空闲空间"></a>分出空闲空间</h3><ol><li>在Windows的开始标中右键进入磁盘管理</li><li>找到要分出空间的盘，右键进行压缩卷</li><li>选择你要给arch扩容的空间大小然后进行压缩</li></ol><h3 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h3><ol><li>下载好傲梅分区助手或者mini</li><li>打开后找到自己压缩出来的空闲空间(一般都是在你压缩盘的后面)</li><li>我们需要将这个空闲空间滑到archlinux的根分区的后面，如下图所示</li></ol><p>未滑动前：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010362.png" alt="image-20240519233737823"></p><p>滑动操作：右键选择移动操作，然后将所处的空间块(<code>不是移动空闲块而是已经分配的分区</code>)要往左移动就往左移动，往右移动就往右移动，<strong>只要将空闲块移动到arch的根目录分区后(一定是贴着的)即可</strong></p><p>示例这边，移动了空闲空间块的后面那个分区将分区移动到空闲块左边</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010363.png" alt="image-20240519234019104"></p><p>将分区块往左移动，这样空闲块就移动到了这个分区的右边</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010364.png" alt="image-20240519234136821"></p><p>重复以上操作，直到空闲块free size在archlinux根目录分区arch root后面</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010365.png" alt="image-20240519233306938"></p><h3 id="制作U盘驱动"><a href="#制作U盘驱动" class="headerlink" title="制作U盘驱动"></a>制作U盘驱动</h3><ol><li><p>在准备过程中，下载好pop os以及rufus</p></li><li><p>插入U盘，打开rufus</p></li><li><p>然后选择pop os系统映像</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010366.png" alt="image-20240519234641624"></p></li><li><p>然后等待status状态是ready也就是开始按钮亮起时，点击开始，制作U盘驱动</p></li></ol><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li><p>重启电脑(记住U盘别拔)</p></li><li><p>进入U盘驱动页面(双系统的一般都会直接显示，如果不行就可以查百度查你自己电脑进入U盘驱动方式)</p></li><li><p>选择你的U盘(刚刚制作的驱动U盘)</p></li><li><p>选择好回车进入，进行系统安装</p></li><li><p>进入到以下页面，点击对应应用列表</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010367.png" alt="image-20240519235703703"></p></li><li><p>然后在搜索输入gparted，然后打开这个软件</p></li><li><p>找到archlinux的根目录，然后相应的空闲块应该就跟在后面，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010368.png" alt="image-20240519235932311"></p></li><li><p>选择arch的根目录分区右键选择resize选项，然后将根目录分区尾部移动完空白位置即可</p><p>未分配：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010370.png" alt="image-20240520000139592"></p><p>分配后：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010371.png" alt="image-20240520000313907"></p></li><li><p>然后点击resize后，回到软件主页面，点击左上角的勾勾按钮，然后点击确认分配的按钮，不点击就无法进行保存分区和空间分配，等待分配完即可</p></li></ol><h3 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h3><p>如果以上步骤没有出错的话，那么恭喜你成功扩容了archlinux的根目录分区的空间大小，下图就是我自己成功分配后的空间啦。如果看文章没有看明白并且具备一定条件(懂的都懂，不懂的估计访问不了)的可以选择观看我给的链接的视频教学，视频地址：<a href="https://www.youtube.com/watch?v=zE-3a6DX1ac">https://www.youtube.com/watch?v=zE-3a6DX1ac</a></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405200010372.png" alt="screenshot_19052024_215649"></p>]]></content>
    
    
    <categories>
      
      <category>Arch Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h2><p><strong>算法</strong>是对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><p><strong>算法特性</strong>：</p><ul><li><strong>有穷性</strong>：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li><li><strong>确定性</strong>：算法中的每一条指令必须要有确定的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li><li><strong>可行性</strong>：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li><li><strong>输入</strong>：一个算法有零个或多个输入。</li><li><strong>输出</strong>：一个算法有一个或多个输出。</li></ul><p><strong>算法设计要求</strong>：</p><ul><li><strong>正确性</strong></li><li><strong>可读性</strong></li><li><strong>健壮性</strong></li><li><strong>高效性</strong></li></ul><p><strong>算法效率</strong>：</p><ul><li><strong>时间效率</strong>：指的是算法所耗费的时间</li><li><strong>空间效率</strong>：指的是算法执行过程中所耗费的存储空间。</li><li><em>注意</em>：时间效率和空间效率有时候是矛盾的。</li></ul><h3 id="时间复杂度的渐进表示法"><a href="#时间复杂度的渐进表示法" class="headerlink" title="时间复杂度的渐进表示法"></a><strong>时间复杂度的渐进表示法</strong></h3><ul><li><p>为了便于比较不同算法的时间效率，我们仅仅比较他们的数量级。</p><p>例如：两个不同的算法，时间消耗分别是：T1(n)&#x3D;10n² 与T2(n)&#x3D;5n³，显然T1时间效率要比T2的高。所以如果选择会选择T1算法</p></li><li><p>若有某个辅助函数f(n),使得当n趋近与无穷大时，T(n)&#x2F;f(n)的极限值为<strong>不等于0的常数</strong>，则称f(n)是T(n)的同数量级函数。记作：T(n)&#x3D;O(f(n))，称O(f(n))为<strong>算法的渐进时间复杂度(O是数量级符号)<strong>，简称</strong>时间复杂度</strong>。<em>f(n)就是算法中执行次数最多的语句的执行次数，n为问题规模</em></p></li><li><p>排序：n为排序数据量，矩阵：n为矩阵的阶数，多项式：n为多项式的项数，集合：n为元素个数，树：n为树的结点个数，图：n为图的顶点数或边数</p></li></ul><p><strong>时间复杂度的计算</strong></p><p><strong>基本方法</strong>：</p><ol><li><p>找出<strong>语句频度最大</strong>的那条语句作为<strong>基本语句</strong></p></li><li><p>计算<strong>基本语句</strong>的频度得到问题规模问题n的某个函数f(n)（级数求和的方式)</p></li><li><p>取其数量级用符号”O”表示</p></li><li><p>例题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;k++)&#123;   <br>            x=x+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>语句频度&#x3D;\sum_{i&#x3D;1}^{n}{\sum_{j&#x3D;1}^{i}{\sum_{k&#x3D;1}^{j}{1}}}<br>$$</p></li><li><p><strong>算法时间复杂度比较</strong>：</p><p><code>常数阶</code>O(1)&lt;<code>对数阶</code>O(logn)&lt;<code>线性阶</code>O(n)&lt;<code>线性对数阶</code>O(nlogn)&lt;<code>平方阶</code>O(n<sup>2</sup>)&lt;<code>k方阶</code>O(n<sup>k</sup>)&lt;<code>指数阶</code>O(2<sup>n</sup>)&lt;<code>阶乘阶</code>O(n!)   k&gt;2</p></li><li><p>对于复杂的算法，可以将它分为几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度</p><ul><li><strong>加法法则</strong>：<code>T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))</code></li><li><strong>乘法法则</strong>：<code>T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))</code></li></ul></li></ol><p><strong>例题</strong>：若f(n)&#x3D;a<sub>m</sub>n<sup>m</sup>+a<sub>m-1</sub>n<sup>m-1</sup>+…+a<sub>1</sub>n+a<sub>0</sub>是m次多项式，忽略所有低次幂项和最高次幂项的系数，体现出增长率的含义，则T(n)&#x3D;O(n<sup>m</sup>).</p><p><strong>递归算法时间复杂度计算</strong>：</p><ul><li><strong>递归算法时间复杂度等于每次递归的时间复杂度*递归总次数(递归树的总节点数)</strong></li></ul><h3 id="空间复杂度的渐进表示法"><a href="#空间复杂度的渐进表示法" class="headerlink" title="空间复杂度的渐进表示法"></a>空间复杂度的渐进表示法</h3><ul><li><p><strong>空间复杂度</strong>：算法所需存储空间的度量，记作：<code>S(n)=O(f(n))</code>,其中n为问题的规模(或大小)</p></li><li><p>算法要占据的空间</p><ul><li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li><li>算法要使用的<strong>辅助空间</strong>(临时存储空间)</li></ul></li><li><p><strong>例题</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">【算法<span class="hljs-number">1</span>】<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>    t=a[i];<br>    a[i]=a[n-i<span class="hljs-number">-1</span>];<br>    a[n-i<span class="hljs-number">-1</span>]=t;<br>&#125;<br><span class="hljs-built_in">S</span>(n)=<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>),就一个t是临时存储空间变量<br>    <br>【算法<span class="hljs-number">2</span>】<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    b[i]=a[n-i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    a[i]=b[i];<br>&#125;<br><span class="hljs-built_in">S</span>(n)=<span class="hljs-built_in">O</span>(n),因为a数组有多少元素，则临时存储空间b数组也需要多少元素，则空间复杂度应该就与n有关<br></code></pre></td></tr></table></figure></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="最大子序列和求解问题"><a href="#最大子序列和求解问题" class="headerlink" title="最大子序列和求解问题"></a>最大子序列和求解问题</h3><h4 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h4><ul><li>直接利用嵌套循环将每次序列和求出来，并跟当前最大序列和比较，得出最大序列和，时间复杂度为<em>O(n³)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//算法1，暴力求解,时间复杂度为O(N?)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxsum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxsum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;size;j++)&#123;<br>            <span class="hljs-type">int</span> thissum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                thissum+=an[k];<br>                <span class="hljs-keyword">if</span>(thissum&gt;maxsum)&#123;<br>                    maxsum=thissum;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="微优化解法"><a href="#微优化解法" class="headerlink" title="微优化解法"></a>微优化解法</h4><ul><li>将比较部分的循环优化成一个边加边比较的算法，比暴力解法减少一层循环，时间复杂度为<em>O(n²)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//算法2，微优化，边算边比较，时间复杂度为O(N²)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxsum1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxsum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-type">int</span> thissum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;size;j++)&#123;<br>            thissum+=an[j];<br>            <span class="hljs-keyword">if</span>(thissum&gt;maxsum)&#123;<br>                maxsum=thissum;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治法求解"><a href="#分治法求解" class="headerlink" title="分治法求解"></a>分治法求解</h4><p><strong>分治法概念</strong>：</p><ul><li>就是将复杂的问题分成小问题，然后解决小问题在通过处理将小问题的解法合并在一起成为大问题的解法。</li></ul><p><strong>最大子序列和的解法</strong></p><ul><li>最大子序列和可能出现在三处，分别是<strong>左半部</strong>、<strong>右半部</strong>或者<strong>跨越输入数据的中部</strong>，前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分的最大和(包含前半部分的最后一个元素)以及后半部分的最大和(包含后半部分的第一个元素)相加得到，前半部分和后半部分的最大和也可以通过进行分成相对应的前后半部分然后求解。该算法的时间复杂度将会降低到<em>O(nlogn)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//算法3，分治法求解，时间复杂度为O(nlogn)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-type">int</span> maxleft,<span class="hljs-type">int</span> maxright,<span class="hljs-type">int</span> maxcenter)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxsum;<br>    maxsum=maxleft&gt;maxright?maxleft:maxright;<br>    maxsum=maxsum&gt;maxcenter?maxsum:maxcenter;<br>    <span class="hljs-keyword">return</span> maxsum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxsubsum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxleftsum,maxrightsum;<br>    <span class="hljs-keyword">if</span>(left==right)&#123;<br>        <span class="hljs-keyword">return</span> an[left];<br>    &#125;<br>    <span class="hljs-type">int</span> center=(left+right)&gt;&gt;<span class="hljs-number">1</span>;<br>    maxleftsum= <span class="hljs-built_in">maxsubsum</span>(an,left,center);<br>    maxrightsum= <span class="hljs-built_in">maxsubsum</span>(an,center+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-type">int</span> leftsum=<span class="hljs-number">0</span>,maxleft=INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center;i&gt;=left;i--)&#123;<br>        leftsum+=an[i];<br>        <span class="hljs-keyword">if</span>(leftsum&gt;maxleft)&#123;<br>            maxleft=leftsum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> rightsum=<span class="hljs-number">0</span>,maxright=INT_MIN;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=center+<span class="hljs-number">1</span>;i&lt;=right;i++)&#123;<br>        rightsum+=an[i];<br>        <span class="hljs-keyword">if</span>(rightsum&gt;maxright)&#123;<br>            maxright=rightsum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max3</span>(maxleftsum,maxrightsum,maxleft+maxright);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxsum2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">maxsubsum</span>(an,<span class="hljs-number">0</span>,size<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="贪心解法-最快最简单解法"><a href="#贪心解法-最快最简单解法" class="headerlink" title="贪心解法(最快最简单解法)"></a>贪心解法(最快最简单解法)</h4><ul><li>该解法也是一种边加边比较，但是它只有一层循环，它的本质就是通过每次相加然后在比较的同时，当他的当前sum不大于最大sum时，并且该sum&lt;0则我们将它归0，这样进行求解序列和时，就能保证它能主动找到正数和，正数和是最有可能成为最大序列和的，该算法的时间复杂度为<em>O(n)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最简单最快算法，时间复杂度为O(N)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxsum3</span><span class="hljs-params">(<span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxsum=INT_MIN,thissum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        thissum+=an[i];<br>        <span class="hljs-keyword">if</span>(thissum&gt;maxsum)&#123;<br>            maxsum=thissum;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(thissum&lt;<span class="hljs-number">0</span>)&#123;<br>            thissum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsum;<br>&#125;<br><br><span class="hljs-comment">//这个代码虽多，但比上面的节约了一些时间。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Maxsum3</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-type">int</span> maxsum=<span class="hljs-number">0</span>,thissum=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,msum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br>                mnum=nums[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&gt;msum)&#123;<br>                msum=nums[i];<br>            &#125;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        thissum+=nums[i];<br>        <span class="hljs-keyword">if</span>(thissum&gt;maxsum)&#123;<br>            maxsum=thissum;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(thissum&lt;<span class="hljs-number">0</span>)&#123;<br>            thissum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt==size&amp;&amp;maxsum==<span class="hljs-number">0</span>)&#123;<br>        maxsum=msum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxsum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>概念</strong>：</p><ul><li><strong>针对于已经预先排序好的数据</strong>，每次将数据进行对半查找，然后看它中间的数据是否是要找的，如果是就返回中间位置，不是就判断该数据是在前半部分还是后半部，然后在进而取其中部，看其是否找到，然后如果还没找到就一直重复操作，直到找到为止，该算法时间复杂度为<em>O(logn)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) r=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>闭区间</strong>：</p><ul><li><p><code>以左边界为求解的判断状态</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid]&lt;=target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l]!=target?<span class="hljs-number">-1</span>:l;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>以右边界为求解的判断状态</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//可以用lower_bound()函数代替</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)&#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid]&gt;=target) r = mid;<br>            <span class="hljs-keyword">else</span> l= mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[r]!=target?<span class="hljs-number">-1</span>:r;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>开区间</strong>：将闭区间代码中if判断中的等号去掉即可</p><h3 id="欧几里德算法"><a href="#欧几里德算法" class="headerlink" title="欧几里德算法"></a>欧几里德算法</h3><p><strong>概念</strong>：</p><ul><li>用于求两个数的<strong>最大公约数</strong>(两个数都可以共同整除的最大数)，利用不断相互取余，直到其中一个余数为0，则最大公约数为不为0的余数，该算法的时间复杂度为<em>O(logn)</em></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> M,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> N)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Rem;<br>    <span class="hljs-keyword">while</span>(N&gt;<span class="hljs-number">0</span>)&#123;<br>        Rem=M%N;<br>        M=N;<br>        N=Rem;<br>    &#125;<br>    <span class="hljs-keyword">return</span> M;<br>&#125;<br><br><span class="hljs-comment">//递归版(简洁)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !b ? a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h3><p><strong>概念</strong>：</p><ul><li>计算X<sup>N</sup>的最常见的算法是使用N-1次乘法自乘，但是可以使用一种将<strong>利用分治思想跟递归结合的算法</strong>更好，效率更高。判断N是偶数还是奇数，如果是偶数的话，我们有X<sup>N</sup>&#x3D;X<sup>N&#x2F;2</sup>*X<sup>N&#x2F;2</sup>，如果为奇数，我们有X<sup>N</sup>&#x3D;X<sup>(N-1)&#x2F;2</sup>*X<sup>(N-1)&#x2F;2</sup>*X，然后在不断的递归并将N等于0和N等于1为递归的基准情形，当N等于1返回X，该算法的时间复杂度为<em>O(logn)</em></li></ul><p>代码：</p><ul><li><strong>递归</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">int</span> X,<span class="hljs-type">long</span> <span class="hljs-type">int</span> N)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">if</span>(X%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Pow</span>(X*X,N/<span class="hljs-number">2</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Pow</span>(X*X,N/<span class="hljs-number">2</span>)*X;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>非递归</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//有些题目数字过大防止溢出会对结果取模</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">int</span> mod)</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-comment">//b为奇数</span><br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            res=res*a%mod;<br>        &#125;<br>        b/=<span class="hljs-number">2</span>;<br>        a=a*a%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>位运算加速</strong>：假设我们要求a的11次方那么他会分解成8+2+1，那如何将其分解成8+2+1的情况，我们<strong>可以将其转换成二进制</strong>，11的二进制为1011，11&#x3D;1*2<sup>3</sup>+0*2<sup>2</sup>+1*<sup>1</sup>+1*2<sup>0</sup>，这样<strong>我们每次取11的二进制的最后一位这样就能分解成8+2+1了</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickpow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">int</span> mod)</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-comment">//b&amp;1就可以等价于b%2==1，如果b为偶数b&amp;1==0，为奇数b&amp;1==1</span><br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)&#123;<br>            res=res*a%mod;<br>        &#125;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;  <span class="hljs-comment">//等价于b/=2</span><br>        a=a*a%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h3><p><strong>引言</strong>：</p><ul><li><code>素数(质数)</code>：<strong>除了1和自己本身之外，没有任何因子的数</strong>叫做素数(质数)</li></ul><h4 id="朴素筛法-优化版"><a href="#朴素筛法-优化版" class="headerlink" title="朴素筛法(优化版)"></a>朴素筛法(优化版)</h4><p><strong>概念</strong>：</p><ul><li><code>朴素筛法</code>：是<strong>直接暴力枚举2到当前判断的数x(不包括)，然后看在这范围内是否存在因子，如果存在就不是素数</strong>，不存在就是素数，时间复杂度为<code>O(n*n)</code></li><li><code>优化版</code>：优化版是用到了一个数学性质进行优化，使其<strong>只需要判断2到sqrt(x)的范围内</strong>，是否存在x的因子即可，时间复杂度为<code>O(n*sqrt(n))</code></li></ul><p><code>数学性质</code>：<strong>如果一个数x能够被一个大于1且小于等于sqrt(x)的整数整除，那么x必定能够被另一个大于1且大于sqrt(x)的整数整除</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//朴素筛素数判断算法时间复杂度：O(n)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;x;++i)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//优化版素数判断算法时间复杂度：O(sqrt(n))</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;x/i;++i)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//假设筛选出1-1000的素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i+=<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isprime</span>(i)) cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="欧拉筛-线性筛"><a href="#欧拉筛-线性筛" class="headerlink" title="欧拉筛(线性筛)"></a>欧拉筛(线性筛)</h4><p><strong>概念</strong>：</p><ul><li><code>欧拉筛</code>：<strong>利用合数的数学性质</strong>，可以将素数筛的算法优化到时间复杂度为<code>O(n)</code></li></ul><p><code>合数</code>：<strong>除了1和自身之外还有其他正因子</strong>(除了 1 和自身以外的能够整除它的正整数)，<strong>并且大于1的整数</strong></p><p><code>数学性质</code>：对于<strong>任意一个合数 x</strong>，它<strong>一定可以被其最小质因数</strong>(即最小的能整除 x 的质数)<strong>整除</strong></p><p><strong>算法具体操作</strong>：</p><ol><li><strong>初始化一个标记数组vis[]和记录素数数组prime</strong>，vis所有元素初始化为false</li><li>从<strong>2遍历到n(要筛选素数范围)，如果vis[i]为false，则将i标记为素数，并将i记录在prime数组中</strong>，并将<strong>i的倍数j(j&#x3D;i*i，i*i+i…)标记为合数(true)</strong></li><li>遍历完所有的数后，<strong>prime数组中的数都为素数</strong></li></ol><blockquote><p>总结：</p><p>在这个过程中，<strong>每个合数都会被标记为其最小质因数</strong>，这样能够确保每个合数只会被标记一次。由于<strong>每个合数只会被其最小质因数标记</strong>，因此在遍历过程中，<strong>每个合数只会被标记一次，而非多次</strong>，从而避免了重复标记，提高了效率。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e8</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-comment">//欧拉筛总体时间复杂度为O(n)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isprimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i]) prime[cnt++]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=n/i;++j)&#123;<br>            vis[i*prime[j]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>概念</strong>：</p><ul><li>我们在的排序工作能<strong>在主存中</strong>完成的，我们就叫这种算法叫做<strong>内部排序</strong></li><li>不能在主存中完成而必须<strong>在磁盘或磁带上完成</strong>的排序算法叫做<strong>外部排序</strong></li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>概念</strong>：</p><ul><li><strong>冒泡排序</strong>是一个很简单的排序算法，冒泡排序是<strong>比较相邻的元素</strong>，如果第一个比第二个大，就交换他们两个，对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值，重复以上步骤，<strong>每次比较次数-1</strong>，直到不需要比较为止。</li><li><em>冒泡排序是一种每一轮排序遍历时，抛出当前遍历时的最大值来进行一个到最后升序的排序方法</em></li><li>冒泡排序的时间复杂度为<em>O(n²)</em></li></ul><p><strong>注意事项</strong>：</p><ul><li>冒泡排序的时间复杂度不是很好，有时候数据量大就应该考虑其他线性时间复杂度的排序算法</li></ul><p><strong>实现代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//比较相邻的元素，如果第一个比第二个大，就交换他们两个</span><br><span class="hljs-comment">//对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值</span><br><span class="hljs-comment">//重复以上步骤，每次比较次数-1，直到不需要比较</span><br><br><br><span class="hljs-comment">//冒泡排序,升序排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> an[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len<span class="hljs-number">-1</span>-i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(an[j]&gt;an[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> temp=an[j+<span class="hljs-number">1</span>];<br>                an[j+<span class="hljs-number">1</span>]=an[j];<br>                an[j]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>概念</strong>：</p><ul><li><strong>插入排序(insertsort)<strong>：插入排序是一个</strong>基于比较移动数据</strong>来实现有序化的算法，<em>时间复杂度为O(N²)</em></li><li>插入排序<strong>根据元素的个数N进行N-1趟排序</strong>，从<strong>第一趟开始</strong>，在<strong>第P趟</strong>，我们将<strong>数组索引第P位的元素或者元素位于第P+1位置上的元素与该元素前面的所有元素进行比较</strong>，比较后<strong>找到</strong>该元素存在的<strong>对应位置进行移动或者叫做插入(不是交换)</strong></li><li>第P趟结束，无序的数组或者数据则变成有序化了。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-type">int</span> temp=an[i];<br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-keyword">for</span>(j=i;j&gt;<span class="hljs-number">0</span>&amp;&amp;an[j<span class="hljs-number">-1</span>]&gt;temp;j--)&#123;<br>            an[j]=an[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        an[j]=temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>概念</strong>：</p><ul><li><strong>希尔排序(shellsort)<strong>是</strong>基于插入排序所优化的算法</strong>，该算法<strong>依靠增量序列来使到减少相邻元素交换排序的机会以及减少排序执行的趟次</strong>，这将比插入排序所花费的<strong>时间减少</strong>，即使希尔排序的<em>时间复杂度也为O(N²)</em></li><li>关于<strong>增量序列h</strong>，我们将数组的所有元素，<strong>按照索引号i,i+h,i+2h….(在数组索引范围0-N-1之内)作为一个序列进行排序</strong>，而这个<strong>排序是按照序列内的索引号排序</strong>因此不会影响到其他索引号的排序，而形成<strong>增量序列的h的选取可以自定义</strong>，但是<strong>希尔建议使用h1&#x3D;(N-1)&#x2F;2,h2&#x3D;h1&#x2F;2直到hk&#x3D;1的方式进行形成增量序列(但不是很好)。</strong></li><li>例如：一个无序数组的元素有12个，则排序该数组需要三趟，h(根据数组最大索引号也就是11除以2取得h1)分别为5，2，1，因此在以5为增量的趟次中，0，5，10为一个序列并将对应号上的元素进行插入排序，1，6，11又为1个序列进行排序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529589.png" alt="image"></p><p>代码：</p><ul><li><strong>使用Sedgewick增量作为希尔排序序列的时间复杂度为O(N<sup>7&#x2F;6</sup>)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i/=<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">//插入排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;len;j++)&#123;<br>            <span class="hljs-type">int</span> temp=an[j],k;<br>            <span class="hljs-comment">//根据增量i进行分序列排序</span><br>            <span class="hljs-keyword">for</span>(k=j;k&gt;=i&amp;&amp;temp&lt;an[k-i];k-=i)&#123;<br>                an[k]=an[k-i];<br>            &#125;<br>            an[k]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用Sedgewick增量的希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellsort_pro</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br>    <span class="hljs-type">int</span> Sedgewick[] = &#123;<span class="hljs-number">260609</span>,<span class="hljs-number">146305</span>,<span class="hljs-number">64769</span>,<span class="hljs-number">36289</span>,<br>                       <span class="hljs-number">16001</span>,<span class="hljs-number">8929</span>,<span class="hljs-number">3905</span>,<span class="hljs-number">2161</span>,<span class="hljs-number">929</span>, <span class="hljs-number">505</span>,<br>                       <span class="hljs-number">209</span>, <span class="hljs-number">109</span>, <span class="hljs-number">41</span>, <span class="hljs-number">19</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;Sedgewick[k]&gt;=len;k++);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=Sedgewick[k];d&gt;<span class="hljs-number">0</span>;d=Sedgewick[++k])&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=d;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> temp=an[i];<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span>(j=i;j&gt;=d&amp;&amp;an[j-d]&gt;temp;j-=d)&#123;<br>                an[j]=an[j-d];<br>            &#125;<br>            an[j]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>概念</strong>：</p><ul><li>堆排序(heapsort)：是一个<strong>基于二叉堆的排序算法</strong>,但是他又跟二叉堆的不一样，二叉堆的数组索引为0的是个哑节点，但是<strong>堆排序是得从0开始的</strong></li><li>堆排序的实现需要根据要实现顺序的方式，<strong>将无序的数组在原数组下重新构建成大根堆&#x2F;小根堆数组</strong>，如果要实现<strong>升序</strong>，就需要<strong>构建成大根堆</strong>，实现<strong>降序</strong>，就需要<strong>构建成小根堆数组</strong>。<strong>构建完</strong>堆数组，然后<strong>以类似堆中操作删除最大元&#x2F;最小元的方式，将数组实现有序</strong>。</li><li><strong>构建堆(以升序为例)<strong>：我们需要</strong>拿取数组元素个数N</strong>，<strong>从(N-1)&#x2F;2到0遍历(拿取堆中的根节点)<strong>，</strong>遍历时拿取该根节点的子节点中的最大值</strong>，如果<strong>最大值大于根节点，就进行根节点与该最大值交换</strong>，<strong>遍历完毕后就形成了大根堆</strong></li><li><strong>删除最大&#x2F;最小元(以升序为例)<strong>：要实现升序，则需要拿取数组元素个数N并</strong>执行从N-1到1次的删除最大元操作</strong>，而最大元就是大根堆数组中的第一位元素，在遍历到索引号为i时，我们需要<strong>将最大元与数组索引号为N-i-1的元素进行交换</strong>，然后<strong>重新构建最大堆保证堆数组的第一位元素就是最大元</strong>，跟<strong>遍历完毕就得到升序的数组</strong>，反之就得到降序的数组。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> leftchild(i) (2*(i)+1)    <span class="hljs-comment">//定义宏函数，找到根节点的左孩子</span></span><br><br><span class="hljs-comment">//构建堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildheap</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp,child;<br>    <span class="hljs-keyword">for</span>(temp=an[index];<span class="hljs-built_in">leftchild</span>(index)&lt;len;index=child)&#123;<br>        child=<span class="hljs-built_in">leftchild</span>(index);<br>        <span class="hljs-keyword">if</span>(child!=len<span class="hljs-number">-1</span>&amp;&amp;an[child+<span class="hljs-number">1</span>]&gt;an[child])&#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(an[child]&gt;temp)&#123;<br>            an[index]=an[child];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    an[index]=temp;<br>&#125;<br><br><span class="hljs-comment">//堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">buildheap</span>(an,len,i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-type">int</span> temp=an[<span class="hljs-number">0</span>];<br>        an[<span class="hljs-number">0</span>]=an[i];<br>        an[i]=temp;<br>        <span class="hljs-built_in">buildheap</span>(an,i,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>概念</strong>：</p><ul><li><strong>归并排序(mergesort)<strong>：是基于</strong>递归和分治策略</strong>的排序算法，*其时间复杂度为O(nlogn)*，但是归并排序不利于主存内排序，因为合并数组需要线性附加内存，如果N很大，则需要的表很大。</li><li>归并算法是将一个无序要排序的数组，将其分半，然后<strong>用递归，将数组一次次分半</strong>，然后利用<strong>递归到</strong>最后一层也就是<strong>数组无法再分了</strong>，<strong>递归返回时，开辟一个新数组，就用合并的操作将其有序的放入新数组</strong>，最后递归完毕就会得到一个有序的数组了。</li></ul><p><strong>合并操作</strong>：</p><ul><li>对于某一个<strong>合并操作</strong>来讲(以合成升序数组为例，<strong>两个数组前提是要有序的</strong>)，我们将数组分成了A，B两个数组(<strong>其实并没有分成两个，只是用lpos，rpos记录这两个数组在原来数组的起始位置</strong>)，用<strong>leftend，rightend记录两个数组结尾的数组索引</strong>，然后我们<strong>开辟一个能存下A和B数组两个数组元素的数组</strong></li><li>然后，我们<strong>将lpos位置的元素跟rpos位置的元素比较</strong>，<strong>哪个小就放进tempos位置上的新数组temarr中</strong>，如果<strong>lpos位置小</strong>，则将<strong>lpos位置元素赋值到temarr中的tempos位置上，tempos和lpos++，然后lpos++完的位置上的元素再跟rpos比较，重复之前操作</strong>。</li><li><strong>直到一个数组元素全部赋值完后，如果另一个数组还有剩下元素，则将剩下的数组赋值到temarr中，则合并操作就结束了。</strong></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//合并操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>*an,<span class="hljs-type">int</span> *temarr,<span class="hljs-type">int</span> lpos,<span class="hljs-type">int</span> rpos,<span class="hljs-type">int</span> rightend)</span></span>&#123;<br>    <span class="hljs-type">int</span> leftend=rpos<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> nums=(rightend-lpos)+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tempos=lpos;<br>    <span class="hljs-comment">//进行比较lpos和rpos位上的元素</span><br>    <span class="hljs-keyword">while</span> (lpos&lt;=leftend&amp;&amp;rpos&lt;=rightend)&#123;<br>        <span class="hljs-keyword">if</span>(an[lpos]&lt;an[rpos])&#123;<br>            temarr[tempos++]=an[lpos++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temarr[tempos++]=an[rpos++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (lpos&lt;=leftend)&#123;       <span class="hljs-comment">//处理left数组的剩余元素</span><br>        temarr[tempos++]=an[lpos++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (rpos&lt;=rightend)&#123;     <span class="hljs-comment">//处理right数组的剩余元素</span><br>        temarr[tempos++]=an[rpos++];<br>    &#125;<br>    <span class="hljs-comment">//使用rightend保证给an数组赋值的正确位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums;i++,rightend--)&#123;<br>        an[rightend]=temarr[rightend];<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//递归分治调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midsort</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> *temarr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>        <span class="hljs-type">int</span> center=(left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">midsort</span>(an,temarr,left,center);<br>        <span class="hljs-built_in">midsort</span>(an,temarr,center+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-built_in">merge</span>(an,temarr,left,center+<span class="hljs-number">1</span>,right);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-type">int</span> *temarr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len];<br>    <span class="hljs-built_in">midsort</span>(an,temarr,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>概念</strong>：</p><ul><li><p>**快速排序(quicksort)*<em>：也是一种分治的递归算法，时间复杂度为</em>O(nlogn)*，是实践中最快的已知排序算法</p></li><li><p>对数组S的快速排序的具体操作是：</p><blockquote><ol><li>如果S中元素个数为0或1，则直接返回该数组</li><li>取S中任一元素v，称之为<strong>枢纽元(pivot)</strong></li><li>将S-{v}(S中除去v的其余元素)分成两个不想交的集合：S<sub>1</sub>&#x3D;{x∈S-{v}|x&lt;&#x3D;v}和S<sub>2</sub>&#x3D;{x∈S-{v}|x&gt;&#x3D;v}.(这个操作就是分治操作，不断地递归取枢纽元将其分割为一个个小集合进行排序)</li><li>返回{quicksort(S<sub>1</sub>)后，继随v，继而quicksort(S<sub>2</sub>)}</li></ol></blockquote></li><li><p>对于元素<strong>小于等于20的数组</strong>我们成为小数组，当数组为小数组时，<strong>快速排序不如插入排序好</strong>，这种情况下<strong>使用插入排序而不是使用递归的快速排序，将会节省大约15%的运行时间(相对于自始至终使用快速排序)</strong></p></li></ul><p><strong>选取枢纽元</strong>：</p><ol><li><strong>随机选取法</strong>：一个<strong>比较安全</strong>的选取方法，<strong>通过使用随机数生成器进行随机产生枢纽元v</strong>，因为随机的枢纽元不可能总在接连不断地产生劣质的分割。但是随机数的生成时间比较长，<strong>无法降低算法的平均运行时间</strong></li><li><strong>三数中值分割法</strong>：一个<strong>比较好</strong>的选取方法，我们<strong>使用数组的左端、右端和中心位置上的三个元素的中间值(就是排序后第二大的元素)作为枢纽元v</strong>。使用该选取方法<strong>消除了预排序输入的坏情形</strong>，并且<strong>减少了快速排序大约5%的运行时间</strong></li></ol><p><strong>分割策略</strong>：</p><ul><li>当数组中的<strong>元素互异</strong>时，在分割阶段，我们<strong>将枢纽元跟数组最右端的元素进行交换</strong>，让枢纽元离开分区域内。我们需要<strong>将小于枢纽元和大于枢纽元的元素分布在区域的左右边。</strong></li><li>利用<strong>i指向最左边的元素</strong>，<strong>j指向倒数第二个位置(也就是交换后枢纽元的左边位置)<strong>，如果</strong>i指向的元素小于枢纽元，i就向右移动</strong>，如果<strong>j指向的元素大于枢纽元，j就向左边移动</strong>，直到<strong>当i指向的位置不小于枢纽元，j指向的位置不大于枢纽元，就将i，j位置上的元素交换，但不交换i，j，交换完各自向右向左移动一位</strong>。</li><li>重复上述的操作，<strong>直到i和j交错</strong>，也就是当i在j的右边一位，j在i的左边一位的时候，<strong>不进行移动与交换</strong>，然后<strong>将枢纽元指向的元素和i所指的元素进行交换</strong></li><li>对于<strong>i或者j指向元素跟枢纽元相等</strong>时，<strong>i和j停止移动进行交换位置上的元素，然后各自向右向左移动一位。</strong></li></ul><p>代码：</p><ul><li><strong>在实际操作中</strong>，我们在选取枢纽元的操作中，已经将<strong>left，center，right位置上的元素排好序</strong>了，而<strong>right位置上的元素本身就比枢纽元大</strong>，我们<strong>不直接交换center和right位置上的元素，而是交换center跟right-1上的元素，这样将会为后面根据枢纽元分割区域中少比较一位。</strong>优化了算法的性能</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=low+<span class="hljs-number">1</span>;i&lt;=high;i++)&#123;<br>        <span class="hljs-type">int</span> temp=an[i];<br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-keyword">for</span>(j=i;j&gt;<span class="hljs-number">0</span>&amp;&amp;an[j<span class="hljs-number">-1</span>]&gt;temp;j--)&#123;<br>            an[j]=an[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        an[j]=temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//三数中值分割法选取枢纽元</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">midian3</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> center=(left+right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(an[left]&gt;an[center])&#123;<br>        <span class="hljs-built_in">swap</span>(an[left],an[center]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(an[left]&gt;an[right])&#123;<br>        <span class="hljs-built_in">swap</span>(an[left],an[right]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(an[center]&gt;an[right])&#123;<br>        <span class="hljs-built_in">swap</span>(an[center],an[right]);<br>    &#125;<br>    <span class="hljs-comment">//因为上述操作已经满足an[left]&lt;an[center]&lt;an[right]，an[right]大于枢纽元，我不需要进行交换让其在比较一位</span><br>    <span class="hljs-comment">//因此让枢纽元跟right-1位置交换，这样在排序时减轻了右边数组的压力</span><br>    <span class="hljs-built_in">swap</span>(an[center],an[right<span class="hljs-number">-1</span>]);<br>    <span class="hljs-keyword">return</span> an[right<span class="hljs-number">-1</span>];   <span class="hljs-comment">//返回枢纽元</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Qsort</span><span class="hljs-params">(<span class="hljs-type">int</span>* an,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left+<span class="hljs-number">10</span>&lt;=right)&#123;<br>        <span class="hljs-type">int</span> pivot=<span class="hljs-built_in">midian3</span>(an,left,right);<br>        <span class="hljs-type">int</span> i=left,j=right<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            <span class="hljs-keyword">while</span> (an[++i]&lt;pivot)&#123;&#125;<br>            <span class="hljs-keyword">while</span> (an[--j]&gt;pivot)&#123;&#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>                <span class="hljs-built_in">swap</span>(an[i],an[j]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(an[i],an[right<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">Qsort</span>(an,left,i<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">Qsort</span>(an,i+<span class="hljs-number">1</span>,right);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">insertsort</span>(an,left,right);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-built_in">Qsort</span>(an,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>另一种快速排序，<strong>每一次递归，我们将数组最左端就当作枢纽元</strong>，还是<strong>左端left开始跟right指向的元素跟枢纽元的值比较</strong>，an[left]&lt;枢纽元left++，an[right]&gt;枢纽元right–，<strong>直到找到an[left]&gt;枢纽元，an[right]&lt;枢纽元的时候进行交换an[left]和an[right]<strong>，</strong>直到left&#x3D;&#x3D;right，就将枢纽元(也就是最左端的元素)与left当前所在位置进行交换</strong>，使得枢纽元放在正确的位置，然后在<strong>以left为界限分治。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> left=low,right=high;<br>    <span class="hljs-keyword">if</span>(left&lt;high) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> temp=an[left];   <span class="hljs-comment">//枢纽元</span><br>    <span class="hljs-keyword">while</span>(left!=right)&#123;<br>        <span class="hljs-comment">//找寻右边区域小于枢纽元的元素位置</span><br>        <span class="hljs-keyword">while</span>(an[right]&gt;=temp&amp;&amp;left&lt;right)&#123;<br>            right--;<br>        &#125;<br>        <span class="hljs-comment">//找寻左边区域大于枢纽元的元素位置</span><br>        <span class="hljs-keyword">while</span>(an[left]&lt;=temp&amp;&amp;left&lt;right)&#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-comment">//将找到的进行交换使得左边区域小于枢纽元，右边区域大于枢纽元</span><br>        <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>            <span class="hljs-built_in">swap</span>(an[left],an[right]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将枢纽元换到正确的中间区域</span><br>    <span class="hljs-built_in">swap</span>(an[low],an[left]);<br>    <span class="hljs-comment">//以left也就是当前枢纽元所在位置为界限进行分治</span><br>    <span class="hljs-built_in">quicksort</span>(an,low,left<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">quicksort</span>(an,left+<span class="hljs-number">1</span>,high);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h4><p><strong>概念</strong>:</p><ul><li><strong>桶排序(Bucket sort)<strong>：桶排序是一个</strong>非比较排序方法</strong>，它的排序是<strong>典型的用空间换时间的方法</strong>，它的时间复杂度甚至可能是线性复杂度(<em>O(n)</em>)。如果我们有N个<strong>整数</strong>，数的大小范围为1<del>M(或者0</del>M-1),就可以根据数据大小范围创建一个空桶(可以看作数组)或者多个空桶，然后将数据分桶后，就可以将这些数据从头到尾输出，输出完就会发现数据已经排好序了！时间复杂度为<em>O(M+N)</em></li></ul><p><strong>注意事项</strong>：</p><ul><li>该类算法是典型的空间换时间，要注意空间的开销</li><li>该类算法排序的对象必须是整数，如果是浮点数和自定义类数据比较，就无法使用该类排序方法。</li><li>分完桶之后，排序的算法自行选择</li><li>分桶规则，根据数据自定义映射规则。</li></ul><h5 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h5><p><strong>概念</strong>：</p><ul><li>假设要排序的数据为N个整数，数的大小范围为0~M-1,我们就创建一个空桶(数组)，数组的长度为该数据的最大值(<strong>将每一个元素看作是数组的下标,例如元素1就放在数组a[1]中</strong>)，数组的值全部初始化为0，然后利用循环如果出现一个元素，就将其对应数组的下标中的数据+1(例如有数据中1出现了两次，则a[1]&#x3D;&#x3D;2)，然后再将根据排序方式将数组元素顺序&#x2F;逆序打印，对应数组下标的值为多少就打印几次。该排序方法时间复杂度为*O(n)*。</li></ul><p><strong>注意事项</strong>：</p><ul><li>元素一定要为整数且为正数！</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span> max=an[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(an[i]&gt;max)&#123;<br>            max=an[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> arr[max+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(max+<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        arr[an[i]]++;<br>    &#125;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;max+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">while</span> (arr[i]&gt;<span class="hljs-number">0</span>)&#123;<br>            an[j]=i;<br>            arr[i]--;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><p><strong>概念</strong>：</p><ul><li>当数据范围过大的时候，如果使用桶排序则需要创建的空桶太多了，因此我们使用<strong>多趟桶式排序</strong>—我们将会用<strong>最低(有效)位</strong>优先的方式进行桶式排序。</li><li>首先我们得先<strong>创建一个0-9的桶(线性表)<strong>，我们将会将数据分趟次(根据数据最大数的位次)排序，第一次就以</strong>每个数据的最低位排序</strong>依次放到其最低位对应的桶中，例如：数据231就放在数组a[2]中，然后再根据<strong>次低位</strong>进行第二趟排序，如果只有一位数的数据就根据第一趟排序的顺序依次放在第0位的桶中，然后如果还有百位的数据则就继续第三趟排序。</li><li>时间复杂度为<em>O(n)</em></li></ul><p><strong>注意事项</strong>：</p><ul><li>数据一定得是整数。</li><li><strong>如果数据出现负数，则需要数组每个元素先加上最小值的绝对值，然后排序完后再减去最小值的绝对值就能实现负数也能排序。</strong></li><li>该算法是基于计数排序的，所以会使用到计数排序的排序方法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529590.png" alt="image"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> exp)</span></span>&#123;<br>    <span class="hljs-type">int</span> count[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//计数数组</span><br>    <span class="hljs-type">int</span> ret[len];  <span class="hljs-comment">//结果数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        count[(an[i]/exp)%<span class="hljs-number">10</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        count[i]+=count[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-comment">//这个地方需要从尾遍历到头，因为如果从头遍历到尾时，我们就无法确定前面出现的数的正确位置！！！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        ret[count[(an[i]/exp)%<span class="hljs-number">10</span>]<span class="hljs-number">-1</span>]=an[i];<br>        count[(an[i]/exp)%<span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        an[i]=ret[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-type">int</span> max=an[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(an[i]&gt;max)&#123;<br>            max=an[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//通过最大数的位数对数据分趟桶式排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;max/k&gt;<span class="hljs-number">0</span>;k*=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">countsort</span>(an,len,k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>能够对负数排序的改进基数排序代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//基数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countsort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> exp)</span></span>&#123;<br>    <span class="hljs-type">int</span> count[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//计数数组</span><br>    <span class="hljs-type">int</span> ret[len];  <span class="hljs-comment">//结果数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        count[(an[i]/exp)%<span class="hljs-number">10</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        count[i]+=count[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-comment">//这个地方需要从尾遍历到头，因为如果从头遍历到尾时，我们就无法确定前面出现的数的正确位置！！！</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        ret[count[(an[i]/exp)%<span class="hljs-number">10</span>]<span class="hljs-number">-1</span>]=an[i];<br>        count[(an[i]/exp)%<span class="hljs-number">10</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        an[i]=ret[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-type">int</span> max=an[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> min=an[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(an[i]&gt;max)&#123;<br>            max=an[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(an[i]&lt;min)&#123;<br>            min=an[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        an[i]+=<span class="hljs-built_in">abs</span>(min);<br>    &#125;<br>    <span class="hljs-comment">//根据位数进行分趟桶式排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;max/k&gt;<span class="hljs-number">0</span>;k*=<span class="hljs-number">10</span>)&#123;<br>        <span class="hljs-built_in">countsort</span>(an,len,k);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        an[i]-=<span class="hljs-built_in">abs</span>(min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h3><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p><strong>概念</strong>：</p><ul><li>拓扑排序是对有向无圈图的顶点的一种排序。排序不必是唯一的，任何合理的排序都是可以的。</li><li>具体做法是：先<strong>找出任意一个没有入边的顶点v</strong>(就是没有其他顶点指向的顶点)，<strong>将顶点v放入队列</strong>，然后<strong>将顶点v和它邻接的边从图中删除</strong>(其实就是将顶点v指向的顶点的入边数都-1，这样就可以代表删除边了)，然后<strong>用数组topnum来记录该顶点的排序位置</strong>。然后<strong>重复上述操作</strong>。顶点v的<strong>入度(indegree)为边(u,v)的条数</strong>。并<strong>用indegree数组来存储每个顶点的入度值</strong>。如果<strong>不存在入度为0的顶点，则该图是个有圈图。</strong></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    listnode* next;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">graph</span>(<span class="hljs-type">int</span> n)&#123;<br>        vnum=n;<br>        an=<span class="hljs-keyword">new</span> listnode[n+<span class="hljs-number">1</span>];<br>        indegree=(<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>            an[i].data=<span class="hljs-number">0</span>;<br>            an[i].next= <span class="hljs-literal">nullptr</span>;<br>            indegree[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">listnode* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> listnode;<br>        p-&gt;data=data;<br>        p-&gt;next= <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> add= <span class="hljs-built_in">createNode</span>(data);<br>        <span class="hljs-keyword">if</span>(an[v].next== <span class="hljs-literal">nullptr</span>)&#123;<br>            an[v].next=add;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            listnode* p=an[v].next;<br>            <span class="hljs-keyword">while</span> (p-&gt;next!= <span class="hljs-literal">nullptr</span>)&#123;<br>                p=p-&gt;next;<br>            &#125;<br>            p-&gt;next=add;<br>        &#125;<br>        indegree[data]++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findedgenull</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=vnum;i++)&#123;<br>            <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//拓扑排序</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        <span class="hljs-type">int</span> v=<span class="hljs-built_in">findedgenull</span>();<br>        <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;该图含有圈&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            q.<span class="hljs-built_in">push</span>(v);<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;该图含有圈&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-type">int</span> w=q.<span class="hljs-built_in">front</span>();<br>                cout&lt;&lt;w&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                q.<span class="hljs-built_in">pop</span>();<br>                listnode* p=an[w].next;<br>                <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(--indegree[p-&gt;data]==<span class="hljs-number">0</span>)&#123;<br>                        q.<span class="hljs-built_in">push</span>(p-&gt;data);<br>                    &#125;<br>                    p=p-&gt;next;<br>                &#125;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    listnode *an;<br>    <span class="hljs-type">int</span> vnum;<br>    <span class="hljs-type">int</span> *indegree;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><p><strong>概念</strong>：</p><ul><li><p>考查最短路径问题，可能会输入一个<strong>赋权图(也就是边带有权的图)<strong>，则一条路径的</strong>v1v2..vN的值就是对路径的边的权求和</strong>，这叫做<strong>赋权路径长</strong>，如果是<strong>无权路径长就是单纯的路径上的边数</strong>。</p></li><li><p>在赋权图，可能会出现负值边的情况，这样当我们去找最短路径时，可能会产生负值圈，毕竟一直走负值边可以将数值变得更短。</p></li></ul><p><strong>单源最短路径问题</strong>：</p><ul><li>给定一个赋权图G&#x3D;(V,E)和一个特定顶点s作为输入，找出从s到G中每一个其他顶点的最短赋权路径。</li></ul><p><strong>无权最短路径</strong>：</p><ul><li>给定一个无权图G&#x3D;(V,E)和一个起始顶点s作为输入，找出从s到G中每一个其他顶点的最短路径。</li></ul><h5 id="广度优先搜索算法-BFS"><a href="#广度优先搜索算法-BFS" class="headerlink" title="广度优先搜索算法(BFS)"></a>广度优先搜索算法(BFS)</h5><p><strong>概念</strong>：</p><ul><li><strong>广度优先搜索算法(BFS)<strong>用于在</strong>无权图或者边权相同的图中寻找最短路径。</strong></li><li>该方法<strong>按层处理顶点</strong>，首先<strong>从起始点出发</strong>，进行<strong>发散找到与起始点邻接的顶点a,…<strong>，并</strong>将s到这些顶点的路径距离更新</strong>，然后<strong>将该点标记成已经访问的顶点并将该点的前一个顶点记录下来(被标记的顶点我们后面遇到就认为该点已经不需要再进行处理了)<strong>，然后</strong>再从顶点a,…发散</strong>，找<strong>到该顶点的邻接顶点，然后重复操作</strong>，<strong>直到所有顶点都被标记完</strong>，就完成了搜索。</li><li><strong>具体代码实现</strong>，是<strong>用一个队列</strong>，在<strong>迭代开始</strong>时，<strong>队列中只含有距离为迭代距离currdist的那些顶点</strong>，然后<strong>执行操作时，将距离currdist+1的顶点的那些顶点添加到队列中</strong>，只要当前距离为currdist顶点处理完，就会处理距离为currdist+1(也就是当前顶点发散的顶点)的顶点添加到队列中。</li><li>在队列中其实<strong>可以将know域也就是标记去掉</strong>，因为队列的形式已经说明执行过了，就不会在执行，因此相当于标记了。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//图的邻接表的结点信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">bool</span> flag;    <span class="hljs-comment">//判断是否访问过</span><br>    <span class="hljs-type">int</span> path;     <span class="hljs-comment">//存储上一个顶点</span><br>    <span class="hljs-type">int</span> dist;     <span class="hljs-comment">//距离</span><br>    listnode* next;<br>&#125;;<br><br><span class="hljs-comment">//图的信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    listnode *an;   <span class="hljs-comment">//邻接表形式存储图</span><br>    <span class="hljs-type">int</span> vnum;     <span class="hljs-comment">//图中结点数</span><br>&#125;;<br><br><span class="hljs-comment">//s为起点，an数组的邻接表表示图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(s);<br>        an[s].dist=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> v=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            an[v].flag= <span class="hljs-literal">true</span>;<br>            listnode* p=an[v].next;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">if</span>(an[p-&gt;data].dist==INT_MAX)&#123;<br>                    an[p-&gt;data].dist=an[v].dist+<span class="hljs-number">1</span>;<br>                    an[p-&gt;data].path=v;<br>                    q.<span class="hljs-built_in">push</span>(p-&gt;data);<br>                &#125;<br>                p=p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p><strong>概念</strong>：</p><ul><li>用于<strong>求解赋权图的最短路径(无负值边)<strong>，Dijkstra算法是</strong>解决单源最短路径问题的一般方法，</strong>并且该<strong>解法是贪心算法</strong>。Dijkstra只是BFS的升级版使他能够求赋权图的最短路径，如果求无权图Dijkstra跟BFS的做法一样！</li><li>Dijkstra算法是<strong>分阶段</strong>的，该算法认为<strong>每一个阶段，都将该阶段当作最好的情况处理</strong>，类似于BFS算法，但是还是有不同的地方，比起BFS多出了需要进行每个阶段出现最好情况就进行更新路径。</li><li>具体做法是，从图中<strong>选取起始点v</strong>，然后<strong>找出邻接点</strong>，并<strong>将当前起始点到邻接点v3,v4…的距离更新</strong>，如果是<strong>赋权图就是dv+C<sub>v,v3</sub>(就是顶点v到v3的权)<strong>，如果是</strong>无权就是dv+1</strong>，并<strong>将v标记为已知</strong>。然后<strong>选取邻接点集中的一点再做为起始点</strong>，然后<strong>重复操作</strong>，将当前顶点的前一个顶点记录。当<strong>v到某个顶点的距离在当前阶段是最小的(最好情况)<strong>，那么</strong>就进行更新</strong>，如果<strong>不是就无需更新</strong>。</li><li>具体来说，当我们扩展一个新结点时，我们会考虑它的所有未访问过的邻接结点，并计算从起始结点经过当前结点到达邻接结点的路径长度。如果这个长度小于已知的最短路径长度（或者邻接结点的路径长度尚未初始化），我们就更新邻接结点的路径长度。这样做的目的是通过不断更新路径长度来找到起始结点到所有其他结点的最短路径。</li><li>实现的时候可以使用优先队列来进行优化算法，只将顶点和其最短路径值进入队列中当队列非空，执行以下操作：<strong>u等于队顶的节点</strong>，<strong>w等于队顶节点的最短路径值</strong>；<strong>遍历u的所有边，如果能找到节点v最短路径值小于v的当前值，更新v，将v压入队列</strong>。结束</li><li><strong>没有用优先队列</strong>优化的Dijkstra算法的<strong>时间复杂度为O(N²)<strong>，如果</strong>使用优先队列</strong>，则**时间复杂度为O(nlogn)**，可以不用考虑已知域;</li></ul><p><strong>Dijkstra跟BFS区别：</strong></p><ol><li><strong>处理顶点</strong>：<ul><li>在<strong>BFS算法</strong>中，当一个<strong>顶点被扩展</strong>时，它的<strong>所有未访问过的邻居顶点都被添加到队列中</strong>，这样它们将按照遍历的顺序逐个被访问。</li><li>在<strong>Dijkstra算法</strong>中，当一个<strong>顶点被扩展</strong>时，它的<strong>邻居顶点也被考虑</strong>，但是Dijkstra算法会计算扩展的顶点与其邻居之间的边的权重，并根据这个权重来更新到达邻居顶点的最短路径长度。这个更新过程使得Dijkstra算法能够处理带有非负权重的图。</li></ul></li><li><strong>选择下一个顶点</strong>：<ul><li>在<strong>BFS算法</strong>中，<strong>下一个要被扩展的顶点是队列中的下一个顶点</strong>，也就是按照队列的先进先出（FIFO）原则选择。</li><li>在<strong>Dijkstra算法</strong>中，<strong>下一个要被扩展的顶点是距离起始点路径长度最小的顶点</strong>，也就是根据已知的最短路径长度来选择。这需要使用优先队列或者最小堆来高效地选择路径长度最小的顶点。</li></ul></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//图的邻接表的结点信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> path;     <span class="hljs-comment">//存储上一个顶点</span><br>    <span class="hljs-type">int</span> dist;     <span class="hljs-comment">//最短距离</span><br>    <span class="hljs-type">int</span> weight;   <span class="hljs-comment">//数组索引顶点跟该顶点的边的权重</span><br>    listnode* next;<br>&#125;;<br><br><span class="hljs-comment">//图的信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    listnode *an;   <span class="hljs-comment">//邻接表形式存储图</span><br>    <span class="hljs-type">int</span> vnum;     <span class="hljs-comment">//图中结点数</span><br>&#125;;<br><br><span class="hljs-comment">//v是起始点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        an[v].dist=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(v);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> w=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            listnode* p=an[w].next;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">if</span>(an[w].dist+p-&gt;weight&lt;an[p-&gt;data].dist)&#123;<br>                    an[p-&gt;data].dist=an[w].dist+p-&gt;weight;<br>                    an[p-&gt;data].path=w;<br>                    q.<span class="hljs-built_in">push</span>(p-&gt;data);<br>                &#125;<br>                p=p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>题目模板</strong>：<br>有向边单源最短路径问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> v, w;<br>&#125;;<br><br><span class="hljs-type">bool</span> vis[N+<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;edge&gt;&gt;&amp; graph)</span> </span>&#123;<br>    <span class="hljs-type">int</span> minroad[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(minroad,INF,<span class="hljs-keyword">sizeof</span> minroad);<br>    minroad[start] = <span class="hljs-number">0</span>;<br><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, u] = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        vis[u]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; edges : graph[u]) &#123;<br>            <span class="hljs-type">int</span> v = edges.v;<br>            <span class="hljs-type">int</span> w = edges.w;<br><br>            <span class="hljs-keyword">if</span> (minroad[u] + w &lt; minroad[v]) &#123;<br>                minroad[v] = minroad[u] + w;<br>                pq.<span class="hljs-built_in">push</span>(&#123;minroad[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> minroad[n]!=INF?minroad[n]:<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, start;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;<br><br>    vector&lt;vector&lt;edge&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        graph[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>    &#125;<br><br>    cout&lt;&lt;<span class="hljs-built_in">dijkstra</span>(start, graph)&lt;&lt;endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h5><p><strong>概念</strong>：</p><ul><li>Floyd(弗洛伊德)算法是<strong>基于动态规划思想</strong>的算法，也称<strong>插点法</strong>，是<strong>全源最短路算法</strong>(全源就代表经过一次Floyd算法，每个点到各个点的最短路径都能算出来)</li><li>用于求任意一对顶点间的最短路径，此时图中的<strong>边的权值可以出现负数，但不能出现负环</strong></li><li>时间复杂度为<code>O(n³)</code>，n为点个数</li></ul><p><strong>基本思想</strong>：</p><ol><li>对于从i到j的弧，进行n次试探</li><li>首先考虑i，0，j是否存在，如果存在，则比较i，j和i，0，j的路径长度，去最短者进行更新i，j的最短路径</li><li>然后再添加顶点1，依次类推。</li></ol><p><strong>具体过程</strong>：</p><ol><li>当一个图里有<strong>n个城市</strong>，求全源最短路径问题</li><li>定义<strong>城市k为从当前图拿出来，并重新插入图中的城市</strong>，<code>城市i</code>，<code>城市j</code>分别为当前<code>源城市</code>和<code>目的城市</code>。<code>dist[i\][j]表示城市i到城市j的最短路径</code></li><li>假设当前图中没有城市k，我们<strong>将城市k重新插入到图中</strong></li><li>我们需要判断城市i到城市j的最短路径是否要更新，则<strong>比较路径经过城市k和原来的路径长度进行比较</strong>，如果**经过城市k的路径长度更短，则更新dist[i][j]**，因此就为<code>dist[i][j]=min(dist[i][k]+dist[k][j],dist[i][j])</code></li><li>因此对这个图**执行n次上述操作(也就是插点法)**，得出的dist二维数组就为全源的最短路径。</li></ol><p><strong>代码模板</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dist[n][n]用来记录图中各点到各点的最短路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> **dist)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(dist[i][k]+dist[k][j]&lt;dist[i][j])&#123;<br>                    dist[i][j]=dist[i][k]+dist[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题部分代码</strong>：</p><p>具体可看力扣<a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a>，只包含求解全源最短路径代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-type">int</span> dist[n][n];<br>    <span class="hljs-built_in">memset</span>(dist,INF, <span class="hljs-built_in">sizeof</span>(dist));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        dist[i][i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge:edges)&#123;<br>        dist[edge[<span class="hljs-number">0</span>]][edge[<span class="hljs-number">1</span>]]=edge[<span class="hljs-number">2</span>];<br>        dist[edge[<span class="hljs-number">1</span>]][edge[<span class="hljs-number">0</span>]]=edge[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//Floyd算法计算全源最短路代码</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(dist[i][k]+dist[k][j]&lt;dist[i][j])&#123;<br>                    dist[i][j]=dist[i][k]+dist[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;城市到其他城市最短路径：&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;edges&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-built_in">Floyd</span>(<span class="hljs-number">5</span>,edges);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><strong>概念</strong>：</p><ul><li><strong>最小生成树</strong>是一颗<strong>连接图G所有顶点的边构成的一颗权最小的树</strong>，<strong>最小生成树一般是在无向图中寻找。</strong></li><li>最小生成树**共有N-1条边(N为顶点数)**。</li></ul><p><strong>算法</strong>：</p><h5 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h5><p><strong>概念</strong>：</p><ul><li>Prim(普里姆)算法是生成最小生成树的一种算法，该算法基本上和求最短路径的Dijkstra算法一样</li><li>具体操作：<strong>选取一个顶点作为树的根节点v1</strong>，然后<strong>从这个顶点发散</strong>，找到其<strong>邻接顶点(加入队列中)<strong>，然后</strong>选取根节点到邻接顶点中权最小的路径</strong>(也就是连接该路径的另一个顶点)进行<strong>添加到树中(也将连接的顶点除去v1的顶点的邻接顶点加入队列中)<strong>，然后初步</strong>形成一个图为u</strong>，然后再<strong>按顺序的查找图u与队列中的顶点的最小路径并加入树中</strong>，重复操作。</li><li>最小生成树信息打印，<strong>打印树中边的顶点对组</strong>。</li></ul><p>实现代码：</p><p><code>使用优先队列</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        an[v].dist=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用优先队列,定义参数&lt;数据类型，容器类型，比较方法&gt;</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt;q;<br>        <span class="hljs-comment">//pair&lt;int,int&gt;对组的第一个为权，第二个为顶点。</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,v));<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> w=q.<span class="hljs-built_in">top</span>().second;<br>            q.<span class="hljs-built_in">pop</span>();<br>            listnode* p=an[w].next;<br>            <span class="hljs-keyword">if</span>(an[w].flag) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">//选取最小权的边而不是顶点到顶点的最短距离</span><br>                <span class="hljs-keyword">if</span>(p-&gt;weight&lt;an[p-&gt;data].dist&amp;&amp;!an[p-&gt;data].flag)&#123;<br>                    an[p-&gt;data].dist=p-&gt;weight;<br>                    an[p-&gt;data].path=w;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(p-&gt;weight,p-&gt;data));<br>                &#125;<br>                p=p-&gt;next;<br>            &#125;<br>            an[w].flag= <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;     <span class="hljs-comment">//记录最小生成树的总权</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=vnum;i++)&#123;<br>            <span class="hljs-keyword">if</span>(an[i].path!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;an[i].path)<br>                    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;an[i].path&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; 权:&quot;</span>&lt;&lt;an[i].dist&lt;&lt;endl;<br>                <span class="hljs-keyword">else</span><br>                    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;an[i].path&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; 权:&quot;</span>&lt;&lt;an[i].dist&lt;&lt;endl;<br>                w+=an[i].dist;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;总权:&quot;</span>&lt;&lt;w;<br>        cout&lt;&lt;endl;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>使用vector容器模拟优先队列</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> v;    <span class="hljs-comment">//顶点</span><br>    <span class="hljs-type">int</span> weight;   <span class="hljs-comment">//权</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge &amp;a,<span class="hljs-type">const</span> edge &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> b.weight&lt;a.weight;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        an[v].dist=<span class="hljs-number">0</span>;<br>        vector&lt;edge&gt;q;<br>        q.<span class="hljs-built_in">push_back</span>(&#123;v,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-built_in">sort</span>(q.<span class="hljs-built_in">begin</span>(),q.<span class="hljs-built_in">end</span>(),cmp);<br>            <span class="hljs-type">int</span> w=q.<span class="hljs-built_in">back</span>().v;<br>            q.<span class="hljs-built_in">pop_back</span>();<br>            listnode* p=an[w].next;<br>            <span class="hljs-keyword">if</span>(an[w].flag) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">//选取最小权的边而不是顶点到顶点的最短距离</span><br>                <span class="hljs-keyword">if</span>(p-&gt;weight&lt;an[p-&gt;data].dist&amp;&amp;!an[p-&gt;data].flag)&#123;<br>                    an[p-&gt;data].dist=p-&gt;weight;<br>                    an[p-&gt;data].path=w;<br>                    q.<span class="hljs-built_in">push_back</span>(&#123;p-&gt;data,p-&gt;weight&#125;);<br>                &#125;<br>                p=p-&gt;next;<br>            &#125;<br>            an[w].flag= <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;     <span class="hljs-comment">//记录最小生成树的总权</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=vnum;i++)&#123;<br>            <span class="hljs-keyword">if</span>(an[i].path!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;an[i].path)<br>                    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;an[i].path&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; 权:&quot;</span>&lt;&lt;an[i].dist&lt;&lt;endl;<br>                <span class="hljs-keyword">else</span><br>                    cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;an[i].path&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; 权:&quot;</span>&lt;&lt;an[i].dist&lt;&lt;endl;<br>                w+=an[i].dist;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;总权:&quot;</span>&lt;&lt;w;<br>        cout&lt;&lt;endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p><strong>概念</strong>：</p><ul><li>Kruskal(克鲁斯卡尔)算法是连续地按照最小的权选择边，并且当所选的边不产生圈时就把它作为最小生成树中的边。</li><li>该算法是在处理一个森林–树的集合。开始的时候，存在|V|棵单节点树，而添加一边则将两棵树合并成一颗树。当算法终止时，就只有一棵树，就是最小生成树。</li></ul><h6 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h6><ul><li><p>并：合并，查：查询连通关系，集：形成集合，<strong>用于处理连通性问题</strong>。</p></li><li><p>并查集：<strong>集合中的元素组织成树的形式</strong>：</p></li></ul><ol><li><p><strong>查找两个元素是否属于同一集合</strong>：所在树的根结点是否相同</p></li><li><p><strong>合并两个集合</strong>——将一个集合的根结点作为另一个集合根结点的孩子</p></li></ol><p><strong>具体操作</strong>：</p><ul><li>该算法是根据<strong>选取边</strong>来进行生成最小生成树，那么我们就<strong>将图的信息用一个边集结构表示</strong>，我们<strong>需要进行一个循环，循环条件就是当最小生成树的边达到N-1条时就退出(N为元素个数)<strong>，每</strong>次循环我们都需要选取最小权重的边</strong>，并且<strong>判断在树中加入这条边会不会形成圈</strong>，如果<strong>形成圈就不进行加入</strong>，直到树的边条数达到N-1就形成了最小生成树。</li><li>该算法的关键是<strong>判断在树中加入边会不会形成圈–也就是判断两个顶点是否位于两个连通分量</strong>，这就需要<strong>并查集</strong>的操作：在图中我们<strong>将每个顶点都当作一个集合</strong>，我们<strong>插入边</strong>的时候，直接<strong>判断这两个顶点是否处于一个集合中</strong>，如何是<strong>一个集合就不进行加入</strong>，如果<strong>不是一个集合，就需要将两个集合进行合并</strong>，那么这<strong>就需要一个存储每个节点的根(父亲)节点的数组parent</strong>。我们将parent每个连通分量(集合)进行初始化为-1，表示没有父亲。</li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;  <span class="hljs-comment">//u，v为顶点的，w为权重,u为起始点，v为终点</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> edge &amp;a,<span class="hljs-type">const</span> edge &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> parent[])</span></span>&#123;<br>        <span class="hljs-type">int</span> t=v;<br>        <span class="hljs-keyword">while</span> (parent[t]&gt;<span class="hljs-number">-1</span>)&#123;    <span class="hljs-comment">//查找该集合的根节点。</span><br>            t=parent[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        vector&lt;edge&gt;q;<br>        <span class="hljs-comment">//存储每个连通变量的父亲节点的数组</span><br>        <span class="hljs-type">int</span> parent[vnum+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;     <span class="hljs-comment">//记录最小生成树的总权</span><br>        <span class="hljs-built_in">memset</span>(parent,<span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*(vnum+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//生成边集数组。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=vnum;i++) &#123;<br>            listnode *p = an[i].next;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">if</span>(i&lt;p-&gt;data)<br>                    q.<span class="hljs-built_in">push_back</span>(&#123;i, p-&gt;data, p-&gt;weight&#125;);<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进行排序将最小权边放入第一位。</span><br>        <span class="hljs-built_in">sort</span>(q.<span class="hljs-built_in">begin</span>(),q.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;num&lt;vnum<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> v1=<span class="hljs-built_in">findroot</span>(q[i].u,parent);<br>            <span class="hljs-type">int</span> v2= <span class="hljs-built_in">findroot</span>(q[i].v,parent);<br>            <span class="hljs-comment">//判断祖先节点是否相等--判断是否在一个集合.</span><br>            <span class="hljs-keyword">if</span>(v1!=v2)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;q[i].u&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;q[i].v&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;<span class="hljs-string">&quot; 权:&quot;</span>&lt;&lt;q[i].w&lt;&lt;endl;<br>                w+=q[i].w;<br>                parent[v2]=v1;    <span class="hljs-comment">//合并集合。</span><br>                num++;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;总权:&quot;</span>&lt;&lt;w;<br>        cout&lt;&lt;endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="深度优先算法-DFS"><a href="#深度优先算法-DFS" class="headerlink" title="深度优先算法(DFS)"></a>深度优先算法(DFS)</h4><p><strong>概念</strong>：</p><ul><li><p>深度优先算法(DFS)跟BFS算法一样是<strong>用于遍历图的算法</strong>，但是DFS并不像BFS算法一样，它搜索出来的路径<strong>不具有最短性</strong>，并且dfs算法<strong>类似于枚举</strong>，因此**DFS算法一般用于求出问题的所有路径(例如全排列)**。</p></li><li><p>深度优先算法就是<strong>从起点出发，选择与其邻接的一条路径进行搜索</strong>，<strong>将该路径搜索完</strong>(没有路了或者是个回路)，<strong>再进行回退</strong>，<strong>重新选择</strong>其他路径搜索。这样就需要<strong>使用递归</strong>实现，而<strong>判断是否访问过顶点</strong>就需要一个bool类型的<strong>数组vis进行记录</strong>。</p></li><li><p>对于<strong>非强连通图</strong>，那么可能在<strong>某个节点开始的深度优先搜索可能访问不了所有的节点</strong>，在这种情况，我们<strong>选取某个未被访问的节点开始，再执行深度优先搜索。</strong></p></li><li><p>dfs中最重要的算法思想是<strong>回溯和剪枝</strong>，dfs+回溯+剪枝也可以用于求解最短路径，但是BFS的时间复杂度更低。</p><blockquote><ol><li>回溯是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</li><li>剪枝，就是减小搜索树规模、尽早排除搜索树中不必要的分支的一种手段。形象地看，就好像剪掉了搜索树的枝条，故称之为“剪枝”</li></ol></blockquote></li></ul><p><strong>具体操作</strong>：</p><ul><li>在<strong>访问</strong>图中某一<strong>起始点v</strong>后，<strong>由v出发</strong>，<strong>访问它的任一邻接点w1;</strong></li><li><strong>再从w1出发</strong>，<strong>访问与w1邻接但还未被访问过的顶点w2</strong>；</li><li>然后再从w2出发，<strong>进行类似的访问</strong>….</li><li>如此进行下去，<strong>直至到达所有的邻接顶点都被访问过的顶点u为止</strong>。</li><li>接着，<strong>退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。</strong></li><li><strong>如果有</strong>，则访问此顶点，之后<strong>再从此顶点出发</strong>，进行与前述类似的访问；</li><li><strong>如果没有</strong>，就<strong>再退回一步进行搜索</strong>。重复上述过程，直到连通图中所有顶点都被访问过为止。</li></ul><p><strong>实现代码</strong>：</p><p><code>邻接矩阵表示图的算法实现</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> vis[g.vexnum];   <span class="hljs-comment">//记录顶点访问信息，需要初始化为false</span><br><br><span class="hljs-comment">//图g为邻接矩阵类型，v为访问顶点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph g,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    cout&lt;&lt;v;<br>    vis[v]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//依次检查邻接矩阵v所在行。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;g.vexnum;w++)&#123;<br>        <span class="hljs-comment">//w是v的邻接点，如果w未访问，则递归调用dfs</span><br>        <span class="hljs-keyword">if</span>(g.arcs[v][w]!=<span class="hljs-number">0</span>&amp;&amp;!vis[w])&#123;<br>            <span class="hljs-built_in">dfs</span>(g,w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>邻接表表示图的算法实现</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        cout&lt;&lt;v;<br>        an[v].flag= <span class="hljs-literal">true</span>;<br>        listnode* p=an[v].next;<br>        <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!an[p-&gt;data].flag)&#123;<br>                <span class="hljs-built_in">DFS</span>(p-&gt;data);<br>            &#125;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="双连通性"><a href="#双连通性" class="headerlink" title="双连通性"></a>双连通性</h4><p><strong>概念</strong>：</p><ul><li>双连通性就是当<strong>删除图中的一个顶点</strong>，使<strong>图分割成两个图</strong>，则<strong>这个图就具有双连通性</strong>，而<strong>能导致图分割成多张图的顶点称为割点</strong></li><li><strong>背向边</strong>：当<strong>一个顶点被访问</strong>时，选<strong>取该顶点其中一个未访问过的邻接顶点进行访问</strong>，<strong>没被选取到的邻接顶点与当前顶点形成的边称为背向边</strong></li></ul><p><strong>寻找割点</strong>：</p><ul><li><p>从图中<strong>任一顶点开始</strong>，<strong>执行深度优先搜索并在顶点被访问时给它们编号</strong>。对于<strong>每一个顶点v我们称其先序编号为Num(v)</strong>;</p></li><li><p>对于深度优先搜索生成树上的每一个顶点v，<strong>计算编号最低的顶点</strong>，我们<strong>称之为Low(v)</strong>;对于求解每个顶点的Low，需要对深度优先生成树进行一次后序遍历算出，因为求出顶点v的Low的规则如下：</p><blockquote><ol><li>Num(v)</li><li>所有背向边(v,w)中的最低Num(w)</li><li>树的所有边(v,w)中的最低Low(w)   –所以需要后序遍历</li><li>Low(v)等于前面三个变量中的最小值。</li></ol></blockquote></li><li><p>如果一个<strong>顶点v为割点</strong>，需要满足<strong>它的子节点w</strong>的<code>Low(w)&gt;=Num(v)</code></p></li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br>    <span class="hljs-type">int</span> data;     <span class="hljs-comment">//num</span><br>    <span class="hljs-type">bool</span> flag;    <span class="hljs-comment">//判断是否访问过</span><br>    <span class="hljs-type">int</span> parent;     <span class="hljs-comment">//父节点</span><br>    <span class="hljs-type">int</span> low;<br>    listnode* next;<br>&#125;;<br><br><span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findart</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        an[v].flag= <span class="hljs-literal">true</span>;<br>        an[v].low=an[v].data=count++;<br>        listnode* p=an[v].next;<br>        <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!an[p-&gt;data].flag)&#123;<br>                an[p-&gt;data].parent=v;<br>                <span class="hljs-built_in">findart</span>(p-&gt;data);<br>                <span class="hljs-keyword">if</span>(an[p-&gt;data].low&gt;=an[v].data)&#123;<br>                    cout&lt;&lt;<span class="hljs-string">&quot;V&quot;</span>&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot;为割点&quot;</span>&lt;&lt;endl;<br>                &#125;<br>                an[v].low=<span class="hljs-built_in">min</span>(an[v].low,an[p-&gt;data].low);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(an[v].parent!=p-&gt;data)&#123;<br>                an[v].low=<span class="hljs-built_in">min</span>(an[v].low,an[p-&gt;data].data);<br>            &#125;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="图论技巧"><a href="#图论技巧" class="headerlink" title="图论技巧"></a>图论技巧</h3><h4 id="超级源点-汇点"><a href="#超级源点-汇点" class="headerlink" title="超级源点&#x2F;汇点"></a>超级源点&#x2F;汇点</h4><p><strong>概念</strong>：</p><ul><li><p><code>超级源点/汇点</code>是模拟出来的虚拟点，多用于图中：</p><blockquote><ol><li>同时有<strong>多个源点和多个汇点</strong>，<strong>建立超级源点和超级汇点</strong></li><li>同时有<strong>多个源点和一个汇点</strong>，<strong>建立超级源点</strong></li><li>同时有<strong>多个汇点和一个源点</strong>，建立<strong>超级汇点</strong></li></ol><p>总结：<code>源点和汇点哪个有多个，就开哪个的超级点</code></p></blockquote></li><li><p>介绍：我们平时所做的算法多是适用于一个源点到一个汇点或者是一个源点到多个汇点的类型，但是如果出现多个源点对应多个汇点时，我们会不知所措。跑多遍算法？那样会TLE，换个思维，既<strong>然是从多个源点出发到多个汇点，我们能不能建立一个点来代替多个源点&#x2F;汇点 的效果，而又不影响答案。</strong></p></li></ul><p><strong>做法</strong>：</p><ul><li>当我们具有<strong>多个源点和一个汇点，</strong>我们要<strong>求源点到汇点的最短路径</strong>，则可以<code>建立一个超级源点，连接所有源点，并且路径长度为0</code>，然后<strong>只需要跑超级源点到汇点这(n+1)个点的最短距离即可</strong></li></ul><p>例题：</p><p><a href="https://www.acwing.com/problem/content/1490/">ACWing 1488.最短距离</a></p><p><strong>分析</strong>：</p><p>要求每次查询给出的村庄y到最近距离的商店的距离，对于每次查询，起点只有一个，汇点有多个，我们可以逆向思维，这样就变成<strong>商店作为源点，村庄y作为汇点</strong>，就变成了<strong>多个源点到单个汇点问题，这样我们创建一个超级源点，连接所有源点，并且路径长度为0，去跑dijkstra算法即可</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pii</span>&#123;<br>    <span class="hljs-type">int</span> v,w;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> d,u;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> edge&amp; other) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> d&gt;other.d;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n,m,k,q,a,b,c;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> vis[N];<br>vector&lt;pii&gt;g[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;edge,vector&lt;edge&gt;,greater&lt;edge&gt;&gt;pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        edge p=pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> u=p.u,d=p.d;<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        vis[u]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:g[u])&#123;<br>            <span class="hljs-type">int</span> v=x.v,w=x.w;<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+w)&#123;<br>                dist[v]=dist[u]+w;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[v],v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>        g[b].<span class="hljs-built_in">push_back</span>(&#123;a,c&#125;);<br>    &#125;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;a;<br>        g[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(&#123;a,<span class="hljs-number">0</span>&#125;);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    cin&gt;&gt;q;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        cin&gt;&gt;a;<br>        cout&lt;&lt;dist[a]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>概念</strong>：</p><ul><li><strong>贪心算法是一种思想</strong>，并不是一种算法，贪心算法是<strong>分阶段地工作，在每一个阶段，可以认为所作决定是好的，而不考虑将来地后果。</strong></li><li>算法的<strong>每个阶段总是选择当前阶段最优</strong>，这种策略<strong>希望当算法终止时，能够将每一次的局部最优变成全局最优。</strong></li></ul><h4 id="调度问题"><a href="#调度问题" class="headerlink" title="调度问题"></a>调度问题</h4><p><strong>概念</strong>：</p><ul><li><strong>调度问题</strong>就是<strong>安排一个完成任务的顺序使得全部任务完成的平均完成的时间能够最小化</strong>。</li></ul><p><strong>单个处理器</strong></p><ul><li>调度任务的方式我们一般使用<strong>非预占调度</strong>：<strong>一旦开始一个任务，就必须将这个任务运行到完成</strong></li><li>调度问题一般都是<strong>最短任务最先进行</strong>，这样将会<strong>产生出每个阶段最优的调度，使得达到全局最优的调度。</strong></li><li>操作系统调用程序一般把优先权赋予那些更短的任务。</li></ul><p><strong>多处理器</strong>：</p><ul><li>如果我们有多个处理器，并且任务是有序的(按照最短时间排序)，这个时候的任务调度问题需要进行小部分的改变，但跟单个处理器的思想是一样的</li><li>假设我们有<strong>p个处理器</strong>，则我们<strong>选择前p个任务分配给各个处理器各一个</strong>，然后<strong>第p+1任务分配给第一个处理器</strong>，然后<strong>后面的就是按照这个规则分配。</strong></li><li>第二个最优解，是将<strong>任务分组分配给各个处理器</strong>，且<strong>任务个数能整除处理器个数</strong>，是<strong>对于0&lt;&#x3D;i&lt;N&#x2F;p</strong>，p为处理器个数，N为任务总数，i为处理器序号，我们<strong>从任务i*p+1直到任务(i+1)*p的每个任务放到编号为i的处理器中。</strong></li></ul><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p><strong>概念</strong>：</p><ul><li>哈夫曼(Huffman)编码是<strong>一种压缩文件的编码</strong>，根据<strong>文件出现的字符使用一种将数据存在树叶上的二叉树来表示每个字符的二进制代码</strong>。</li><li><strong>每个字符通过从根节点开始用0指示左分支用1表示右分支而以记录路径的方法表示出来</strong>。如果字符c<sub>i</sub>在深度d<sub>i</sub>处并且出现f<sub>i</sub>次，那么该字符代码的值为对d<sub>i</sub>f<sub>i</sub>的求和。</li><li>一个<strong>最优的哈夫曼编码</strong>是一种<strong>满二叉树</strong>：<strong>所有的节点或者是树叶，或者有两个子节点。</strong></li><li>而贪心算法在这里就是<strong>根据字符出现的频率找出总价值最小的满二叉树</strong>，其中所有字符位于树叶。就是<strong>将出现次数少的放在深度深的地方(编码位数较多)，将出现最多放在最浅的地方(编码位数较少)</strong></li><li>例如图10-9，字符a压缩后所表示的二进制代码为000</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529591.png" alt="image"></p><p><strong>哈夫曼算法</strong>：</p><ul><li>为了生成最优的哈夫曼编码树，哈夫曼提出了哈夫曼算法，这个算法也是使用了贪心的策略</li><li>假设<strong>字符个数为C</strong>，算法的描述如下：算法对一个由树组成的森林进行。<strong>一棵树的权等于它的树叶(字符)的频率的和</strong>。<strong>任意选取最小权的两棵树T1和T2</strong>，并<strong>任意形成以T1和T2为子树的新树</strong>，<strong>将这样的过程进行C-1次</strong>。在<strong>算法的开始</strong>，<strong>存在C课单节点树</strong>–每个字符一颗树。在<strong>算法结束时得到一棵树</strong>，这棵树就是最优哈夫曼编码树。</li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//树的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span>&#123;<br>    <span class="hljs-type">char</span> data;   <span class="hljs-comment">//存字符</span><br>    tree* left;<br>    tree* right;<br>    <span class="hljs-type">int</span> weight;    <span class="hljs-comment">//权重</span><br>&#125;;<br><br><span class="hljs-comment">//用来定义优先队列的比较规则</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(tree *a, <span class="hljs-type">const</span> tree* b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a-&gt;weight&lt;b-&gt;weight;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//需要将数据先存入优先队列中</span><br>priority_queue&lt;tree*,vector&lt;tree*&gt;,cmp&gt;pq;<br><br><br><span class="hljs-function">tree* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data,<span class="hljs-type">int</span> weight)</span></span>&#123;<br>    tree* p=<span class="hljs-keyword">new</span> tree;<br>    p-&gt;data=data;<br>    p-&gt;left= <span class="hljs-literal">nullptr</span>;<br>    p-&gt;right= <span class="hljs-literal">nullptr</span>;<br>    p-&gt;weight=weight;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function">tree* <span class="hljs-title">merge</span><span class="hljs-params">(tree* &amp;t1,tree* &amp;t2)</span></span>&#123;<br>    <span class="hljs-type">int</span> n=t1-&gt;weight+t2-&gt;weight;<br>    tree* p= <span class="hljs-built_in">createNode</span>(<span class="hljs-number">0</span>,n);<br>    p-&gt;left=t1;<br>    p-&gt;right=t2;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function">tree* <span class="hljs-title">Huffman</span><span class="hljs-params">()</span></span>&#123;<br>    tree* p;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        tree* t1=pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        tree* t2=pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        p=<span class="hljs-built_in">merge</span>(t1,t2);<br>        pq.<span class="hljs-built_in">push</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p><strong>概念</strong>：</p><ul><li><strong>分治算法</strong>也是一种<strong>思想策略</strong>，分治算法就是<strong>将大问题不断地分成小问题解决后再重新构建原问题地解</strong>。一般地分治算法的时间复杂度为<em>O(NlogN)</em></li><li><strong>分</strong>：<strong>递归</strong>解决较小的问题；<strong>治</strong>：然后，<strong>从子问题的解构建原问题的解</strong>。分治算法中我们一直<strong>坚持子问题是不相交的(即基本不重叠)</strong></li></ul><h4 id="最近点问题"><a href="#最近点问题" class="headerlink" title="最近点问题"></a>最近点问题</h4><p><strong>概念</strong>:</p><ul><li>对于平面内存在一个点集P，找到点集P中的最小距离的点对(两个点的距离在点集中所有点产生的距离中最短)。</li><li>如果按照简单地方法解决就需要嵌套循环导致时间复杂度为O(N²)，但是这个时间复杂度太大了，因此我们就是用到分治</li></ul><p><strong>解决方法</strong>：</p><ul><li><p>将<strong>点集P按照x轴进行排序</strong>。</p><ul><li>对于<strong>每个递归操作</strong>，<strong>将点集P分成两个点集P<sub>L</sub>和P<sub>R</sub><strong>，</strong>找出d<sub>L</sub>,d<sub>c</sub>,d<sub>R</sub><strong>，</strong>求</strong>这之间的<strong>最小值</strong>，然后<strong>递归返回解得到最终问题的解</strong>。</li></ul></li><li><p><strong>d<sub>L</sub><strong>是在</strong>点集P<sub>L</sub>最短距离的点对的距离</strong>，<strong>d<sub>c</sub><strong>是</strong>跨越点集P<sub>L</sub>和P<sub>R</sub>的最短距离的点对的距离</strong>，<strong>d<sub>R</strong></sub>是<strong>在点集P<sub>R</sub>最短距离的点对的距离</strong>。</p></li><li><p><strong>d<sub>c</sub>的求法</strong>：<strong>令 δ&#x3D;min(d<sub>L</sub>，d<sub>R</sub>)<strong>，如果</strong>出现d<sub>c</sub>更小的情况</strong>，则<strong>d<sub>c</sub>的两个点必然在分割线的左右各δ的距离之内</strong>，我们将<strong>这个区域叫做一条带</strong>。我们<strong>将</strong>在<strong>带的区域内的点按照y轴排序</strong>，如果<strong>两个点的y轴坐标相差大于δ，则d<sub>c</sub>&gt;δ</strong>，因此<strong>就可以不进行判断直接跳过，处理下一对点对</strong>。伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先将带区域内的点按照y轴排序</span><br><span class="hljs-comment">//NumPoint为带区域的点集的点个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NumPoint;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;Numpoint;j++)&#123;<br>        <span class="hljs-comment">//判断点对的y轴距离是否大于δ</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">diff</span>(pi.y,pj.y)&gt;δ)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">diff</span>(pi,pj)&lt;δ)&#123;    <span class="hljs-comment">//判断pi到pj的距离是否小于δ</span><br>            δ=<span class="hljs-built_in">diff</span>(pi,pj);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h4><p><strong>概念</strong>：</p><ul><li><strong>选择问题要求我们找出含N个元素的表S中的第k个最小的元素</strong>。</li><li>该问题的解法虽然使用了分治算法的策略，但是他在分之后只需要求解一个子问题，也不需要合并子问题求解，换句话来说，这个问题就是将大问题不断地分找到属于这个问题地解。</li></ul><p><strong>具体做法</strong>：</p><ul><li><strong>每次递归操作</strong>，<strong>选取一个枢纽元v</strong>，<strong>将集合S根据枢纽元分成S1，S2两个集合</strong>，S1的元素小于枢纽元，S2的元素大于枢纽元</li><li>如果<strong>k&lt;&#x3D;|S1|</strong>  –<strong>|S1|为集合S1的元素个数</strong>，就<strong>递归集合S1求解集合S中的第k个最小元素。</strong></li><li>如果<strong>k&#x3D;|S1|+1</strong>，则<strong>枢纽元就是第k个最小元素</strong>。</li><li><strong>否则</strong>，<strong>在S中的第k个最小元素是S2中的第(k-|S1|-1)个最小元素</strong>。</li></ul><p><strong>五分化中项法</strong>：</p><ul><li>这也是一个选取枢纽元的方法，这个算法的性能更高</li></ul><p><strong>概念</strong>：</p><ul><li><strong>把N个元素分成向下取整(N&#x2F;5)组，5个元素一组，忽略(最多4个)剩余的元素</strong></li><li><strong>找出每组的中项(中间值)<strong>，</strong>得到向下取整(N&#x2F;5)个中项的表M</strong></li><li><strong>求出M的中项，将其作为枢纽元v返回</strong></li></ul><h3 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h3><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p><strong>概念</strong>：</p><ul><li><strong>KMP算法</strong>是用于解决字符串匹配的问题的算法，也就是有<strong>一个文本串和一个模式串</strong>，<strong>求解这个模式串是否在文本串中出现或者匹配</strong>。</li><li>相对于暴力求解，KMP算法<strong>使用了前缀表来进行匹配</strong>，充分利用了之前匹配的字符，减少了重新匹配全部模式串的时间。</li><li>时间复杂度为O(m+n)，其中n为文本串长度，m为模式串长度。</li></ul><p><strong>前缀表</strong>：</p><p>例子：文本串：’aabaabaaf’ ，模式串：’aabaaf’</p><ul><li><p>前缀表也就是<strong>记录模式串的各子串最长相等前后缀长度</strong>(即字符串的前缀和后缀相等并且长度最长)的<strong>数组</strong>，而<em>在KMP算法中是对模式串求解前缀表</em></p></li><li><p><strong>前缀</strong>：<strong>字符串除了尾字符的子字符串</strong>都是前缀，模式串的前缀有：a、aa、aab、aaba、aabaa</p></li><li><p><strong>后缀</strong>： <strong>字符串除了首字符的子字符串</strong>都是后缀，模式串的后缀有：f、af、aaf、baaf、abaaf</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529592.png" alt="image"></p></li><li><p>根据上述的例子可以列出表格：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529593.png" alt="image"></p></li><li><p>这样就对应着：aabaaf  010120，这个就为前缀表，而<strong>前缀表</strong>在KMP算法中被称为<code>next数组</code>或者<code>prefix数组</code>。next的意思就是指通过这个数组可以知晓下一步指针会跳到哪一步。</p></li></ul><p><strong>求解next数组</strong>：</p><p>注：在<strong>遍历模式串的各个子串</strong>时，<strong>i为当前子串的后缀末尾索引</strong>，<strong>j为当前字串的前缀末尾索引</strong>并且为<strong>数组索引小于等于i之前的子串的最长相等前后缀长度</strong>。子串是连续的字符形成的</p><ol><li><code>初始化</code>：<strong>j初始化为0</strong>，因为模式串的第一个前缀子串为第一个字符，所以j索引指向0的位置，并且<strong>next[0]&#x3D;0</strong>，<strong>i初始化为1</strong>，用<strong>一个循环从索引i开始遍历模式串</strong>。(因为只有一个字符的子串没有相等前后缀)</li><li><code>前后缀不相同情况</code>：为了充分利用之前已经匹配的字符，我们将对发生冲突的地方也就是<strong>前后缀末尾字符不匹配的时候</strong>，我们将<strong>对前缀末尾索引</strong>进行<strong>回溯到索引为next[j-1]的位置</strong>。</li><li><code>前后缀相同情况</code>：<strong>当前后缀末尾字符相等的时候</strong>，就可以<strong>将j++<strong>，不仅将当前子串更新到下一个子串，还</strong>更新了当前子串的最长相等前后缀长度</strong>也就是<strong>next[i]&#x3D;j</strong></li></ol><p>实现代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(<span class="hljs-type">int</span> *next,<span class="hljs-type">const</span> string&amp; s,<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-comment">//前后缀不相等情况</span><br>        <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;s[i]!=s[j])&#123;<br>            j=next[j<span class="hljs-number">-1</span>];    <span class="hljs-comment">//回溯找到相等位置或者回到0</span><br>        &#125;<br>        <span class="hljs-comment">//前后缀相同情况</span><br>        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;<br>        next[i]=j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>KMP具体操作</strong>：</p><ol><li><code>求解next数组</code></li><li>然后<strong>利用求解next数组同等思路</strong>，<code>求解文本串出现模式串位置的索引</code>，求解next数组是模式串前后缀末尾字符的比较，而文本串模式串匹配过程，是文本串与模式串的字符比较过程。</li><li>当<strong>j</strong>也就是<strong>文本串在索引大于等于i之前的子串与模式串最长匹配字符长度等于模式串的长度</strong>，就<strong>说明文本串出现了模式串</strong>，然后<strong>返回文本串中出现模式串的第一个字符的索引值</strong><code>(i-j+1)</code>。</li></ol><p>KMP算法总体实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">(<span class="hljs-type">int</span> *next,<span class="hljs-type">const</span> string&amp; s,<span class="hljs-type">int</span> size)</span></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-comment">//前后缀不相等情况</span><br>        <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;s[i]!=s[j])&#123;<br>            j=next[j<span class="hljs-number">-1</span>];    <span class="hljs-comment">//回溯找到相等位置或者回到0</span><br>        &#125;<br>        <span class="hljs-comment">//前后缀相同情况</span><br>        <span class="hljs-keyword">if</span>(s[i]==s[j]) j++;<br>        next[i]=j;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;text,<span class="hljs-type">const</span> string &amp;mode)</span></span>&#123;<br>    <span class="hljs-type">int</span> len=text.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> size=mode.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,next[size];<br>    <span class="hljs-built_in">getnext</span>(next,mode,size);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;text[i]!=mode[j])&#123;<br>            j=next[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i]==mode[j]) j++;<br>        <span class="hljs-keyword">if</span>(j==size) <span class="hljs-keyword">return</span> (i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">//未找到模式串</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先(LCA)"></a>最近公共祖先(LCA)</h3><p><strong>概念</strong>：</p><ul><li><strong>祖先节点</strong>：给定一棵多叉树，对于其中任意非根节点x，我们称从x的父节点到根节点的路径上的所有点为x的祖先节点</li><li><strong>公共祖先</strong>：如果节点a同时是节点b和c的祖先，称a是b和c的公共祖先</li><li><code>最近公共祖先LCA</code>:对于树上任意两点x和y，<strong>距离它们最近的公共祖先的节点</strong>就称为x和y的最近公共祖先(简称LCA)</li></ul><h4 id="朴素求解-暴力"><a href="#朴素求解-暴力" class="headerlink" title="朴素求解(暴力)"></a>朴素求解(暴力)</h4><p><strong>原理</strong>：我们<strong>只需要将x和y节点都升到同一深度或同一层</strong>，并<strong>让x和y同时向上走，直到x和y相等时</strong>，当前的<strong>x或y就是原先x和y节点的最近公共祖先</strong></p><p><strong>时间复杂度</strong>：最坏情况下，<strong>n为树上节点数，q为查询次数</strong>，则朴素求解的lca时间复杂度为<code>O(q*n)</code></p><p><strong>做法</strong>：</p><ol><li>定义一个<code>dep数组</code>和<code>p数组</code>，分别<strong>用于存储树上节点的深度</strong>和<strong>每个树上节点的父节点</strong></li><li>先用<code>dfs</code><strong>预处理dep数组和p数组</strong></li><li>对于<strong>每次查询</strong>，我们<strong>先判断dep[x]是否大于dep[y]<strong>，如果</strong>小于，则将x和y交换</strong></li><li><strong>将x上升到与y相同深度</strong>，也就是dep[x]&#x3D;&#x3D;dep[y]的时候</li><li>然后<strong>令x和y一起上升</strong>，<strong>直到x&#x3D;&#x3D;y，则x或y就是最近公共祖先</strong>，返回x或y</li></ol><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n,m,s,a,b;  <span class="hljs-comment">//n为节点数，m为查询次数，s为根节点编号,a和b用于临时存储节点的临时变量</span><br><span class="hljs-type">int</span> dep[N],p[N];<br>vector&lt;<span class="hljs-type">int</span>&gt;g[N]; <span class="hljs-comment">//存储边集</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    dep[u]=d;<br>    <span class="hljs-type">int</span> size=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)&#123;<br>        <span class="hljs-type">int</span> v=g[u][i];<br>        <span class="hljs-keyword">if</span>(v==p[u]) <span class="hljs-keyword">continue</span>;<br>        p[v]=u;<br>        <span class="hljs-built_in">dfs</span>(v,d+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">while</span>(dep[x]&gt;dep[y]) x=p[x];<br>    <span class="hljs-keyword">while</span>(x!=y)&#123;<br>        x=p[x];<br>        y=p[y];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a].<span class="hljs-built_in">emplace_back</span>(b);<br>        g[b].<span class="hljs-built_in">emplace_back</span>(a);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">lca</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在线倍增算法"><a href="#在线倍增算法" class="headerlink" title="在线倍增算法"></a>在线倍增算法</h4><p><strong>原理</strong>：</p><ul><li>跟朴素求解一样的，我<strong>们也是需要将x和y置于同一深度</strong>，但是我们不再是简单的一个个去上升，而是利用倍增的思想，<strong>每次以2<sup>i</sup>(i∈[0,log2(dep[x]-dep[y])])的递增上升</strong></li><li>同样的<strong>当x和y在同一深度上升时，也是利用倍增的递增上升，每次以2<sup>i</sup>(i∈[0,log2(dep[x])])的跨度递增，直到x和y相等</strong></li><li><code>在线</code>：就是输入数据，就直接通过计算得出结果</li></ul><p><strong>倍增</strong>：倍增就是递增速度是通过2<sup>j</sup>(j&#x3D;0,1,2,..)的速度递增的，<strong>一个倍增数组的元素f[i][j]，表示第i+2<sup>j</sup>的元素</strong></p><blockquote><p><code>至于j为什么最大为log2(n+1)</code></p><p>解答：n为树上节点数，我们<strong>假设最坏情况为从根节点一直到最后一个节点x都是一条线连接</strong>，那<strong>最后一个节点x也必须能够通过倍增访问根节点</strong>，而倍增的速度是通过2<sup>j</sup>(j&#x3D;0,1,2,..)的速度递增的，因此<strong>最大的j就应该保证x+2<sup>j</sup>等于根节点</strong>，因此我们发现<strong>根节点到x中间一共n-1(包括根节点)<strong>，因此</strong>最大的j要保证2<sup>j</sup>&#x3D;n-1</strong>，这样就可以得到最大的<code>j=log2(n)+1</code>了</p></blockquote><p><strong>做法</strong>：</p><ol><li><p>定义一个<code>dep[N]</code>和<code>f[N][log2(n+1)]</code>，分别<strong>用于存储树上节点的深度</strong>、<strong>每个树上节点的父节点</strong>和<strong>存储每个节点i通过2<sup>j</sup>(j&#x3D;0,1,2,..log2(n)+1)的递增到达的节点</strong></p></li><li><p>通过<code>dfs预处理dep和f</code>数组</p><blockquote><p>预处理f数组时，<strong>假设当前节点为u，则将f[u][0]置为p[u]<strong>(上升2的0次方就是上升一个，所以为父节点)，然后</strong>遍历递增倍数i从1到log2(dep[2])<strong>，然后将</strong>利用u的2<sup>i</sup>的祖先等于u的2<sup>i-1</sup>的2<sup>i-1</sup>祖先</strong>，也就是<code>f[u][i]=f[f[u][i-1]][i-1]</code>，得到当前节点u倍增到的各节点</p></blockquote></li><li><p>对于每次查询，判断<strong>dep[x]是否大于dep[y]<strong>，如果</strong>小于，则将x和y交换</strong></p></li><li><p>然后开始通过<code>递增倍数i从log2(dep[x]-dep[y])到0的跨度递增</code>，如果<strong>当前2<sup>i</sup>小于dep[x]-dep[y]<strong>，就<code>让x上升到f[x][i]</code>，</strong>让x与y深度相等</strong></p><blockquote><p><strong>为啥i</strong>从log2(dep[x]-dep[y])到0，而<strong>不是从0开始</strong></p><p>解答：</p><ul><li>这是<code>因为我们从0开始增加的跨度，很可能会使x的深度达不到y</code>，为啥是达不到呢，因为我们需要判<strong>断当前dep[x]-dep[y]是否大于当前2<sup>i</sup><strong>，如果</strong>从0开始就会产生x到dep[x]-dep[y]还有余数，而剩下的i太大，导致无法使用</strong></li><li>至于为啥会有余数，我们可以从<strong>二进制进行证明</strong>，假设dep[x]-dep[y]&#x3D;50，而50的二进制为110010，我们的<strong>i从log2(50)也就是5到0的过程中</strong>，假设当前i为5，2^5转为二进制就为100000，因此就将50中的最高位1消掉，假设当前i为3，此时的50只剩0010，而2^3为1000，0010&lt;1000，所以不减，<strong>按照这种规则(如果2<sup>i</sup>大就不减，小就减)，50最终一定会变为0</strong></li><li><strong>而i从0开始递增，假设当前i&#x3D;0，那相减，二进制就为110001</strong>，因为i是递增的，所以导致<strong>最低位的1一定会留下，就会产生余数</strong>，将这两种方法转换为10进制也是一样道理，<strong>50-32-16-2&#x3D;0，而50-1-2-4-8-16&#x3D;19，而19&lt;32，导致无法继续减，所以可能导致x无法上升到y的高度</strong></li></ul></blockquote></li><li><p><strong>判断x是否等于y</strong>，如果等于，就返回x(<strong>这种情况就是y是x的祖先</strong>)</p></li><li><p>当dep[x]&#x3D;&#x3D;dep[y]时，我们就可以让x和y同时倍增上升，按照步骤4的递增方法递增，当for循环中判断<code>f[x][i]!=f[y][i]</code>，如果<strong>不相等就让x和y一起上升到f[x][i]和f[y][i]<strong>，直到i&#x3D;0时，根据4的性质证明，</strong>发现最后f[x][0]都会等于f[y][0]，所以i&#x3D;0时，无法x和y无法上升</strong>，所以<code>最后返回f[x][0]</code></p></li></ol><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n,m,s,a,b;  <span class="hljs-comment">//n为节点数，m为查询次数，s为根节点编号,a和b用于临时存储节点的临时变量</span><br><span class="hljs-type">int</span> dep[N],f[N][<span class="hljs-number">22</span>]; <span class="hljs-comment">//log2(N)算出来19，可以创建大于19的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt;g[N]; <span class="hljs-comment">//存储边集</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    dep[u]=d;<br>    f[u][<span class="hljs-number">0</span>]=p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">log2</span>(dep[u]);++i)&#123;<br>        f[u][i]=f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> size=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)&#123;<br>        <span class="hljs-type">int</span> v=g[u][i];<br>        <span class="hljs-keyword">if</span>(v==p) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v,u,d+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]-dep[y]);i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[x]-dep[y]) x=f[x][i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">log2</span>(dep[x]);i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>        <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i])&#123;<br>            x=f[x][i];<br>            y=f[y][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        g[a].<span class="hljs-built_in">emplace_back</span>(b);<br>        g[b].<span class="hljs-built_in">emplace_back</span>(a);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(s,s,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">lca</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划-dp"><a href="#动态规划-dp" class="headerlink" title="动态规划(dp)"></a>动态规划(dp)</h3><p><strong>概念</strong>：</p><ul><li>将<strong>递归算法重新写成非递归算法</strong>，让后者把<strong>那些子问题的答案系统地记录在一个表(dp数组)内</strong>，这种方法叫做<strong>动态规划</strong></li><li>通常用于<strong>求解具有最优性质的问题</strong>(最优子结构&amp;最优子问题)，希望找到具有最优值的解。</li><li>核心为穷举，动态规划问题往往具有最优子结构，重叠子问题和状态转移方程的特征。</li></ul><p><strong>基本思想</strong>：</p><ul><li><strong>适用于子问题不是独立的情况</strong>，也就是各子问题包含公共的子问题，鉴于会重复的求解各个子问题，对每个问题只求一遍，将其保存在一张表中，从而避免重复计算。</li></ul><p><strong>特征</strong>：</p><ul><li><p><strong>最优子结构</strong>：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p></li><li><p><strong>重叠子问题</strong>：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法利用这个子问题重叠性质，对每一个问题只解一次，而后将其解保存在一个表格(dp数组)中，在以后尽可能多地利用这些子问题的解。</p></li><li><p>**状态转移方程(最关键)**：</p><blockquote><ol><li>是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。如果给定了第K阶段的状态S<strong>k</strong>以及决策u<strong>k</strong>(S<strong>k</strong>)，则第K+1阶段的状态S<strong>k+1</strong>也就完全确定</li><li>也就是<strong>递推方程，一个状态的解往往可以由前一个状态的解得出</strong></li><li>状态是由自己定义的通常可以认为<strong>是函数参数，dp数组的索引</strong>。</li><li><strong>状态转移</strong>就是<strong>从一个状态变成另一个状态</strong>，就例如本质为斐波那契数列的爬楼梯问题，从N-1阶或N-2的楼梯上到N阶的楼梯就称为状态转移.</li><li><strong>状态压缩</strong>：<strong>有时候并不需要保存所有状态</strong>，当<strong>保存的状态减少，导致算法的空间复杂度降低的技巧</strong>叫做状态压缩</li></ol></blockquote></li></ul><p><strong>能解决的问题</strong>：</p><ol><li>计数</li><li>最值</li><li>存在性(是和否的问题，例如01背包)</li></ol><p><strong>解题步骤</strong>：</p><ul><li><strong>明确状态</strong>：<code>也就是原问题和子问题中会变化的变量,状态的种数决定dp数组的维度</code>。根据题意定义状态，这个状态可能是求解题目会变化的量，因为动态规划本质就是穷举，所以这个状态应该是穷举所有方案能够找到求解的目标</li><li><strong>明确选择</strong>：<code>也就是导致状态产生变化的行为</code>。选择就是限制，当我们需要求解问题时，就需要不断地更新选择限制中的数据，来不断地产生多个方案，从而从中找到最优方案。</li><li><strong>明确dp函数&#x2F;数组的定义</strong>：就是求解的问题的函数，这个函数要求什么</li><li><strong>base case</strong>：初始状态，根据题意找到初始状态，然后写出状态转移方程然后写出自顶向下或者自底向上递推的解法</li></ul><p><strong>分析问题</strong>：</p><ul><li>先分析问题，用备忘录消除重叠子问题，写出自顶向下解法</li><li>进一步，可以写出自底向上解法</li><li>再进一步，可能可以优化空间复杂度</li></ul><p><strong>动态规划框架</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化 base case</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...]=base;<br><span class="hljs-comment">//进行状态转移</span><br><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...]=求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2</span>，...);<br></code></pre></td></tr></table></figure><p>例子：</p><p><strong>零钱兑换问题</strong>：</p><p>分析问题：</p><ul><li>设F(n)为求解凑出目标金额为n的最少硬币数，通过分析问题，求解目标金额为n的最小硬币数F(n)&#x3D;min(F(n-coin1),F(n-coin2)….)，当coins&#x3D;[1,2,5]，目标金额为11时，则F(11)&#x3D;min(F(11-1)，F(11-2),F(11-5))，然后依次递推下去，这样就形成了自顶向下的求法，但是会有重复计算，因此需要使用备忘录也就是记忆性递归来剪枝进行优化</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529594.png" alt="image"></p><ul><li><em>自顶向下解法</em>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//因为这是自顶向下递推，初始化则只需要初始化为达不到的值就行了</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; coins,<span class="hljs-type">int</span> amount)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(amount==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(amount&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(v[amount]!=<span class="hljs-number">-2</span>) <span class="hljs-keyword">return</span> v[amount];<br>        <span class="hljs-type">int</span> res=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin:coins)&#123;<br>            <span class="hljs-type">int</span> sub=<span class="hljs-built_in">dp</span>(coins,amount-coin);<br>            <span class="hljs-keyword">if</span>(sub==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            res=<span class="hljs-built_in">min</span>(res,sub+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//存到备忘录中</span><br>        v[amount]=(res==INT_MAX)?<span class="hljs-number">-1</span>:res;<br>        <span class="hljs-keyword">return</span> v[amount];<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        v.<span class="hljs-built_in">assign</span>(amount+<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(coins,amount);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><em>自底向上解法</em>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//状态：目标金额 amount 因为每选择一枚硬币就会导致amount数值减少</span><br>    <span class="hljs-comment">//选择：coins数组，包含着硬币面额，选择不同面额的硬币就会导致amount的不同，凑出amount的方案也不同</span><br>    <span class="hljs-comment">//函数定义：coinChange函数，对于目标金额amount，至少需要coinChange(coins,amount)枚硬币</span><br>    <span class="hljs-comment">//base case：当amount=0时，则最少需要0个硬币，当amount&lt;0，则无法凑出目标金额</span><br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//目标金额所用最多硬币数为amount，因为是求解最小硬币数问题,所以应该初始化比amount还大</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(amount+<span class="hljs-number">1</span>,amount+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//枚举所有状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;amount+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:coins)&#123;<br>                <span class="hljs-comment">//判断当前amount是否小于选择的面额，如果小于就跳过</span><br>                <span class="hljs-keyword">if</span>(i-j&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//状态转移，求出凑出当前面额i的最小硬币数</span><br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (dp[amount]&gt;=amount+<span class="hljs-number">1</span>)?<span class="hljs-number">-1</span>:dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>01背包问题</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529595.png" alt="image"></strong></p><ul><li>经典的动态规划题目，01背包的01就对应着我是否将当前物品放入背包中，由题意可知，我们只需要求解dp[N] [W]就可以得到答案，分析题目对于选择i物品时，当前背包剩余重量为w时，我们将物品i放入背包则dp[i] [w]&#x3D;dp[i-1] [w-wt[i-1]]+val[i-1]，我们不将物品i放入背包则dp[i] [w]&#x3D;dp[i-1] [w]，因此我们取其最大值就可以求出对于前i个物品，当背包容量为w时，可以装的最大价值，因此状态转移方程为max(dp[i-1] [w],dp[i-1] [w-wt[i-1]]+val[i-1]);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//状态：背包的空余容量剩多少，可选择的物品还有哪些</span><br><span class="hljs-comment">//选择：把这个物品是否放进背包</span><br><span class="hljs-comment">//dp[i][w]定义，对于前i个物品，当背包的容量为w时，可以装的最大价值是dp[i][w]</span><br><span class="hljs-comment">//base case:dp[0][...]=dp[...][0]=0,因为当选择物品为0的时候无论w多少都为0，当背包容量为0时，无论物品多少都无法放进</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,W;<br>    cin&gt;&gt;N&gt;&gt;W;<br>    <span class="hljs-type">int</span> val[N],wt[N];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        cin&gt;&gt;val[N]&gt;&gt;wt[N];<br>    &#125;<br>    <span class="hljs-type">int</span> dp[N+<span class="hljs-number">1</span>][W+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*((N+<span class="hljs-number">1</span>)*(W+<span class="hljs-number">1</span>)));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=W;w&gt;=wt[i<span class="hljs-number">-1</span>];w--)&#123;<br>            dp[i][w]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][w],dp[i<span class="hljs-number">-1</span>][w-wt[i<span class="hljs-number">-1</span>]]+val[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[N][W];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>完全背包问题</strong>：</p><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 v<sub>i</sub>，价值是 w<sub>i</sub>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>二维dp</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N],dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;++j)&#123;<br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j-v[i]&gt;=<span class="hljs-number">0</span>) dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i][j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态压缩</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N],dp[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;=m;++j)&#123;<br>            dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p><strong>概念</strong>：</p><ul><li>记忆化搜索就是深度优先搜索的一种优化策略，<code>记忆化搜索=深度优先搜索形式+动态规划思想</code></li><li>由于dfs本质是暴力搜索，没有很好地处理重叠子问题，因此很低效</li><li>记忆化算法在求解地时候还是按照自顶向下的顺序，<strong>但是每求解一个状态，就将它的解保存下来</strong></li><li><strong>求解最优解问题</strong></li></ul><p><strong>优点</strong>：</p><ul><li><strong>解决了深度优先搜索中的重叠子问题要多次遍历的问题</strong></li><li>搜索还可以剪枝，可能剪去大量不必要的状态</li></ul><p><strong>缺点</strong>：</p><ul><li>对于同样的问题，如果用动态规划解决而是用了记忆化搜索会使得效率有所降低</li></ul><p><strong>dfs函数组成</strong>：</p><ol><li>得有搜索边界即结束条件，以及处理</li><li>对当前状态的检查，如果结果已经记录，则直接返回返回</li><li>从当前状态到下一个状态的转移，当前状态最优解的记录</li><li>对结果的返回</li><li>核心点：状态转移方程的确定。dp[state]&#x3D;optimal(dp[state],dfs(next state)+cost);</li></ol><p><strong>代码模板</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//type为类型，state为状态，在图论中一般都是横竖坐标</span><br><span class="hljs-function">type <span class="hljs-title">dfs</span><span class="hljs-params">(state)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(结束条件)&#123;<br>        处理;<br>        <span class="hljs-keyword">return</span> type; <span class="hljs-comment">//返回对应类型的值</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(当前状态的解已被记录) <span class="hljs-keyword">return</span> dp[state];<br>    <span class="hljs-comment">//跟动态规划一样或者说跟dfs一样遍历下一个状态</span><br>    <span class="hljs-keyword">for</span> each next state&#123;<br>        <span class="hljs-keyword">if</span>(检查当前状态是否符合约束条件)&#123;<br>            dp[state]=<span class="hljs-built_in">optimal</span>(dp[state],<span class="hljs-built_in">dfs</span>(next state)+cost);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[state];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题代码实现</strong>：</p><ul><li><p>蓝桥杯题：<code>滑行</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529596.png" alt="image"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> mp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>], n, m,dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dp[x][y]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[x][y];<br>    dp[x][y]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)&#123;<br>        <span class="hljs-type">int</span> px=x+dx[i];<br>        <span class="hljs-type">int</span> py=y+dy[i];<br>        <span class="hljs-keyword">if</span>(px&gt;=<span class="hljs-number">0</span>&amp;&amp;py&gt;=<span class="hljs-number">0</span>&amp;&amp;px&lt;n&amp;&amp;py&lt;m&amp;&amp;mp[px][py]&lt;mp[x][y])&#123;<br>            dp[x][y]=<span class="hljs-built_in">max</span>(dp[x][y],<span class="hljs-built_in">dfs</span>(px,py)+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>            cin&gt;&gt;mp[i][j];<br>            dp[i][j]=<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>            cnt=<span class="hljs-built_in">max</span>(cnt,<span class="hljs-built_in">dfs</span>(i,j));<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p><strong>概念</strong>：</p><ul><li><code>数位dp</code>是一种计数用的dp，一般是要<strong>统计一个区级[l,r]内满足一些条件的数的个数</strong></li><li>所谓数位dp，就是<strong>对数位进行dp，也就是个位、十位等</strong></li><li>相对于普通的<a href="https://so.csdn.net/so/search?q=%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020">暴力枚举</a>，数位dp快就快在它的记忆化，也就是说后面可能会利用到前面已经计算好的东西</li><li>题型往往是：<strong>给定一个闭区间[L,R]，求这个区间中满足”某种条件”的数的总数量</strong></li></ul><p><strong>题型特征</strong>：</p><ol><li>要求统计满足一定条件的数的数量（即，<strong>最终目的为计数</strong>）；</li><li>这些条件经过转化后<strong>可以使用「数位」的思想去理解和判断</strong>；</li><li>输入<strong>会提供一个数字区间</strong>（有时也只提供上界）来作为统计的限制；</li><li><strong>上界很大（比如10<sup>18</sup>），暴力枚举验证会超时</strong>。</li></ol><blockquote><p>总结：<strong>给定一个闭区间[L,R]，求这个区间中满足”某种条件”的数的总数量</strong></p></blockquote><p><strong>基本原理</strong>：</p><p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，<strong>这样的过程中有许多重复的部分</strong>。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以<strong>我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</strong>，而我们的统计就是由记忆化搜索解决</p><p><strong>具体实现</strong>：</p><ul><li><p>数位dp首先通常<strong>把统计[L,R]范围内满足条件的数字转化为统计[1,N]内满足条件的数字数量</strong>，这样就将下界限制去掉,只考虑上边界。就变成：<code>Ans[L,R]=Ans[1,R]-Ans[1,L-1]</code></p></li><li><p><strong>将数字大小转换为数位字典序，也就是记录最大枚举到的数字每一位的数值</strong>(例如R为123456，那word[1]&#x3D;6,word[2]&#x3D;5依次类推)。我们称这个数组为<code>word[n+1]</code></p></li><li><p>DFS要记录的状态:</p><blockquote><ol><li>现在枚举到哪一位，记为<code>pos</code></li><li>前面一位的数字是多少，记为<code>pre</code></li><li>这一位可以填的最大数字，记为<code>up</code>，但是求解过程我们会以<code>flag</code>来<strong>表示是否需要更新up</strong></li></ol></blockquote></li><li><p>我们<strong>开始从最高位到最低位枚举</strong>，对于当前位置x有两种填补可能性：</p><blockquote><ol><li>如果<code>x前面某一位已经小于对应位置的上限数字</code>，则这一位可以<code>填0-9</code></li><li>如果<code>x前面每一位都等于对应位置的上限数字</code>，这一位<code>可填数字范围为0-x对应位置的上限数字</code></li></ol><p>所以，我们只需要维护前面每一位数字是否和上限数字一样，就可以得到这个位置数字可填范围</p></blockquote></li><li><p>如果<code>flag为false</code>，那么dfs计算的过程就和up毫无关系，那么我们可以考虑<strong>把这个状态答案记录下来</strong>，用于后面复用</p></li></ul><p><strong>模板</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//pos为当前位数</span><br><span class="hljs-comment">//pre代表前一位所填数字</span><br><span class="hljs-comment">//flag代表前面每一位数字是否都等于对应的上限数字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> pre,<span class="hljs-type">bool</span> flag)</span></span>&#123;<br>    <span class="hljs-comment">//如果pos&lt;=0表示枚举完每一位，那返回对应要返回的值</span><br>    <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> 需要返回值;<br>    <span class="hljs-comment">//如果该状态已经计算过了就返回</span><br>    <span class="hljs-keyword">if</span>(!flag&amp;&amp;dp[pos][pre]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][pre];<br>    <span class="hljs-comment">//如果flag为true，up就为对应的上限数字，反之就为9</span><br>    <span class="hljs-type">int</span> up=flag?word[pos]:<span class="hljs-number">9</span>;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">//计数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;++i)&#123;<br>        <span class="hljs-keyword">if</span>(判断数位是否满足条件) cnt+=<span class="hljs-built_in">dfs</span>(pos<span class="hljs-number">-1</span>,i,flag&amp;&amp;(i==up)); <span class="hljs-comment">//如果满足就继续搜索</span><br>    &#125;<br>    <span class="hljs-comment">//记录状态</span><br>    <span class="hljs-keyword">if</span>(!flag) dp[pos][pre]=cnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><ol><li><p><code>Windy数</code>：定义<strong>不含前导0</strong>且相邻两个数字之差至少为2的正整数被称为windy数，比如5，36，192都是windy数，10，21不是windy数，求[L,R]范围内有多少个Windy数，1&lt;&#x3D;L,R&lt;&#x3D;1e18;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll word[<span class="hljs-number">20</span>];<br>ll dp[<span class="hljs-number">30</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-comment">//lead是用来判断前面一位是否为0</span><br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(ll pos,ll pre,<span class="hljs-type">bool</span> flag,<span class="hljs-type">bool</span> lead)</span></span>&#123;<br>   <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//因为不含前导0，所以pre要大于0</span><br>   <span class="hljs-keyword">if</span>(!flag&amp;&amp;pre&gt;<span class="hljs-number">0</span>&amp;&amp;dp[pos][pre]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][pre];<br>   <span class="hljs-type">int</span> up=flag?word[pos]:<span class="hljs-number">9</span>;<br>   ll cnt=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;++i)&#123;<br>       <span class="hljs-comment">//因为要求不含前导0，所以当前面一位为0，说明这一位就为数的开始，所以算是符合条件</span><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(i-pre)&gt;=<span class="hljs-number">2</span>||lead) cnt+=<span class="hljs-built_in">dfs</span>(pos<span class="hljs-number">-1</span>,i,flah&amp;&amp;(i==up),lead&amp;&amp;(i==<span class="hljs-number">0</span>));<br>   &#125;<br>   <span class="hljs-keyword">if</span>(!flag) dp[pos][pre]=cnt;<br>   <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span>&#123;<br>    <span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        word[++pos]=x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(pos,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b) cout&lt;&lt;<span class="hljs-built_in">solve</span>(b)-<span class="hljs-built_in">solve</span>(a<span class="hljs-number">-1</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>统计整数数目</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529597.png" alt="image"></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> min_sum,max_sum;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">23</span>][<span class="hljs-number">401</span>];<br>    <span class="hljs-type">char</span> word[<span class="hljs-number">25</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> sum,<span class="hljs-type">bool</span> flag)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sum&gt;=min_sum;<br>        <span class="hljs-keyword">if</span>(!flag&amp;&amp;dp[pos][sum]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][sum];<br>        <span class="hljs-type">int</span> up=flag?word[pos]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;++i)&#123;<br>            <span class="hljs-keyword">if</span>(sum+i&lt;=max_sum) res=(res+<span class="hljs-built_in">dfs</span>(pos<span class="hljs-number">-1</span>,sum+i,flag&amp;&amp;(i==up)))%mod;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) dp[pos][sum]=res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string x)</span></span>&#123;<br>        <span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) word[++pos]=x[i];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(pos,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(string num1, string num2, <span class="hljs-type">int</span> min_sum, <span class="hljs-type">int</span> max_sum)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=num1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(num1[n]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            num1[n]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>            n--;<br>        &#125;<br>        num1[n]--;<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dp);<br>        <span class="hljs-keyword">this</span>-&gt;min_sum=min_sum;<br>        <span class="hljs-keyword">this</span>-&gt;max_sum=max_sum;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">solve</span>(num2)-<span class="hljs-built_in">solve</span>(num1)+mod)%mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><p><strong>概念</strong>：</p><ul><li>ST表<strong>适用于解决区间最值的问题(RMQ问题)的数据结构</strong></li><li>ST表<strong>本质是dp算法</strong>，只不过dp是对数组一排一排更新，而RMQ是对数组一列一列动态规划的</li><li><strong>预处理</strong>时间复杂度为<code>O(nlogn)</code>，<strong>查询</strong>时间复杂度为<code>O(1)</code></li></ul><p><strong>操作</strong>：</p><p>例题：给一个数组，有n个数，有m个left，right(left和right为区间边界)，求出这m个区间的最值</p><ol><li>首先引入状态f[i][j]，<strong>f[i][j]表示从第i个元素开始的长度为2<sup>j</sup>个元素的最值</strong></li><li>将第i个元素开始的2<sup>j</sup>个元素<strong>分成长度相等的两部分，每部分的长度为2<sup>j-1</sup></strong></li><li><code>状态转移方程</code>就为：**f[i][j]&#x3D;max(f[i][j-1]，f[i+2<sup>j-1</sup>][j-1])**，即两部分的最大值</li><li><code>边界条件</code>：<strong>f[i][0]&#x3D;a[i]</strong></li><li>要询问区间[L,R]的最大值，因区间[L,R]的长度为R-L+1，<strong>求出log<sub>2</sub>(R-L+1)的值，设为x</strong></li><li>因此区间[L,R]就可以分为[L,L+2<sup>x</sup>-1]和[R-2<sup>x</sup>+1,R]两个部分，根据状态转移方程可以得出<code>区间[L,R]的最大值</code>：<strong>RMQ(L,R)&#x3D;max(f[L][x],f[R-2<sup>x</sup>+1][x])</strong></li><li><strong>2<sup>x</sup>可以用移位运算1&lt;&lt;x提高效率</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)<span class="hljs-built_in">log</span>(r-l+<span class="hljs-number">1</span>)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">//在c++中log默认为以10为底，所以需要换底</span><br>    <span class="hljs-comment">//或者直接使用log2函数</span><br>    <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[l][x],f[r-(<span class="hljs-number">1</span>&lt;&lt;x)+<span class="hljs-number">1</span>][x]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//例子</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">20</span>];  <span class="hljs-comment">//20是由log2(n)+1算出来的</span><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-comment">//    int x=(int)log(r-l+1)/log(2);</span><br>    <span class="hljs-type">int</span> x=(<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[l][x],f[r-(<span class="hljs-number">1</span>&lt;&lt;x)+<span class="hljs-number">1</span>][x]);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-type">int</span> p;<br>        cin&gt;&gt;p;<br>        f[i][<span class="hljs-number">0</span>]=p;<br>    &#125;<br>    <span class="hljs-comment">//外层循环是遍历列,列不需要遍历到n，而是2的j次方小于等于n</span><br>    <span class="hljs-comment">// 因为f[i][j]代表的是从i开始的2的j次方个元素的最值，因此j最大只能取到log2(n)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;++j)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;++i)&#123;<br>            f[i][j]=<span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        cout&lt;&lt;<span class="hljs-built_in">query</span>(x,y)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>例题</strong>：</p><p>蓝桥杯2415：附近最小</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529598.png" alt="image"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-type">int</span> n, k;<br><br><span class="hljs-comment">//ST算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;f)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>)<span class="hljs-built_in">log2</span>(r - l + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f[l][x], f[r - (<span class="hljs-number">1</span> &lt;&lt; x) + <span class="hljs-number">1</span>][x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n ;<br>    <span class="hljs-type">int</span> logn = <span class="hljs-built_in">log2</span>(n) + <span class="hljs-number">1</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(logn));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        cin &gt;&gt; f[i][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; ++i) &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    cin &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, i - k);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">min</span>(n, i + k);<br>        cout &lt;&lt; <span class="hljs-built_in">query</span>(l, r, f) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><strong>概念</strong>：</p><ul><li>单调栈是一种数据结构，但是因为经常使用就将其放入算法</li><li>单调栈就是<strong>栈内的元素呈单调递增或者单调递减的(一般指栈顶到栈底)</strong></li><li>将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈<strong>满足单调性的前提下弹出最少的元素</strong>。</li><li>例如：例如，单调递增栈中自顶向下的元素为{0,11,45,81}，插入元素14时为了保持单调性需要依次弹出0、11，操作后栈变为{14,45,81}</li><li>时间复杂度为<code>O(n)</code></li></ul><p><strong>适用场景</strong>：</p><ul><li><p>单调栈可以<strong>求解出某个元素左边或者右边第一个比它大或者小的元素</strong></p></li><li><p>可以将其分为具体四种问题：</p><blockquote><ol><li>寻找左侧第一个比当前元素大的元素</li><li>寻找左侧第一个比当前元素小的元素</li><li>寻找右侧第一个比当前元素大的元素</li><li>寻找右侧第一个比当前元素小的元素</li></ol></blockquote></li></ul><p><strong>各问题解决做法</strong>：</p><p><code>总结</code>：</p><ul><li>查找<strong>比当前大的元素用单调递增栈</strong>，查找<strong>比当前小的元素用单调递减栈</strong></li><li>从<strong>左侧</strong>查找就<strong>看插入栈时的栈顶元素</strong>，从<strong>右侧</strong>查找就<strong>看弹出栈时即将插入的元素</strong></li></ul><ol><li><p><code>寻找左侧第一个比当前元素大的元素</code>：</p><blockquote><ul><li>构造一个<strong>单调递增栈(从栈顶到栈底)</strong></li><li><strong>从左到右遍历元素</strong></li><li>如果<strong>当前元素大于栈顶元素</strong>，则将其<strong>加入</strong>(也就是将栈里面小于当前元素的都弹出再插入)；</li><li>如果<strong>小于</strong>，则<strong>当前栈顶元素就是当前遍历的元素左侧第一个比它大的元素</strong></li><li>如果插入时的<strong>栈为空</strong>，则<strong>说明左侧不存在比当前元素大的元素</strong></li></ul></blockquote></li><li><p><code>寻找左侧第一个比当前元素小的元素</code>：</p><blockquote><ul><li>构造一个<strong>单调递减栈(从栈顶到栈底)</strong></li><li><strong>从左到右遍历元素</strong></li><li>如果当前元素<strong>小于</strong>栈顶元素，就<strong>加入</strong>栈中</li><li>如果<strong>大于</strong>，则<strong>当前栈顶元素就是当前遍历元素左侧第一个比它小的元素</strong></li><li>如果插入时的<strong>栈为空</strong>，则<strong>说明左侧不存在比当前元素小的元素</strong></li></ul></blockquote></li><li><p><code>寻找右侧第一比当前元素大的元素</code>：</p><blockquote><ul><li>构造一个<strong>单调递增栈(从栈顶到栈底)</strong></li><li><strong>从左到右遍历元素</strong></li><li>如果<strong>当前遍历元素大于当前栈底元素</strong>，则<strong>当前栈顶元素的右侧第一个比它大的元素就是当前遍历元素</strong></li><li>如果<strong>小于</strong>，则将其<strong>加入</strong>栈中</li><li>如果在<strong>栈中的元素没有被弹出</strong>，说明栈中<strong>剩下的元素没有右侧比它大的元素</strong></li></ul></blockquote></li><li><p><code>寻找右侧第一个比当前元素小的元素</code>：</p><blockquote><ul><li>构造一个<strong>单调递减栈(从栈顶到栈底)</strong></li><li><strong>从左到右遍历元素</strong></li><li>如果<strong>当前遍历元素小于当前栈顶元素</strong>，则<strong>当前栈顶元素的右侧第一个比它小的元素就是当前遍历元素</strong></li><li>如果<strong>大于</strong>，则<strong>加入</strong>栈中</li><li>如果在<strong>栈中的元素没有被弹出</strong>，说明栈中<strong>剩下的元素没有右侧比它小的元素</strong></li></ul></blockquote></li></ol><p><strong>模板代码</strong>：</p><ol><li><p><code>单调递增栈</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[i]&gt;nums[st.<span class="hljs-built_in">top</span>()])&#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>单调递减栈</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[i]&lt;nums[st.<span class="hljs-built_in">top</span>()])&#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>概念</strong>：</p><ul><li><p>滑动窗口算法是由双指针来维护窗口进行滑动的算法</p></li><li><p>该算法适用于求解包含以下关键词的问题：</p><blockquote><ol><li>满足xxx条件(计算结果，出现次数，同时包含)</li><li>最长&#x2F;最短</li><li>子串&#x2F;子数组&#x2F;子序列</li></ol></blockquote></li></ul><p>**使用思路(寻找最长)**：</p><ul><li><p><code>核心</code>：左右双指针(L,R)在起始点，R向右逐位滑动循环</p></li><li><p>每次滑动过程中：</p><blockquote><ol><li>如果<strong>窗内元素满足条件</strong>，<code>R向右扩大窗口</code>，并<strong>更新最优结果</strong></li><li>如果窗内元素<strong>不满足条件</strong>，<code>L向右缩小窗口</code></li></ol></blockquote></li><li><p>直到R到达结尾结束</p></li><li><p><strong>代码模板</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始化：左指针l,右指针r,当前结果res,最优结果<span class="hljs-function">bestres</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(右指针没有到结尾)</span></span>&#123;<br>    窗口扩大，加入r对应的元素，更新当前res;<br>    <span class="hljs-keyword">while</span>(res不满足条件)&#123;<br>        窗口缩小，移除l对应的元素，l右移;<br>    &#125;<br>    更新最优结果bestres;<br>    r++;<br>&#125;<br></code></pre></td></tr></table></figure><p>**使用思路(寻找最短)**：</p><ul><li><p><code>核心</code>：左右双指针(L,R)在起始点，R向右逐位滑动循环</p></li><li><p>每次滑动过程中：</p><blockquote><ol><li>如果窗内<strong>元素满足条件</strong>，<code>L向右缩小窗口</code>，并<strong>更新最优结果</strong></li><li>如果窗内元素<strong>不满足条件</strong>，<code>R向右扩大窗口</code></li></ol></blockquote></li><li><p>直到R到达结尾结束</p></li><li><p><strong>代码模板</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始化：左指针l,右指针r,当前结果res,最优结果<span class="hljs-function">bestres</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(右指针没有到结尾)</span></span>&#123;<br>    窗口扩大，加入r对应的元素，更新当前res;<br>    <span class="hljs-keyword">while</span>(res满足条件)&#123;<br>        更新最优结果bestres;<br>        窗口缩小，移除l对应的元素，l右移;<br>    &#125;<br>    r++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p><strong>概念</strong>:</p><ul><li><p><strong>回溯算法</strong>是一种<strong>进行选择搜索然后再回退到选择点选择其他路径然后形成一个决策树的算法</strong>，例如在一个空间摆放家具就需要进行选择不同的家具然后看效果，如果选择其中一个家具的效果不好，则就回退到选择点选择除选择过以外的家具，如果客户认可就沿着这个路径继续搜索，然后达到一个穷举的效果。</p></li><li><p>回溯算法<strong>一般用于求解所有可行性解问题，例如全排列，N皇后等问题</strong></p></li><li><p>回溯算法相当于穷举搜索的巧妙实现，但是<strong>性能一般不理想，但是可以通过剪枝来提升性能</strong></p></li><li><p>回溯算法也是一种<strong>暴力穷举算法</strong>，穷举的过程就是<strong>遍历一颗多叉树</strong>的过程</p></li></ul><p><strong>求解问题</strong>：</p><ul><li>用于<strong>求解所有可行性解</strong>的算法(例如全排列，组合，子集问题)</li></ul><p><strong>回溯算法框架</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">List&lt;value&gt; result;  <span class="hljs-comment">//用于存求解答案</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径,选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(满足结束条件)&#123;<br>        result.<span class="hljs-built_in">add</span>(路径);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(选择:选择列表)&#123;<br>        做选择;<br>        <span class="hljs-built_in">backtrack</span>(路径,选择列表);<br>        撤销选择;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题</strong>：</p><p><code>全排列</code>：给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;res;   <span class="hljs-comment">//存储结果</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;track;<br>        <span class="hljs-built_in">backtrack</span>(nums,track);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//回溯算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums,vector&lt;<span class="hljs-type">int</span>&gt;track)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(track.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>        res.<span class="hljs-built_in">push_back</span>(track);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>        <span class="hljs-comment">//避免重复选择</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(track.<span class="hljs-built_in">begin</span>(),track.<span class="hljs-built_in">end</span>(),num)!=track.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//做选择</span><br>        track.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-built_in">backtrack</span>(nums,track);<br>        <span class="hljs-comment">//撤销选择</span><br>        track.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>N皇后</code>：</p><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;string&gt;&gt;res;<br><br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//初始化棋局</span><br>        vector&lt;string&gt;<span class="hljs-built_in">track</span>(n,<span class="hljs-built_in">string</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-comment">//每行每行放置皇后</span><br>        <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>,track,n);<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;string&gt; track,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//因为我们是每行每行的放置，因此当前行数一下都没有放置皇后所以扫描当前行数以上的就行了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>        <span class="hljs-keyword">if</span>(track[i][col]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//同理扫描当前位置斜上方有没有放置皇后就行了(左上，右上)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row,j=col;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>;i--,j--)&#123;<br>        <span class="hljs-keyword">if</span>(track[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row,j=col;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;=n;i--,j++)&#123;<br>        <span class="hljs-keyword">if</span>(track[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> row,vector&lt;string&gt;&amp; track,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(track.<span class="hljs-built_in">size</span>()==row)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(track);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;col&lt;n;col++)&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(track,row,col,n)) <span class="hljs-keyword">continue</span>;<br>        track[row][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-built_in">backtrack</span>(row+<span class="hljs-number">1</span>,track,n);<br>        track[row][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p><strong>概念</strong>：</p><ul><li>抽象数据类型(abstract data type,ADT)是一些操作的集合。抽象数据类型是数学的抽象，只是描述ADT有啥功能，但是在ADT定义中根本没涉及到如何实现功能，这可以看作是模块化设计的补充，对于诸如表，集合、图和他们的操作一起看作是抽象数据类型，就像整数、实数和布尔量是数据类型一样.例如集合ADT，我们可以有诸如并、交、测定大小以及取余等操作。</li></ul><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><strong>定义</strong>：</p><ul><li>我们将处理一般的形如A1,A2,A3….AN的表成为<strong>线性表</strong>，N为表的大小，我们称N&#x3D;0的表为空表。对于除空表外的任何表，我们说A<sub>i+1</sub>后继A<sub>i</sub>并称A<sub>i-1</sub>前驱A<sub>i</sub>,表中的第一个元素为A<sub>1</sub>,而最后一个元素为A<sub>N</sub>.</li></ul><h4 id="简单数组实现表"><a href="#简单数组实现表" class="headerlink" title="简单数组实现表"></a>简单数组实现表</h4><p><strong>概念</strong>：</p><ul><li>表的实现可以通过数组进行实现，而表的插入和删除，就需要对数组元素进行移动，例如插入，如果向第一个位置插入，我们就需要数组元素都向后移动一位，又如删除第一个元素，就需要将第一个元素删掉，数组元素再向前移动一位。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h?&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 100</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>&#123;</span><br>    <span class="hljs-type">int</span> elements[SIZE];<br>    <span class="hljs-type">int</span> len;  <span class="hljs-comment">//表中元素的长度(即个数)</span><br>&#125;;<br><br><span class="hljs-comment">//创建一个空表对象</span><br><span class="hljs-keyword">struct</span> List* <span class="hljs-title function_">createList</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span> *<span class="hljs-title">p</span>;</span><br>    p=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> List));<br>    p-&gt;len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//判断表是否为空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List* p)</span>&#123;<br>    <span class="hljs-keyword">return</span> p-&gt;len==<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//头插法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inserthead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List *p,<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;len&gt;=SIZE)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表已满&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p-&gt;len;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        p-&gt;elements[i]=p-&gt;elements[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    p-&gt;elements[<span class="hljs-number">0</span>]=x;<br>    p-&gt;len++;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertlast</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List*p,<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;len&gt;=SIZE)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表已满&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    p-&gt;elements[p-&gt;len]=x;<br>    p-&gt;len++;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//打印表中数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List *p)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p-&gt;len;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;list element is:%d\n&quot;</span>,p-&gt;elements[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//查找指定值，返回索引</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List *p,<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p-&gt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;elements[i]==x)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没有找到值为%d的数据\n&quot;</span>,x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//查找表中对应索引的值，返回值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findkth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List *p,<span class="hljs-type">int</span> pos)</span>&#123;<br>    <span class="hljs-keyword">if</span>(pos&gt;p-&gt;len)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不存在索引为%d的数据\n&quot;</span>,pos);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p-&gt;elements[pos];<br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> List *p,<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p-&gt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;elements[i]==x)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;p-&gt;len<span class="hljs-number">-1</span>;j--)&#123;<br>                p-&gt;elements[j]=p-&gt;elements[j+<span class="hljs-number">1</span>];<br>            &#125;<br>            p-&gt;len--;<br>           <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><strong>与简单数组实现的优缺点</strong>：</p><ul><li><strong>优点</strong>：简单数组实现表的插入和删除需要花费大量的时间，尤其当数据量大的时候，则程序的耗时将会难以接受，因此为了避免插入和删除的线性开销，我们需要允许表可以不连续存储，否咋表的部分或全部需要整体移动，因此我们将用<strong>链表</strong>进行实现</li><li><strong>缺点</strong>：在查找数据的时候，链表所耗的时长更多，因为数组可以直接用索引来获取，但是链表需要遍历表连接的数据，直到找到数据为止。</li></ul><p><strong>概念</strong>：</p><ul><li><strong>链表</strong>由一系列<strong>不必在内存相连的结构</strong>组成，每一个结构均含有表元素和指向包含该元素后继元的结构的指针，我们称之为<em>Next指针</em>。最后一个单元的Next指针指向NULL，NULL是在c中的定义，c中规定为0.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> Node *<span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>=</span>(<span class="hljs-keyword">struct</span> Node* )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>    p-&gt;data=data;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//头插法</span><br><span class="hljs-keyword">struct</span> Node *<span class="hljs-title function_">inserthead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node *head, <span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">add</span> =</span> createNode(data);<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> add;<br>&#125;<br><span class="hljs-comment">//struct Node *p = head;</span><br><span class="hljs-comment">//head = add;</span><br><span class="hljs-comment">//head-&gt;next = p;</span><br><span class="hljs-comment">//return head;</span><br>add-&gt;next = head;<br><span class="hljs-keyword">return</span> add;<br>&#125;<br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-keyword">struct</span> Node *<span class="hljs-title function_">insert</span><span class="hljs-params">(Node *head,<span class="hljs-type">int</span> data)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">add</span>=</span>createNode(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        head=head-&gt;next;<br>    &#125;<br>    head-&gt;next=add;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node *<span class="hljs-title function_">search</span><span class="hljs-params">(Node *head,<span class="hljs-type">int</span> data)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>||head-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>=</span>head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==data)&#123;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node *<span class="hljs-title function_">del</span><span class="hljs-params">(Node *head,<span class="hljs-type">int</span> data)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head-&gt;data==data)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>=</span>head-&gt;next;<br>        <span class="hljs-built_in">free</span>(head);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">tail</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>=</span>head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==data)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        tail=p;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data==data)&#123;<br>        tail-&gt;next=p-&gt;next;<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-comment">//清除链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">destoty</span><span class="hljs-params">(Node *head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head!=<span class="hljs-literal">NULL</span>)&#123;<br>        destory(head-&gt;next);<br>        <span class="hljs-built_in">free</span>(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双向非循环链表"><a href="#双向非循环链表" class="headerlink" title="双向非循环链表"></a>双向非循环链表</h4><p><strong>作用</strong>：</p><ul><li><strong>有时候以倒序扫描链表更方便</strong>，但是为了实现这个就会多出一条附加链的开销，他<strong>增加了空间的需求</strong>，同时使得插入和删除的开销增加一倍，但是<strong>又简化了删除操作</strong>。</li></ul><p><strong>概念</strong>：</p><ul><li><strong>双向非循环链表</strong>就是双向的链表，链表中的前后结点都有指向对方的指针，就是A<sub>1</sub>的next为A<sub>2</sub>，但是A<sub>2</sub>又有指针指向A<sub>1</sub>.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529599.png" alt="image"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* prev;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span> *<span class="hljs-built_in">createNode</span>(<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">auto</span>* p=(<span class="hljs-keyword">struct</span> doublyNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> doublyNode));<br>    p-&gt;data=data;<br>    p-&gt;prev=<span class="hljs-literal">NULL</span>;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//头插法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>*<span class="hljs-built_in">inserthead</span>(<span class="hljs-keyword">struct</span> doublyNode* head,<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>*add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>*p=head;<br>    head=add;<br>    head-&gt;next=p;<br>    p-&gt;prev=head;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span> * <span class="hljs-built_in">insertlast</span>(<span class="hljs-keyword">struct</span> doublyNode* head,<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>*p=head;<br>    <span class="hljs-keyword">while</span> (p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        p=p-&gt;next;<br>    &#125;<br>    p-&gt;next=add;<br>    p-&gt;prev=p;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-function">doublyNode * <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> doublyNode* head,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;链表没有数据&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head-&gt;data==data)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* p=head-&gt;next;<br>        <span class="hljs-built_in">free</span>(head);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* tail=head;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* p=head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==data)&#123;<br>            tail-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        tail=p;<br>        p=p-&gt;next;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> doublyNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;链表没有数据&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">doublyNode</span>* p=head;<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>概念</strong>：</p><ul><li><strong>循环链表</strong>就是没有表头表尾的链表，例如一般的链表的表尾为NULL,但是循环链表的下一个指向的表头，不仅有<strong>单向循环链表</strong>，而且还有<strong>双向循环链表</strong>，双向循环链表就是表头的前一个指向表尾，表尾的下一个指向表头。</li><li><em>C++中的STL库中就已经封装了双向循环链表的类(list)</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529600.png" alt="image"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单向循环链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span> *prev;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* <span class="hljs-built_in">createNode</span>(<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=(<span class="hljs-keyword">struct</span> CirNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> CirNode));<br>    p-&gt;data=data;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    p-&gt;prev=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* <span class="hljs-built_in">inserthead</span>(CirNode* head,<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        add-&gt;next=add;<br>        add-&gt;prev=add;<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=head;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p1=head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p1!=head)&#123;<br>        p1=p1-&gt;next;<br>    &#125;<br>    head=add;<br>    head-&gt;next=p;<br>    p1-&gt;next=head;<br>    head-&gt;prev=p1;<br>    p-&gt;prev=head;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//尾插法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* <span class="hljs-built_in">insertlast</span>(CirNode* head,<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        add-&gt;prev=add;<br>        add-&gt;next=add;<br>        <span class="hljs-keyword">return</span> add;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=head)&#123;<br>        p=p-&gt;next;<br>    &#125;<br>    p-&gt;next=add;<br>    add-&gt;prev=p;<br>    add-&gt;next=head;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* <span class="hljs-built_in">del</span>(CirNode* head,<span class="hljs-type">int</span> data)&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;链表没有数据&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(head-&gt;data==data)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=head-&gt;next;<br>        p-&gt;prev=head-&gt;prev;<br>        <span class="hljs-built_in">free</span>(head);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* tail=head;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=head-&gt;next;<br>    <span class="hljs-keyword">while</span> (p!=head)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==data)&#123;<br>            tail-&gt;next=p-&gt;next;<br>            p-&gt;next-&gt;prev=tail;<br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        tail=p;<br>        p=p-&gt;next;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(CirNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;链表没有数据&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CirNode</span>* p=head;<br>    <span class="hljs-keyword">do</span>&#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p=p-&gt;next;<br>    &#125; <span class="hljs-keyword">while</span> (p!=head);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跳跃表-跳表"><a href="#跳跃表-跳表" class="headerlink" title="跳跃表(跳表)"></a>跳跃表(跳表)</h4><p><strong>概念</strong>：</p><ul><li><strong>跳跃表是一个随机化的数据结构</strong>，实质就是一种<strong>可以进行二分查找的有序链表</strong>。</li><li>跳表在<strong>原有的有序链表的基础上面通过随机化算法产生随机级数的节点使其通过节点的索引来实现快速查找</strong>，<strong>提高了插入，删除，查找操作的性能</strong></li><li>跳表数据结构是<strong>以O(logN)期望时间进行查找和删除操作的数据结构</strong></li></ul><p><strong>特性</strong>：</p><ul><li><strong>有序性</strong></li><li><strong>插入新元素通过随机化算法随机分配存储该新元素值的节点级数</strong>，而<strong>级数就代表着这个节点有多少个指针</strong>，例如调表的第k位4阶节点，从最高层到最后一层，每个指针指向第2<sup>i</sup>+k节点(也就是跳过2<sup>i</sup>个节点，i为层数)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529601.png" alt="image"></p><p><strong>随机化算法</strong>：</p><ul><li>该算法用于给跳表插入新元素时，进行随机产生k阶节点用于作为新元素值得载体插入在跳表中。</li><li>虽然是随机的，但是各阶节点的产生是有概率性的，1&#x2F;2是一阶节点，1&#x2F;4是2阶节点，大约1&#x2F;2<sup>i</sup>的节点是i阶节点。</li></ul><p><strong>查找操作</strong>：</p><ul><li>首先<strong>在最高级索引上查找最后一个小于当前查找元素的位置</strong>，<strong>然后再跳到次高级索引继续查找，直到跳到最底层为止。</strong></li><li>跳表的数据结构大大提高了查找操作，跳表的<strong>查找操作类似于二分查找</strong>。</li></ul><p><strong>插入操作</strong>：</p><ol><li><p><strong>随机产生阶数，然后根据阶数跟数值创建节点</strong></p></li><li><p>如果<strong>新创建的表头</strong>，则<strong>直接令表头的第一层索引指针指向新创建的节点</strong>，如果<strong>不是就根据上步产生的阶数创建prev数组用来存储每层要插入节点位置的前继节点，遍历每一层，将prev赋值完</strong>。</p></li><li><p>然后<strong>根据阶数遍历，插入到存储到prev的前继节点的下一个位置。</strong></p></li></ol><p><strong>删除操作</strong>：</p><ol><li>跟插入操作差不多，<strong>先进行将prev数组赋值</strong></li><li>然后<strong>遍历每层，将每层的前继节点指向被删除节点的下一个节点</strong>。</li><li><strong>释放被删除节点的空间</strong>。</li></ol><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> val;     <span class="hljs-comment">//存储元素值</span><br>    vector&lt;Node*&gt;next;   <span class="hljs-comment">//存储各层数指针的数组</span><br>    <span class="hljs-type">int</span> level;  <span class="hljs-comment">//阶数</span><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">skiplist</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">skiplist</span>(<span class="hljs-type">int</span> level):<span class="hljs-built_in">Maxlevel</span>(level)&#123;<br>        head= <span class="hljs-built_in">createNode</span>(<span class="hljs-literal">NULL</span>,Maxlevel);<br>    &#125;<br>    ~<span class="hljs-built_in">skiplist</span>() &#123;<br>        Node* tail=head;<br>        Node* p;<br>        <span class="hljs-keyword">while</span> (tail!= <span class="hljs-literal">nullptr</span>)&#123;<br>            p=tail;<br>            tail=tail-&gt;next[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">delete</span> p;<br>        &#125;<br>        head= <span class="hljs-literal">nullptr</span>;<br>    &#125;;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Node* head;<br>    <span class="hljs-type">int</span> Maxlevel;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data,<span class="hljs-type">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> Node;<br>        p-&gt;val=data;<br>        p-&gt;level=level;<br>        p-&gt;next.<span class="hljs-built_in">resize</span>(level,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rand_level</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> level=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">2</span>&amp;&amp;level&lt;=Maxlevel)&#123;<br>            level++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br><br><br>&#125;;<br><br><span class="hljs-function">Node *<span class="hljs-title">skiplist::find</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>    Node* p=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Maxlevel<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span> (p-&gt;next[i]!= <span class="hljs-literal">nullptr</span>&amp;&amp;p-&gt;next[i]-&gt;val&lt;data)&#123;<br>            p=p-&gt;next[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next[<span class="hljs-number">0</span>]!= <span class="hljs-literal">nullptr</span>&amp;&amp;p-&gt;next[<span class="hljs-number">0</span>]-&gt;val==data)&#123;<br>        <span class="hljs-keyword">return</span> p-&gt;next[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">skiplist::insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>    <span class="hljs-type">int</span> level=<span class="hljs-built_in">rand_level</span>();<br>    Node* add= <span class="hljs-built_in">createNode</span>(data,level);<br>    <span class="hljs-keyword">if</span>(head-&gt;next[<span class="hljs-number">0</span>]== <span class="hljs-literal">nullptr</span>)&#123;<br>        head-&gt;next[<span class="hljs-number">0</span>]=add;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node* p=head;<br>    Node* prev[level];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=level<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span> (p-&gt;next[i]!= <span class="hljs-literal">nullptr</span>&amp;&amp;p-&gt;next[i]-&gt;val&lt;data)&#123;<br>            p=p-&gt;next[i];<br>        &#125;<br>        prev[i]=p;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;level;i++)&#123;<br>        add-&gt;next[i]=prev[i]-&gt;next[i];<br>        prev[i]-&gt;next[i]=add;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">skiplist::del</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>    Node* p=head;<br>    Node* prev[Maxlevel];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Maxlevel<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">nullptr</span>!=p-&gt;next[i]&amp;&amp;p-&gt;next[i]-&gt;val&lt;data)&#123;<br>            p=p-&gt;next[i];<br>        &#125;<br>        prev[i]=p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p-&gt;next[<span class="hljs-number">0</span>]!= <span class="hljs-literal">nullptr</span>&amp;&amp;p-&gt;next[<span class="hljs-number">0</span>]-&gt;val==data)&#123;<br>        Node* tail=p-&gt;next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Maxlevel<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(prev[i]-&gt;next[i]!= <span class="hljs-literal">nullptr</span>&amp;&amp;prev[i]-&gt;next[i]-&gt;val==data)<br>                prev[i]-&gt;next[i]=prev[i]-&gt;next[i]-&gt;next[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span> tail;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">skiplist::print</span><span class="hljs-params">()</span> </span>&#123;<br>    Node* p=head-&gt;next[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;p-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p=p-&gt;next[<span class="hljs-number">0</span>];<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><ul><li><strong>栈(stack)<strong>是限制插入和删除只能在一个位置上的进行的表，而这个模型唯一的开口位置是表的</strong>末端</strong>，叫做<strong>栈顶(top)<strong>，相反表的首部，叫做</strong>栈底</strong>。对于栈的基本操作有**Push(进栈)<strong>和</strong>Pop(出栈)**，前者相当于插入，后者则是删除表中最后一个元素(也就是处在栈顶位置的元素)。</li><li><em>栈是一个先进后出的模型</em></li></ul><p><strong>注意事项</strong>：</p><ul><li><p>虽然这里将栈放在线性表外，但是栈模型也属于线性表。</p></li><li><p><strong>栈</strong>是既可以用数组实现也可以用链表实现</p><blockquote><ul><li>如果栈的大小已知且固定，或者对随机访问元素效率有较高要求，使用<strong>数组</strong>实现栈可能更合适。</li><li>如果栈的大小不确定，或者插入和删除操作频繁且在栈顶之外发生，使用<strong>链表</strong>实现栈可能更有优势。</li></ul></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529602.png" alt="image"></p><p><strong>链表实现代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Node* Stack;<br><br><span class="hljs-function">Stack <span class="hljs-title">createStack</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">struct</span> Node;<br>    p-&gt;data=data;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//进栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack &amp;head,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    Stack add= <span class="hljs-built_in">createStack</span>(data);<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        head=add;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Node* p=head;<br>        add-&gt;next=p;<br>        head=add;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">(Stack &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node* p=head;<br>    head=p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><br><span class="hljs-comment">//获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">(Stack head)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> head-&gt;data;<br>&#125;<br><br><br><span class="hljs-comment">//打印栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStack</span><span class="hljs-params">(Stack head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node* p=head;<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//获取栈的大小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Size</span><span class="hljs-params">(Stack head)</span></span>&#123;<br>    Node* p=head;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(p-&gt;data&amp;&amp;p-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        cnt=<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<br>            cnt++;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">//判断栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">(Stack head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (head!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//清空栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(Stack &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node* tail=head-&gt;next;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">delete</span> head;<br>        head=tail;<br>        <span class="hljs-keyword">if</span>(tail!=<span class="hljs-literal">NULL</span>)<br>            tail=tail-&gt;next;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>数组实现代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//入栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        head.<span class="hljs-built_in">push_back</span>(data);<br>    &#125;<br><br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据！&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            head.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//获取栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据！&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//打印栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printstack</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;栈中没有数据&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=head.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;it&gt;=head.<span class="hljs-built_in">begin</span>();it--)&#123;<br>                cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//清空栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;<br>        head.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//获取栈的大小</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//判断栈是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;head;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="逆波兰转换式"><a href="#逆波兰转换式" class="headerlink" title="逆波兰转换式"></a>逆波兰转换式</h4><p><strong>概念</strong>：</p><ul><li><p>一种<strong>后缀表达式</strong>，例如a+b+c*d，转换成逆波兰表达式就为：a b + c d * +，然后我们将逆波兰表达式压入栈中(<em>将元素压入栈中遇到运算符号就将栈中的两个元素进行出栈在进行运算，运算完后再压入栈中，重复操作就能得到逆波兰表达式的结果</em>)，逆波兰表达式中没有括号！</p></li><li><p>转换成逆波兰表达式，需要一个空栈跟一个临时输出区(但不直接输出)，将<strong>运算元素放进临时输出区</strong>，将<strong>运算符号压入栈</strong>中。</p><blockquote><ul><li>如果运算符的优先级大于上一个运算符，就进行入栈。</li><li>如果运算符的优先级小于等于上一个运算符，就将前面的运算符出栈放在临时输出区，再将该运算符入栈。</li><li>如果栈中有左括号，后面入栈的运算符不是右括号的话，左括号就不出栈，而是继续重复上两个规则，直到右括号出现就将左括号出栈，但括号不放入临时输出区</li><li>当运算元素都放入临时输出区时，栈区还有运算符就直接出栈放入临时存放区，最终将临时存放区按顺序输出出来就是转换的逆波兰表达式</li></ul></blockquote></li></ul><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> a1,b1;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;+&#x27;</span>||a==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>        a1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;*&#x27;</span>||a==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        a1=<span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;(&#x27;</span>||a==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>        a1=<span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;+&#x27;</span>||b==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>        b1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;*&#x27;</span>||b==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        b1=<span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==<span class="hljs-string">&#x27;(&#x27;</span>||b==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>        b1=<span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a1&gt;=b1;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">reversePolan</span><span class="hljs-params">(<span class="hljs-type">char</span> *an,<span class="hljs-type">int</span> len)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt;s;<br>    vector&lt;<span class="hljs-type">char</span>&gt;v;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(an[i]!=<span class="hljs-string">&#x27;+&#x27;</span>&amp;&amp;an[i]!=<span class="hljs-string">&#x27;-&#x27;</span>&amp;&amp;an[i]!=<span class="hljs-string">&#x27;*&#x27;</span>&amp;&amp;an[i]!=<span class="hljs-string">&#x27;/&#x27;</span>&amp;&amp;an[i]!=<span class="hljs-string">&#x27;(&#x27;</span>&amp;&amp;an[i]!=<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            v.<span class="hljs-built_in">push_back</span>(an[i]);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(an[i]==<span class="hljs-string">&#x27;+&#x27;</span>||an[i]==<span class="hljs-string">&#x27;-&#x27;</span>||an[i]==<span class="hljs-string">&#x27;*&#x27;</span>||an[i]==<span class="hljs-string">&#x27;/&#x27;</span>||an[i]==<span class="hljs-string">&#x27;(&#x27;</span>||an[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())&#123;<br>                s.<span class="hljs-built_in">push</span>(an[i]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(an[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                s.<span class="hljs-built_in">push</span>(an[i]);<br>                cnt=<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(an[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;cnt==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    v.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">top</span>());<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                s.<span class="hljs-built_in">pop</span>();<br>                cnt=<span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">flag</span>(s.<span class="hljs-built_in">top</span>(),an[i]))&#123;<br>                <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())&#123;<br>                    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    v.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">top</span>());<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                s.<span class="hljs-built_in">push</span>(an[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s.<span class="hljs-built_in">push</span>(an[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())&#123;<br>            v.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">top</span>());<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> an[]=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>&#125;;<br>    <span class="hljs-type">int</span> len= <span class="hljs-built_in">sizeof</span>(an)/ <span class="hljs-built_in">sizeof</span>(an[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">auto</span> a= <span class="hljs-built_in">reversePolan</span>(an,len);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i:a)&#123;<br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h3><p><strong>概念</strong>：</p><ul><li><strong>队列</strong>也是一种线性表，使用队列时插入在一端进行而删除则在另一端进行，队列的基本操作是<strong>入队</strong>，它是在<strong>表的末端</strong>(也叫做<strong>队尾</strong>)插入一个元素，<strong>出队</strong>，它是删除在**表的开头(**<strong>队头</strong>)的元素。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529603.png" alt="image"></p><p><strong>数组实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//数组实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//入队(向数组末尾插入数据)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        head.<span class="hljs-built_in">push_back</span>(data);<br>    &#125;<br><br>    <span class="hljs-comment">//出队(将数组第一个元素删除)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;队列中没有数据！&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">auto</span> it=head.<span class="hljs-built_in">begin</span>();<br>            head.<span class="hljs-built_in">erase</span>(it);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取队首元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;队列中没有数据！&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-comment">//打印队列</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;队列中没有数据！&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:head)&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-comment">//清空队列</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        head.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//获取队列大小</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//判断队列是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;head;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>链表实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链表实现</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Queue</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Queue* next;<br>&#125;;<br><br><span class="hljs-function">Queue* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> Queue;<br>    p-&gt;data=data;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//入队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue* &amp;head,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    Queue* add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">NULL</span>)&#123;<br>        head=add;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Queue* p=head;<br>        <span class="hljs-keyword">while</span> (p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            p=p-&gt;next;<br>        &#125;<br>        p-&gt;next=add;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//出队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue* &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;队列中没有元素&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Queue* p=head;<br>    head=p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><br><span class="hljs-comment">//获取队首元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">(Queue* &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;队列中没有元素&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head-&gt;data;<br>&#125;<br><br><span class="hljs-comment">//打印队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Queue* &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;队列中没有元素&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Queue* p=head;<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p=p-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//清空队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(Queue* &amp;head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;队列中没有元素&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Queue* tail=head-&gt;next;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">delete</span> head;<br>        head=tail;<br>        <span class="hljs-keyword">if</span>(tail!=<span class="hljs-literal">NULL</span>)<br>            tail=tail-&gt;next;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="普通树-多叉树"><a href="#普通树-多叉树" class="headerlink" title="普通树(多叉树)"></a>普通树(多叉树)</h4><p><strong>概念</strong>：</p><ul><li><strong>树</strong>就是由<strong>根节点(父亲)<strong>分出多个</strong>分支节点(儿子)<strong>，然后分支又分出多个分支，我们将这种结构称为树,树也可以这么定义：一棵树由称作</strong>根的节点r以及0个或多个非空的(子)树T1，T2，T3…Tk组成</strong>，这些子树每一棵的根都被来自<strong>根r的一条有向的边所连接</strong>。</li><li><strong>从递归定义中我们发现</strong>，一颗树是<strong>N个节点</strong>和<strong>N-1条边</strong>的集合，其中的一个节点叫做<strong>根</strong>。每条边都将某个节点连接到它的父亲，而除去根接待你外每一个节点都有一个父亲。<strong>没有子节点的节点叫做树叶(叶节点)<strong>，</strong>具有相同父节点称为兄弟节点</strong>。<strong>节点深度</strong>就是该节点到根节点的长度是多少，<strong>节点高度</strong>就是该节点到最近叶节点的长度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529604.png" alt="image"></p><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//通过链表的形式，表头就是根节点，通过找到第一个子节点，就能找到其他的子节点。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">treeNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    treeNode* firstchild;    <span class="hljs-comment">//用于指向该节点的第一个子节点</span><br>    treeNode* nextsibling;   <span class="hljs-comment">//用于指向该节点的下一个兄弟节点</span><br>&#125;;<br><br><span class="hljs-function">treeNode* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> treeNode;<br>    p-&gt;data=data;<br>    p-&gt;firstchild=<span class="hljs-literal">NULL</span>;<br>    p-&gt;nextsibling=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//插入节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addChild</span><span class="hljs-params">(treeNode* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    treeNode* add=<span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        root=add;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;firstchild==<span class="hljs-literal">NULL</span>)&#123;<br>            root-&gt;firstchild=add;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            treeNode* p=root-&gt;firstchild;<br>            <span class="hljs-keyword">while</span>(p-&gt;nextsibling!=<span class="hljs-literal">NULL</span>)&#123;<br>                p=p-&gt;nextsibling;<br>            &#125;<br>            p-&gt;nextsibling=add;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//先序查找</span><br><span class="hljs-function">treeNode* <span class="hljs-title">preorderSearch</span><span class="hljs-params">(treeNode* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    treeNode* res;<br>    res=<span class="hljs-built_in">preorderSearch</span>(root-&gt;firstchild,data);<br>    <span class="hljs-keyword">if</span>(res!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res=<span class="hljs-built_in">preorderSearch</span>(root-&gt;nextsibling,data);<br>    <span class="hljs-keyword">if</span>(res!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//后序查找</span><br><span class="hljs-function">treeNode* <span class="hljs-title">postorderSearch</span><span class="hljs-params">(treeNode* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    treeNode* res;<br>    res=<span class="hljs-built_in">postorderSearch</span>(root-&gt;firstchild,data);<br>    <span class="hljs-keyword">if</span>(res!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res=<span class="hljs-built_in">postorderSearch</span>(root-&gt;nextsibling,data);<br>    <span class="hljs-keyword">if</span>(res!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//删除节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(treeNode* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    treeNode* p=<span class="hljs-literal">NULL</span>;<br>    treeNode* tail=root-&gt;firstchild;<br>    <span class="hljs-keyword">while</span>(tail!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(tail-&gt;data==data)&#123;<br>            <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>                root-&gt;firstchild=tail-&gt;nextsibling;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p-&gt;nextsibling=tail-&gt;nextsibling;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> tail;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">del</span>(tail,data);<br>        p=tail;<br>        tail=tail-&gt;nextsibling;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderprint</span><span class="hljs-params">(treeNode *root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorderprint</span>(root-&gt;firstchild);<br>    <span class="hljs-built_in">preorderprint</span>(root-&gt;nextsibling);<br>&#125;<br><br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderprint</span><span class="hljs-params">(treeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">postorderprint</span>(root-&gt;firstchild);<br>    <span class="hljs-built_in">postorderprint</span>(root-&gt;nextsibling);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><br><span class="hljs-comment">//清空树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(treeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">destroy</span>(root-&gt;firstchild);<br>    <span class="hljs-built_in">destroy</span>(root-&gt;nextsibling);<br>    <span class="hljs-keyword">delete</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>树有很多应用。流行的用法之一是包括UNIX、VAX&#x2F;VMS和DOS在内的许多常用操作中的目录结构。</p><p><strong>核心思想</strong>：</p><ul><li>树的遍历的核心是<strong>递归</strong></li><li>树的遍历的核心思想还有<strong>遍历的方式</strong>(先序遍历，后序遍历….)</li></ul><p><strong>先序遍历</strong>：</p><ul><li>先从根节点，处理完根节点，再去处理子树</li><li>先处理子树的根节点，才处理子节点</li><li><strong>先序遍历总是处理根节点，再处理子节点</strong></li></ul><p><strong>后序遍历</strong>：</p><ul><li>先处理子树的子节点，再处理子树的根节点</li><li>把全部小子树处理完，就处理树的根节点</li><li><strong>后序遍历总是先处理子节点，再处理根节点</strong></li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><strong>概念</strong>：</p><ul><li><strong>二叉树(binary tree)<strong>是一颗</strong>每个节点都不能多于两个子节点</strong>的树，左边的子树称为左子树，右边的子树称为右子树</li></ul><p><strong>性质</strong>：</p><ul><li><p>二叉树实际上是图，二叉树相对于树更常用。</p></li><li><p>平衡二叉树的深度要比节点数小很多，平均深度为<strong>O(n<sup>1&#x2F;2</sup>)</strong></p></li><li><p>对于特殊类型的二叉树，即**二叉查找树(binary search tree)<strong>，平均深度为</strong>O(logN)**，最坏情况的二叉树深度能达到N-1。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529605.png" alt="image"></p><p><strong>先序遍历</strong>：</p><ul><li><strong>先处理根节点，再处理左子树，最后处理右子树</strong></li><li>处理左子树的时候，也是先处理左子树的根节点，再处理剩下的左子节点(或者子树)，最后处理右节点(子树)</li><li>处理右子树跟处理左子树的操作一样。</li></ul><p><strong>中序遍历</strong>：</p><ul><li><strong>先处理左子树，再处理根节点，最后处理右子树</strong></li><li>处理左子树时，也是先处理左子树的左子节点(子树),再处理左子树的根节点，最后处理左子树的右子节点(子树)</li><li>处理完左子树，处理根节点</li><li>处理完根节点，就处理右子树(跟处理左子树的操作一致)</li></ul><p><strong>后序遍历</strong>：</p><ul><li><strong>先处理左子树，再处理右子树，最后处理根节点</strong></li><li>处理左子树的时候，也是先处理左子树的左子节点(子树)，再处理左子树的右子节点(子树)，最后处理左子树的根节点。</li><li>处理完左子树，再处理右子树(跟处理左子树的操作一致)</li><li>处理完右子树，最后处理树的根节点</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树,用left指向左子树节点，用right指向右子树节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binarytree</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    binarytree* left;<br>    binarytree* right;<br>&#125;;<br><br><span class="hljs-function">binarytree* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> binarytree;<br>    p-&gt;data=data;<br>    p-&gt;left=<span class="hljs-literal">NULL</span>;<br>    p-&gt;right=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//插入节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addchild</span><span class="hljs-params">(binarytree* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    binarytree* add= <span class="hljs-built_in">createNode</span>(data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root) &#123;<br>        root = add;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root-&gt;left)&#123;<br>            root-&gt;left=add;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root-&gt;right)&#123;<br>            root-&gt;right=add;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;该根节点的子节点已满！&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//先序查找</span><br><span class="hljs-function">binarytree* <span class="hljs-title">preorderSearch</span><span class="hljs-params">(binarytree* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    binarytree* res;<br>    res=<span class="hljs-built_in">preorderSearch</span>(root-&gt;left,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res=<span class="hljs-built_in">preorderSearch</span>(root-&gt;right,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//中序查找</span><br><span class="hljs-function">binarytree* <span class="hljs-title">inorderSearch</span><span class="hljs-params">(binarytree* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    binarytree* res;<br>    res=<span class="hljs-built_in">inorderSearch</span>(root-&gt;left,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    res=<span class="hljs-built_in">inorderSearch</span>(root-&gt;right,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//后序查找</span><br><span class="hljs-function">binarytree* <span class="hljs-title">postorderSearch</span><span class="hljs-params">(binarytree* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    binarytree* res;<br>    res= <span class="hljs-built_in">postorderSearch</span>(root-&gt;left,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    res= <span class="hljs-built_in">postorderSearch</span>(root-&gt;right,data);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span>!=res)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//清空树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(binarytree* &amp;root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">destroy</span>(root-&gt;left);<br>    <span class="hljs-built_in">destroy</span>(root-&gt;right);<br>    <span class="hljs-keyword">delete</span> root;<br>&#125;<br><br><span class="hljs-comment">//删除节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(binarytree* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    binarytree* p=root;<br>    binarytree* tail=root-&gt;left;<br>    <span class="hljs-keyword">while</span> (tail!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(tail-&gt;data==data)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=p-&gt;right)&#123;<br>                p-&gt;left=p-&gt;right;<br>                p-&gt;right=<span class="hljs-literal">NULL</span>;<br>                <span class="hljs-keyword">delete</span> tail;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">delete</span> tail;<br>                p-&gt;left=<span class="hljs-literal">NULL</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">del</span>(tail,data);<br>        binarytree* temp=p;<br>        p=tail;<br>        tail=temp-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderprint</span><span class="hljs-params">(binarytree* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorderprint</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorderprint</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderprint</span><span class="hljs-params">(binarytree* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;left);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderprint</span><span class="hljs-params">(binarytree* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">postorderprint</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorderprint</span>(root-&gt;right);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树-二叉排序树"><a href="#二叉查找树-二叉排序树" class="headerlink" title="二叉查找树(二叉排序树)"></a>二叉查找树(二叉排序树)</h4><p><strong>概念</strong>：</p><ul><li>二叉树的一个重要应用是它们在查找中的使用—二叉查找树</li><li>二叉查找树<strong>每个节点的值都不同</strong>，以后再处理值相同的情况</li><li><strong>对于二叉查找树的每个节点，它的左子树中所有关键字值小于该节点的关键字值，而它的右子树中所有的关键字值大于该节点的关键字值</strong></li><li>该数的所有元素可以用某种统一的方式排序—-<strong>二叉查找树有序</strong></li><li>二叉查找树的平均深度为<em>O(logN)</em></li><li>二叉查找树应该用<strong>中序遍历</strong>方式遍历</li></ul><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binarysearch</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    binarysearch* left;<br>    binarysearch* right;<br>&#125;;<br><br><span class="hljs-function">binarysearch* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> binarysearch;<br>    p-&gt;data=data;<br>    p-&gt;right=<span class="hljs-literal">NULL</span>;<br>    p-&gt;left=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><br><span class="hljs-comment">//插入节点</span><br><span class="hljs-function">binarysearch* <span class="hljs-title">insert</span><span class="hljs-params">(binarysearch* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span>==root)&#123;<br>        binarysearch* add= <span class="hljs-built_in">createNode</span>(data);<br>        root=add;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">insert</span>(root-&gt;left,data);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right= <span class="hljs-built_in">insert</span>(root-&gt;right,data);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-comment">//查找,直接判断大小然后递归分树查找(小就左子树，大就右子树，不然就是中间的树根节点)</span><br><span class="hljs-function">binarysearch* <span class="hljs-title">Search</span><span class="hljs-params">(binarysearch* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(root-&gt;left,data);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(root-&gt;right,data);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//查找树的最小值,二叉查找树只需顺着左子树一路到最左就是最小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmin</span><span class="hljs-params">(binarysearch* root)</span></span>&#123;<br><span class="hljs-comment">//    递归形式</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findmin</span>(root-&gt;left);<br>    &#125;<br><br>    <span class="hljs-comment">//非递归形式</span><br><span class="hljs-comment">//    if(NULL!=root)&#123;</span><br><span class="hljs-comment">//        while (root-&gt;left!=NULL)&#123;</span><br><span class="hljs-comment">//            root=root-&gt;left;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//    &#125;else&#123;</span><br><span class="hljs-comment">//        return NULL;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    return root-&gt;data;</span><br>&#125;<br><br><span class="hljs-comment">//查找树的最大值，二叉查找树只需顺着右子树一路到最右就是最大</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmax</span><span class="hljs-params">(binarysearch* root)</span></span>&#123;<br>    <span class="hljs-comment">//递归形式</span><br><span class="hljs-comment">//    if(NULL==root)&#123;</span><br><span class="hljs-comment">//        return NULL;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    if(root-&gt;right==NULL)&#123;</span><br><span class="hljs-comment">//        return root-&gt;data;</span><br><span class="hljs-comment">//    &#125;else&#123;</span><br><span class="hljs-comment">//        return findmax(root-&gt;right);</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//非递归形式</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=root)&#123;<br>        <span class="hljs-keyword">while</span> (root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;<br>            root=root-&gt;right;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;树没有数据&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root-&gt;data;<br>&#125;<br><br><br><span class="hljs-comment">//遍历(使用中序遍历)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderprint</span><span class="hljs-params">(binarysearch* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;left);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//删除节点，如果只有一个节点就分析是左子树还是右子树，然后将子树代替该根节点</span><br><span class="hljs-comment">//如果既有左节点(子树)和右节点(子树)，就找到右子树的最小值节点代替该根节点！</span><br><span class="hljs-function">binarysearch* <span class="hljs-title">del</span><span class="hljs-params">(binarysearch* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">del</span>(root-&gt;left,data);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right=<span class="hljs-built_in">del</span>(root-&gt;right,data);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)&#123;     <span class="hljs-comment">//找寻右子树的最小值节点，删除最小值节点只有两种情况就是只有右子树(节点)或者没有节点。</span><br>        <span class="hljs-type">int</span> temp= <span class="hljs-built_in">findmin</span>(root-&gt;right);<br>        root-&gt;data=temp;<br>        root-&gt;right=<span class="hljs-built_in">del</span>(root-&gt;right,temp);<br>    &#125;<span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">//只有一个子节点或者没有子节点的情况</span><br>        binarysearch* p=root;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root-&gt;left)&#123;<br>            root=root-&gt;right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root-&gt;right)&#123;<br>            root=root-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-comment">//清空树</span><br><span class="hljs-function">binarysearch* <span class="hljs-title">destroy</span><span class="hljs-params">(binarysearch* &amp;root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=root)&#123;<br>        <span class="hljs-built_in">destroy</span>(root-&gt;left);<br>        <span class="hljs-built_in">destroy</span>(root-&gt;right);<br>        <span class="hljs-keyword">delete</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="平衡查找树-AVL树"><a href="#平衡查找树-AVL树" class="headerlink" title="平衡查找树(AVL树)"></a>平衡查找树(AVL树)</h4><p><strong>概念</strong>：</p><ul><li>为了防止因为插入删除而导致的<strong>树结构不平衡</strong>(通常我们删除节点总是对右子树的最小值节点替代操作，而不是交替的利用左子树的最大值节点替代，这就将导致左子树的平均深度大于右子树平均深度，直接导致整颗树平均深度的增加，导致对树节点的操作时间增长)，导致对树的操作所用时间成倍数增长的问题，我们采用<strong>平衡二叉树—左右子树的平均深度差不多</strong>，达到一种平衡的操作，平衡二叉树希望对树的任意节点的操作时间为<em>O(logN)</em></li><li>AVL(Adelson-Velskii和Landis)树是<strong>带有平衡条件的二叉查找树</strong>。这个平衡条件需要容易保持，而且需保证树的深度是O(logN)。</li><li>一颗AVL树是<strong>其每个节点的左子树和右子树的高度最多差1的二叉查找树</strong>，空树的高度定义为-1</li><li>在高度为h的AVL树中，最少节点数S(h)由S(h)&#x3D;S(h-1)+S(h-2)+1算出。该h为该数最大高度。</li></ul><p><strong>旋转</strong>：</p><ul><li><p>功能：对被破坏平衡的AVL树进行修正，<strong>使得重新平衡</strong></p></li><li><p>对于我们<strong>对树的插入操作</strong>，<strong>破坏AVL树的平衡</strong>，我们则需要对树进行简单的修正来保持平衡，这个操作我们称其为<strong>旋转</strong></p></li><li><p>我们把必须重新平衡的节点(<strong>就是造成AVL树不平衡的插入点跟因此被打破平衡的另外一个节点(也就是插入点跟树中的一个节点高度差大于1)的共同根节点</strong>)叫做α，由于任意节点最多有两个儿子，因此高度不平衡时，α点的两颗子树的高度差2，这种不平衡的情形有四种：</p><blockquote><p>1.对α的左儿子的左子树进行一次插入</p><p>2.对α的左儿子的右子树进行一次插入</p><p>3.对α的右儿子的左子树进行一次插入</p><p>4.对α的右儿子的右子树进行一次插入</p></blockquote></li><li><p>对于1和4的情形称为<strong>插入发生在”外边”的情况</strong>(即<strong>左-左</strong>的情况或<strong>右-右</strong>的情况)，该情况需要通过对<strong>树的一次单旋转</strong>而完成调整</p></li><li><p>对于2和3的情形称为<strong>插入发生在”内部”的情况</strong>(即<strong>左-右</strong>的情况或<strong>右-左</strong>的情况)，这个情况需要通过对<strong>树的双旋转</strong>来处理</p></li></ul><h5 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a><strong>单旋转</strong></h5><ul><li><p>对于情形1(如图4-31)，我们需要将造成不平衡的插入点上移一层，另外那个跟它高度差为2的节点下移一层(<strong>就是将α点跟其左节点进行单旋转</strong>(<em>单旋转就是类似将左节点拎起来，其他的节点根据重量下坠，然后再根据二叉查找树的特性排序形成新的平衡二叉树</em>))，并形成一个新的平衡二叉查找树，具体操作就如图4-32，插入6会破坏AVL树的特性，因为6是插入点，而8没有子节点(这个空的子节点其实就是被破坏平衡的高度差为2的节点)，它们的共同根节点就为8，所以8为α点，我们需要将α点的左节点也就是7跟α点也就是8进行单旋转，然后形成新的平衡查找树</p><p>具体操作为：</p><blockquote><ol><li>向α点的左儿子的左子树插入节点造成不平衡</li><li>将α点跟α点的左儿子做单旋转</li><li>原先α点的左儿子的左子树根节点成为现在α点(之前的α点的左儿子)的左儿子，原先的α点作为现在α点的右儿子，原先α点的左儿子的右子树根节点成为现在α点的右儿子的左子树根节点</li><li>重新形成一个新的AVL树</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529606.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529607.png" alt="image"></p></li><li><p>对于情形4(如图4-33)，其实情形4跟情形差不多的做法就是方向改变了，我们需要将造成不平衡的插入点上移一层，另外那个跟它高度差为2的节点下移一层(<strong>就是将α点跟其右节点进行单旋转</strong>(<em>单旋转就是类似将右节点拎起来，其他的节点根据重量下坠，然后再根据二叉查找树的特性排序形成新的平衡二叉树</em>))，并形成新的平衡二叉查找树</p><p>具体操作为：</p><blockquote><ol><li>向α点的右儿子的右子树插入节点造成不平衡</li><li>对α点跟α点的右儿子进行单旋转</li><li>原先的α点成为现在的α点(之前的α点的右儿子)的左儿子，原先的α点的右儿子的右子树根节点成为现在的α点的右儿子，原先α点的右儿子的左子树根节点成为了现在α点的左儿子的右子树根节点</li><li>重新形成一颗新的AVL树</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529608.png" alt="image"></p></li></ul><h5 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h5><ul><li><p>对于情形2和3，单旋转无法修正被破坏的AVL树，对于图4-34子树Y太深，单旋转无法减低它的深度</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529609.png" alt="image"></p></li><li><p>对于情形2，例如图4-35(k1&lt;k2&lt;k3)，我们需要用到<strong>双旋转</strong>(<em>让α的左儿子的右子树根节点跟α的左儿子做一次单旋转，旋转完后，α的左儿子的右子树就是α的左儿子，原来α的左儿子变成了α的左儿子的右子树根节点，然后现在的α的左儿子(也就是原来的α的左儿子的右子树根节点)跟α点做一次单旋转</em>)，具体步骤就是</p><blockquote><ol><li>向α的左儿子的右子树插入节点</li><li>就双旋转后，让α的左儿子的右子树根节点(这里成为k2)旋转到α点(这里称为k3)的位置，α的左儿子(称为k1)成为k2的左儿子，k3成为k2的右儿子</li><li>如果插入的是左节点，就让它成为k1的右儿子，如果插入的是右节点就让它成为k3的左儿子。</li><li>然后就形成了新的AVL树</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529610.png" alt="image"></p></li><li><p>对于情形三(图4-36，k1&lt;k2&lt;k3)，跟情形二做法差不多只是方向改变了，我们需要用到<strong>双旋转</strong>(<em>让α的右儿子的左子树根节点跟α的右儿子做一次单旋转，旋转完后，α的右儿子的左子树就是α的右儿子，原来α的右儿子变成了α的右儿子的左子树根节点，然后现在的α的右儿子(也就是原来的α的右儿子的左子树根节点)跟α点做一次单旋转</em>)，具体步骤就是</p><blockquote><ol><li>向α的右儿子的左子树插入节点</li><li>就双旋转后，让α的右儿子的左子树根节点(这里成为k2)旋转到α点(这里称为k1)的位置，α的右儿子(称为k3)成为k2的右儿子，k1成为k2的左儿子</li><li>如果插入的是左节点，就让它成为k1的右儿子，如果插入的是右节点就让它成为k3的左儿子。</li><li>然后就形成了新的AVL树</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529611.png" alt="image"></p></li></ul><p><strong>代码</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//平衡查找树是其每个节点的左子树和右子树的高度最多差1的二叉查找树</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AVL</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    AVL* left;<br>    AVL* right;<br>    <span class="hljs-type">int</span> height;  <span class="hljs-comment">//节点高度</span><br>&#125;;<br><br><span class="hljs-function">AVL* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> AVL;<br>    p-&gt;data=data;<br>    p-&gt;right=<span class="hljs-literal">NULL</span>;<br>    p-&gt;left=<span class="hljs-literal">NULL</span>;<br>    p-&gt;height=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//防止出现空的高度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Height</span><span class="hljs-params">(AVL* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;height;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//左左情况单旋转函数</span><br><span class="hljs-function">AVL* <span class="hljs-title">SingleRotatewithLeft</span><span class="hljs-params">(AVL* &amp;k1)</span></span>&#123;<br>    AVL* k2;<br>    k2=k1-&gt;left;<br>    k1-&gt;left=k2-&gt;right;<br>    k2-&gt;right=k1;<br>    k1-&gt;height= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(k1-&gt;left), <span class="hljs-built_in">Height</span>(k1-&gt;right))+<span class="hljs-number">1</span>;<br>    k2-&gt;height= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(k2-&gt;left), <span class="hljs-built_in">Height</span>(k2-&gt;right))+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-comment">//右右情况单旋转函数</span><br><span class="hljs-function">AVL* <span class="hljs-title">SingleRotatewithRight</span><span class="hljs-params">(AVL* &amp;k1)</span></span>&#123;<br>    AVL* k2;<br>    k2=k1-&gt;right;<br>    k1-&gt;right=k2-&gt;left;<br>    k2-&gt;left=k1;<br>    k1-&gt;height= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(k1-&gt;left), <span class="hljs-built_in">Height</span>(k1-&gt;right))+<span class="hljs-number">1</span>;<br>    k2-&gt;height= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(k2-&gt;left), <span class="hljs-built_in">Height</span>(k2-&gt;right))+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-comment">//左右情况双旋转</span><br><span class="hljs-function">AVL* <span class="hljs-title">DoubleRotatewithLeft</span><span class="hljs-params">(AVL* &amp;k1)</span></span>&#123;<br>    <span class="hljs-comment">//非递归形式</span><br><span class="hljs-comment">//    AVL* k2;</span><br><span class="hljs-comment">//    AVL* k3;</span><br><span class="hljs-comment">//    k2=k1-&gt;left;</span><br><span class="hljs-comment">//    k3=k1-&gt;left-&gt;right;</span><br><span class="hljs-comment">//    k1-&gt;left=k3-&gt;right;</span><br><span class="hljs-comment">//    k2-&gt;right=k3-&gt;left;</span><br><span class="hljs-comment">//    k3-&gt;left=k2;</span><br><span class="hljs-comment">//    k3-&gt;right=k1;</span><br><span class="hljs-comment">//    k1-&gt;height=max(Height(k1-&gt;left), Height(k1-&gt;right))+1;</span><br><span class="hljs-comment">//    k2-&gt;height=max(Height(k2-&gt;left), Height(k2-&gt;right))+1;</span><br><span class="hljs-comment">//    k3-&gt;height=max(Height(k3-&gt;left), Height(k3-&gt;right))+1;</span><br><span class="hljs-comment">//    return k3;</span><br>    <span class="hljs-comment">//递归形式，建议用递归，好记</span><br>    k1-&gt;left= <span class="hljs-built_in">SingleRotatewithRight</span>(k1-&gt;left);   <span class="hljs-comment">//k2跟k3单旋转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SingleRotatewithLeft</span>(k1);       <span class="hljs-comment">//k1跟现在的k2(原来的k3)单旋转</span><br>&#125;<br><br><span class="hljs-comment">//右左情况双旋转</span><br><span class="hljs-function">AVL* <span class="hljs-title">DoubleRotatewithRight</span><span class="hljs-params">(AVL* &amp;k1)</span></span>&#123;<br>    <span class="hljs-comment">//非递归形式</span><br><span class="hljs-comment">//    AVL* k2;</span><br><span class="hljs-comment">//    AVL* k3;</span><br><span class="hljs-comment">//    k2=k1-&gt;right;</span><br><span class="hljs-comment">//    k3=k1-&gt;right-&gt;left;</span><br><span class="hljs-comment">//    k1-&gt;right=k3-&gt;left;</span><br><span class="hljs-comment">//    k2-&gt;left=k3-&gt;right;</span><br><span class="hljs-comment">//    k3-&gt;left=k1;</span><br><span class="hljs-comment">//    k3-&gt;right=k2;</span><br><span class="hljs-comment">//    k1-&gt;height=max(Height(k1-&gt;left), Height(k1-&gt;right))+1;</span><br><span class="hljs-comment">//    k2-&gt;height=max(Height(k2-&gt;left), Height(k2-&gt;right))+1;</span><br><span class="hljs-comment">//    k3-&gt;height=max(Height(k3-&gt;left), Height(k3-&gt;right))+1;</span><br><span class="hljs-comment">//    return k3;</span><br>    <span class="hljs-comment">//递归形式</span><br>    k1-&gt;right= <span class="hljs-built_in">SingleRotatewithLeft</span>(k1-&gt;right);       <span class="hljs-comment">//k2跟k3单旋转</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SingleRotatewithRight</span>(k1);           <span class="hljs-comment">//k1跟现在的k2(原来的k3)单旋转</span><br>&#125;<br><br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function">AVL* <span class="hljs-title">insert</span><span class="hljs-params">(AVL* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        AVL* add= <span class="hljs-built_in">createNode</span>(data);<br>        root=add;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">insert</span>(root-&gt;left,data);<br>        <span class="hljs-comment">//判断高度差</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>== <span class="hljs-built_in">Height</span>(root-&gt;left)- <span class="hljs-built_in">Height</span>(root-&gt;right))&#123;<br>            <span class="hljs-comment">//左左情况，情形1,单旋转</span><br>            <span class="hljs-keyword">if</span>(data&lt;root-&gt;left-&gt;data)&#123;<br>                root=<span class="hljs-built_in">SingleRotatewithLeft</span>(root);<br>            &#125;<span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">//左右情况，情形2，双旋转</span><br>                root=<span class="hljs-built_in">DoubleRotatewithLeft</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right= <span class="hljs-built_in">insert</span>(root-&gt;right,data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>== <span class="hljs-built_in">Height</span>(root-&gt;right)- <span class="hljs-built_in">Height</span>(root-&gt;left))&#123;<br>            <span class="hljs-comment">//右右情况，情形4，单旋转</span><br>            <span class="hljs-keyword">if</span>(data&gt;root-&gt;right-&gt;data)&#123;<br>                root=<span class="hljs-built_in">SingleRotatewithRight</span>(root);<br>            &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//右左情况,情形3，双旋转</span><br>                root=<span class="hljs-built_in">DoubleRotatewithRight</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//通过递归，从后序开始往上回，这样就能保证树的高度的正确性,这样子到了根节点就拿到了最大的高度</span><br>    root-&gt;height= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(root-&gt;left), <span class="hljs-built_in">Height</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-comment">//查找</span><br><span class="hljs-function">AVL* <span class="hljs-title">Search</span><span class="hljs-params">(AVL* root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">Search</span>(root-&gt;left,data);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right= <span class="hljs-built_in">Search</span>(root-&gt;right,data);<br>    &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-comment">//查找最小值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmin</span><span class="hljs-params">(AVL* root)</span></span>&#123;<br>    <span class="hljs-comment">//递归形式</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findmin</span>(root-&gt;left);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br><br>    <span class="hljs-comment">//非递归形式</span><br><span class="hljs-comment">//    if(NULL!=root)&#123;</span><br><span class="hljs-comment">//        while (root-&gt;left!=NULL)&#123;</span><br><span class="hljs-comment">//            root=root-&gt;left;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        return root-&gt;data</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    return NULL;</span><br>&#125;<br><br><span class="hljs-comment">//查找最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmax</span><span class="hljs-params">(AVL* root)</span></span>&#123;<br>    <span class="hljs-comment">//递归形式</span><br><span class="hljs-comment">//    if(NULL==root)&#123;</span><br><span class="hljs-comment">//        return NULL;</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    if(NULL!=root-&gt;right)&#123;</span><br><span class="hljs-comment">//        return findmax(root-&gt;right);</span><br><span class="hljs-comment">//    &#125;else&#123;</span><br><span class="hljs-comment">//        return root-&gt;data;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//非递归形式</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>!=root)&#123;<br>        <span class="hljs-keyword">while</span> (root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;<br>            root=root-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root-&gt;data;<br>&#125;<br><br><br><span class="hljs-comment">//删除节点，删除操作也会导致AVL树平衡破坏，所以删除操作也需要对AVL树做判断</span><br><span class="hljs-function">AVL* <span class="hljs-title">del</span><span class="hljs-params">(AVL* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">del</span>(root-&gt;left,data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>== <span class="hljs-built_in">Height</span>(root-&gt;left)- <span class="hljs-built_in">Height</span>(root-&gt;right))&#123;<br>            <span class="hljs-keyword">if</span>(data&lt;root-&gt;left-&gt;data)&#123;<br>                root= <span class="hljs-built_in">SingleRotatewithLeft</span>(root);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                root= <span class="hljs-built_in">DoubleRotatewithLeft</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right=<span class="hljs-built_in">del</span>(root-&gt;right,data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>== <span class="hljs-built_in">Height</span>(root-&gt;right)- <span class="hljs-built_in">Height</span>(root-&gt;left))&#123;<br>            <span class="hljs-keyword">if</span>(data&gt;root-&gt;right-&gt;data)&#123;<br>                root= <span class="hljs-built_in">SingleRotatewithRight</span>(root);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                root= <span class="hljs-built_in">DoubleRotatewithRight</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)&#123;<br>        <span class="hljs-type">int</span> temp= <span class="hljs-built_in">findmin</span>(root);<br>        root-&gt;data=temp;<br>        root-&gt;right=<span class="hljs-built_in">del</span>(root-&gt;right,temp);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        AVL* p=root;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root-&gt;left)&#123;<br>            root=root-&gt;right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root-&gt;right)&#123;<br>            root=root-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">NULL</span>)<br>        root-&gt;height=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(root-&gt;left), <span class="hljs-built_in">Height</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-comment">//清空树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(AVL* &amp;root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">destroy</span>(root-&gt;left);<br>    <span class="hljs-built_in">destroy</span>(root-&gt;right);<br>    <span class="hljs-keyword">delete</span> root;<br>&#125;<br><br><span class="hljs-comment">//打印，中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderprint</span><span class="hljs-params">(AVL* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;left);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h4><p><strong>概念</strong>：</p><ul><li><strong>伸展树</strong>是一颗对<strong>任意一个节点被访问</strong>后，就经过<strong>一系列的AVL树的旋转操作</strong>将该<strong>节点放到根上</strong>的特殊<strong>二叉查找树</strong>。</li><li>伸展树能<strong>保证对树操作M次的时间复杂度为O(MlogN)<strong>，而当一个查找树的一个节点刚好处于查找树最坏的情形，我们每次访问都需要按照最坏情形的时间计算，这将耗费</strong>O(M*N)<strong>的时间，伸展树就是要</strong>将访问的节点进行移动</strong>，使它不一直存在一个地方，避免了多次操作最坏情形的出现，而伸展树访问的节点比较深，经过移动，对该节点的原先子树节点访问也会避免往更深处进行操作</li><li>伸展树不要求保留高度或平衡信息，因此能够节省空间以及简化代码</li></ul><p><strong>查找操作</strong>：</p><ul><li><p>关于访问节点，然后对其进行一系列旋转操作，将该节点放到<strong>根</strong>上，我们需要对访问该节点的路径上(<strong>从下到上</strong>)<strong>每一个节点都需要和它们的父节点</strong>实施<strong>单旋转</strong>，直到将该节点推到根</p></li><li><p>但是如果只进行单旋转情况，并直接从下到上的话，则会浪费大部分时间</p></li><li><p>因此我们需要使用<strong>展开</strong>操作，而展开操作其实就是根据路径树的结构分情况进行操作</p></li><li><p><strong>具体步骤</strong>：</p><blockquote><ol><li>判断路径的结构，分为“<strong>之字形</strong>”和“<strong>一字形</strong>”</li><li>如果是“<strong>之字形</strong>”，就需要对要访问的节点进行<strong>双旋转</strong>操作，<em>如果访问的节点不是根的孙节点</em>，则进行双旋转操作后，<strong>会将路径结构转换为“一字形”</strong>，然后再进行“一字形”操作，将其放在根上</li><li>如果是“<strong>一字形</strong>”，就需要路径<strong>从下到上逐一进行单旋转操作</strong>，直至要访问的节点成为根才结束</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529612.png" alt="image"></p></li></ul><p><strong>删除操作</strong>：</p><ul><li>我们可以<strong>通过访问要被删除的节点然后访问后进行删除</strong>，这样的话，被删除节点就会被推到根上，<strong>将该节点删除，树就会分为两颗子树T<sub>L</sub>和T<sub>R</sub>(左子树和右子树)</strong></li><li>要想将T<sub>L</sub>和T<sub>R</sub>重新合成为一个树，就<strong>需要找到T<sub>L</sub>的最大值</strong>，并进行<strong>旋转操作</strong>，<strong>将其作为T<sub>L</sub>的根节点</strong>，而此时T**<sub>L</sub>将是一个没有右儿子的树<strong>，然后将</strong>T<sub>R</sub>的根节点作为现在T<sub>L</sub>根节点的右儿子**</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">splay</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    splay* left;<br>    splay* right;<br>&#125;;<br><br><span class="hljs-function">splay* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> splay;<br>    p-&gt;data=data;<br>    p-&gt;left=<span class="hljs-literal">NULL</span>;<br>    p-&gt;right=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function">splay* <span class="hljs-title">SingleRotatewithLeft</span><span class="hljs-params">(splay* &amp;k1)</span></span>&#123;<br>    splay* k2;<br>    k2=k1-&gt;left;<br>    k1-&gt;left=k2-&gt;right;<br>    k2-&gt;right=k1;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-function">splay* <span class="hljs-title">SingleRotatewithRight</span><span class="hljs-params">(splay* &amp;k1)</span></span>&#123;<br>    splay* k2;<br>    k2=k1-&gt;right;<br>    k1-&gt;right=k2-&gt;left;<br>    k2-&gt;left=k1;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-function">splay* <span class="hljs-title">DoubleRotatewithLeft</span><span class="hljs-params">(splay* &amp;k1)</span></span>&#123;<br>    k1-&gt;left= <span class="hljs-built_in">SingleRotatewithRight</span>(k1-&gt;left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SingleRotatewithLeft</span>(k1);<br>&#125;<br><br><span class="hljs-function">splay* <span class="hljs-title">DoubleRotatewithRight</span><span class="hljs-params">(splay* &amp;k1)</span></span>&#123;<br>    k1-&gt;right= <span class="hljs-built_in">SingleRotatewithLeft</span>(k1-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SingleRotatewithRight</span>(k1);<br>&#125;<br><br><span class="hljs-comment">//插入</span><br><span class="hljs-function">splay* <span class="hljs-title">insert</span><span class="hljs-params">(splay* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        splay* add= <span class="hljs-built_in">createNode</span>(data);<br>        root=add;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">insert</span>(root-&gt;left,data);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right= <span class="hljs-built_in">insert</span>(root-&gt;right,data);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">//查找</span><br><span class="hljs-comment">//因为查找data很有可能是相等的，所以要分开这种情况，如果root的下一个是要找的我们就往上返，令节点差为2个保证了判断路径结构的正确性</span><br><span class="hljs-function">splay* <span class="hljs-title">search</span><span class="hljs-params">(splay* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root||root-&gt;data==data)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;data)&#123;<br>        root-&gt;left= <span class="hljs-built_in">search</span>(root-&gt;left,data);<br>        <span class="hljs-keyword">if</span>(data&lt;root-&gt;left-&gt;data)&#123;<br>            root= <span class="hljs-built_in">SingleRotatewithLeft</span>(root);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;left-&gt;data)&#123;<br>            root= <span class="hljs-built_in">DoubleRotatewithLeft</span>(root);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&gt;root-&gt;data)&#123;<br>        root-&gt;right= <span class="hljs-built_in">search</span>(root-&gt;right,data);<br>        <span class="hljs-keyword">if</span>(data&gt;root-&gt;right-&gt;data)&#123;<br>            root= <span class="hljs-built_in">SingleRotatewithRight</span>(root);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;root-&gt;right-&gt;data)&#123;<br>            root= <span class="hljs-built_in">DoubleRotatewithRight</span>(root);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">//查找最小值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmin</span><span class="hljs-params">(splay* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findmin</span>(root-&gt;left);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//查找最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmax</span><span class="hljs-params">(splay* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findmax</span>(root-&gt;right);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//删除树节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(splay* &amp;root,<span class="hljs-type">int</span> data)</span></span>&#123;<br>    <span class="hljs-built_in">search</span>(root,data);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        splay* t1=root-&gt;left;<br>        splay* t2=root-&gt;right;<br>        root-&gt;left=<span class="hljs-literal">NULL</span>;<br>        root-&gt;right=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">delete</span> root;<br>        <span class="hljs-type">int</span> temp= <span class="hljs-built_in">findmax</span>(t1);<br>        t1= <span class="hljs-built_in">search</span>(t1,temp);<br>        t1-&gt;right=t2;<br>        root=t1;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderprint</span><span class="hljs-params">(splay* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;left);<br>    cout&lt;&lt;root-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorderprint</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-comment">//清空树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(splay* &amp;root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">destroy</span>(root-&gt;left);<br>    <span class="hljs-built_in">destroy</span>(root-&gt;right);<br>    <span class="hljs-keyword">delete</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-树-B-tree"><a href="#B-树-B-tree" class="headerlink" title="B-树(B-tree)"></a><strong>B-树(B-tree)</strong></h4><p><strong>概念</strong>：</p><ul><li><p>B-树是一个<strong>非二叉树</strong>的<strong>多路平衡查找树(数据有序)<strong>，是</strong>一颗所有数据都存储在树叶节点上</strong>的树，不一定存储具体的数据，也可以是指向包含数据的记录的指针或地址</p></li><li><p>对于**阶为M(子节点数量在2和M之间)**的B-树具有一下结构特性：</p><blockquote><ol><li>树的根节点或者叶子节点，或者子节点数的范围为[2,M]</li><li>B树每个结点关键字数量为[ceil(2&#x2F;M)-1,M-1]</li><li>除根外，所有非树叶节点的子节点数在[ceil(2&#x2F;M),M]之间，ceil为向上取整函数</li><li><strong>所有的树叶都在相同的深度上</strong></li></ol></blockquote></li><li><p>非叶子节点也有存储关键词的地方，这个地方是来表示范围的(<em>如果要查找的数据小于该关键字就找关键字左边的子节点数据，大于就右边的子节点数据</em>)，<strong>如果叶子节点数据按照升序排列，则非叶子节点的关键词有m-1个(m为该非叶子节点的子节点个数)，如果按照降序排列，则非叶子节点的关键字有m个</strong>，例如图4-58为升序排列的B树</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529613.png" alt="image"></p></li></ul><p><strong>插入操作</strong></p><ul><li><p>插入在叶子节点进行</p></li><li><p>向B树中插入数据，<strong>根据非叶子节点的关键字找到正确的存储数据的叶子节点</strong>。</p></li><li><p>如果节点内的数据小于M-1(M为阶数)，就根据排列规则插入；如果节点能够存储的数据已经满了，就进行<strong>分裂节点(叶子节点)</strong></p><blockquote><p>分裂节点操作步骤：</p><ol><li>先看看<strong>该叶子节点的关键字数量</strong>是否小于M-1(M为阶数)</li><li>按顺序插入进去，节点的关键字数量如果<strong>大于M-1</strong>，就<strong>将该叶子节点分裂成两个叶子节点</strong>，两个叶子节点的<strong>数据各占原叶子节点的一半</strong>，<strong>中间的关键字(数据)作为根节点的关键字</strong>，<strong>剩下分成两部分的节点作为其(中间关键字形成的根节点)左右节点</strong>。当根节点大于M-1的时候，就分裂根节点！</li><li>如果小于则根据插入的关键字大小按顺序插入。</li></ol></blockquote></li></ul><p><strong>删除操作</strong></p><ol><li><p>通过递归找到指定删除的节点</p></li><li><p>删除的关键字在非叶子节点上，就将其左边的指向叶子节点中的最大值跟要删除的关键字互换，就递归进去删除最大值。</p></li><li><p>删除的关键字在叶子节点上</p><blockquote><ol><li>叶子节点的关键字个数大于ceil(M&#x2F;2-1),直接删除</li><li>叶子节点的关键字个数等于ceil(M&#x2F;2-1),向父节点借关键字</li></ol></blockquote></li><li><p>递归返回上一层后检查该节点的关键字数，如果小于ceil(M&#x2F;2-1)，就向父节点借关键字，合并该关键字的左右节点，然后不断返回上一层，不断地检查，向父节点借关键字，合并子节点直到返回到根节点。</p></li></ol><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">btree</span>&#123;<br>    <span class="hljs-type">int</span> level;  <span class="hljs-comment">//树的阶数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;keys;  <span class="hljs-comment">//关键字数组</span><br>    vector&lt;btree*&gt;child; <span class="hljs-comment">//子节点数组</span><br>    <span class="hljs-type">int</span> keynum;   <span class="hljs-comment">//节点的关键字数目</span><br>    btree* parent;    <span class="hljs-comment">//子节点的父节点</span><br>&#125;;<br><br><span class="hljs-comment">//创造节点</span><br><span class="hljs-function">btree* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> btree;<br>    p-&gt;level=level;<br>    p-&gt;keynum=<span class="hljs-number">0</span>;<br>    p-&gt;parent= <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=p-&gt;level;i++)&#123;<br>        p-&gt;child.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>        p-&gt;keys.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//查找指定值，返回一个包含节点指针，和指定值的位置的对组</span><br><span class="hljs-function">pair&lt;btree*,<span class="hljs-type">int</span>&gt; <span class="hljs-title">find</span><span class="hljs-params">(btree* root,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=root-&gt;keynum;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(key&lt;root-&gt;keys[i])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;root-&gt;keys[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(root,i);<br>        &#125;<br>    &#125;<br>    pair&lt;btree*,<span class="hljs-type">int</span>&gt;p=<span class="hljs-built_in">find</span>(root-&gt;child[i],key);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//分裂节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splitNode</span><span class="hljs-params">(btree* &amp;root,btree* p,<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;keynum==p-&gt;level)&#123;<br>            <span class="hljs-comment">//分裂节点</span><br>            <span class="hljs-type">int</span> mid=p-&gt;keynum/<span class="hljs-number">2</span>+p-&gt;keynum%<span class="hljs-number">2</span>;<br>            btree* newnode= <span class="hljs-built_in">createNode</span>(p-&gt;level);<br>            newnode-&gt;parent=p-&gt;parent;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=root-&gt;keynum;j&gt;index<span class="hljs-number">-1</span>;j--)&#123;<br>                root-&gt;keys[j+<span class="hljs-number">1</span>]=root-&gt;keys[j];<br>            &#125;<br>            root-&gt;keys[index]=p-&gt;keys[mid];<br>            root-&gt;keynum++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;j&lt;=p-&gt;keynum;j++)&#123;<br>                newnode-&gt;keys[j-mid]=p-&gt;keys[j];<br>                newnode-&gt;keynum++;<br>            &#125;<br>            p-&gt;keynum=p-&gt;keynum-newnode-&gt;keynum<span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> k;<br>            <span class="hljs-keyword">for</span>(k=root-&gt;level<span class="hljs-number">-1</span>;k&gt;index<span class="hljs-number">-1</span>;k--)&#123;<br>                root-&gt;child[k+<span class="hljs-number">1</span>]=root-&gt;child[k];<br>            &#125;<br>            k++;<br>            root-&gt;child[k]=newnode;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;keynum==root-&gt;level) &#123;<br>        btree *newchild = <span class="hljs-built_in">createNode</span>(root-&gt;level);<br>        <span class="hljs-type">int</span> mid = root-&gt;keynum / <span class="hljs-number">2</span> + root-&gt;keynum % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= root-&gt;level; i++) &#123;<br>            newchild-&gt;keys[i - mid] = root-&gt;keys[i];<br>            newchild-&gt;keynum++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = newchild-&gt;keynum; j &lt;= newchild-&gt;level; j++) &#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;child[j])<br>                root-&gt;child[j]-&gt;parent=newchild;<br>            newchild-&gt;child[j - newchild-&gt;keynum] = root-&gt;child[j];<br>            root-&gt;child[j] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;parent == <span class="hljs-literal">nullptr</span>) &#123;<br>            btree *newnode = <span class="hljs-built_in">createNode</span>(root-&gt;level);<br>            newnode-&gt;keys[<span class="hljs-number">1</span>] = root-&gt;keys[mid];<br>            newnode-&gt;keynum++;<br>            root-&gt;keynum = root-&gt;level - newchild-&gt;keynum - <span class="hljs-number">1</span>;<br>            newnode-&gt;child[<span class="hljs-number">0</span>] = root;<br>            newnode-&gt;child[<span class="hljs-number">1</span>] = newchild;<br>            root-&gt;parent = newnode;<br>            newchild-&gt;parent = newnode;<br>            root = newnode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            newchild-&gt;parent = root-&gt;parent;<br>            root-&gt;keynum = root-&gt;level - newchild-&gt;keynum - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> a = root-&gt;parent-&gt;keynum;<br>            <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; root-&gt;keys[mid] &lt; root-&gt;parent-&gt;keys[a]) &#123;<br>                root-&gt;parent-&gt;keys[a + <span class="hljs-number">1</span>] = root-&gt;parent-&gt;keys[a];<br>                root-&gt;parent-&gt;child[a + <span class="hljs-number">1</span>] = root-&gt;parent-&gt;child[a];<br>                a--;<br>            &#125;<br>            a++;<br>            root-&gt;parent-&gt;keys[a] = root-&gt;keys[mid];<br>            root-&gt;parent-&gt;keynum++;<br>            root-&gt;parent-&gt;child[a] = newchild;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//插入节点</span><br><span class="hljs-function">btree* <span class="hljs-title">insert</span><span class="hljs-params">(btree* &amp;root,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>==root-&gt;keynum)&#123;<br>        root-&gt;keys[<span class="hljs-number">1</span>]=key;<br>        root-&gt;keynum++;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-type">int</span> index=root-&gt;keynum;<br>    <span class="hljs-keyword">while</span> (index&gt;<span class="hljs-number">0</span>&amp;&amp;key&lt;root-&gt;keys[index])&#123;<br>        root-&gt;keys[index+<span class="hljs-number">1</span>]=root-&gt;keys[index];<br>        index--;<br>    &#125;<br>    index++;<br>    <span class="hljs-keyword">if</span>(root-&gt;child[<span class="hljs-number">0</span>]!=<span class="hljs-literal">nullptr</span>)&#123;<br>        btree* p;<br>        <span class="hljs-keyword">if</span>(index==root-&gt;keynum)&#123;<br>            p=root-&gt;child[index+<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p=root-&gt;child[index<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;child[<span class="hljs-number">0</span>]-&gt;child[<span class="hljs-number">0</span>]!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p= <span class="hljs-built_in">insert</span>(p,key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;child[<span class="hljs-number">0</span>]-&gt;child[<span class="hljs-number">0</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-type">int</span> i=p-&gt;keynum;<br>            <span class="hljs-keyword">while</span> (i&gt;<span class="hljs-number">0</span>&amp;&amp;key&lt;p-&gt;keys[i])&#123;<br>                p-&gt;keys[i+<span class="hljs-number">1</span>]=p-&gt;keys[i];<br>                i--;<br>            &#125;<br>            i++;<br>            p-&gt;keys[i]=key;<br>            p-&gt;keynum++;<br>        &#125;<br>        <span class="hljs-built_in">splitNode</span>(root,p,index);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        root-&gt;keys[index]=key;<br>        root-&gt;keynum++;<br>        <span class="hljs-built_in">splitNode</span>(root, <span class="hljs-literal">nullptr</span>,<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">//查找最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findmax</span><span class="hljs-params">(btree* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;child[<span class="hljs-number">0</span>]!= <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findmax</span>(root-&gt;child[root-&gt;keynum]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root-&gt;keys[root-&gt;keynum];<br>&#125;<br><br><span class="hljs-comment">//合并节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(btree* &amp;root,<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> min,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> n1 = root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keynum;<br>    <span class="hljs-type">int</span> n2 = root-&gt;child[n]-&gt;keynum;<br>    <span class="hljs-keyword">if</span> (n1 &gt; min) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n2; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>            root-&gt;child[n]-&gt;keys[j + <span class="hljs-number">1</span>] = root-&gt;child[n]-&gt;keys[j];<br>            root-&gt;child[n]-&gt;child[j + <span class="hljs-number">1</span>] = root-&gt;child[n]-&gt;child[j];<br>        &#125;<br>        root-&gt;child[n]-&gt;child[<span class="hljs-number">1</span>] = root-&gt;child[n]-&gt;child[<span class="hljs-number">0</span>];<br>        root-&gt;child[n]-&gt;keys[<span class="hljs-number">1</span>] = root-&gt;keys[n];<br>        root-&gt;keys[n]=root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keys[n1];<br>        root-&gt;child[n]-&gt;child[<span class="hljs-number">0</span>] = root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[n1];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[n1] = <span class="hljs-literal">nullptr</span>;<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[<span class="hljs-number">0</span>]-&gt;parent = root-&gt;child[n<span class="hljs-number">-1</span>];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keynum--;<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keys[n1] = <span class="hljs-literal">NULL</span>;<br>        root-&gt;child[n]-&gt;keynum++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n2 &gt; min) &#123;<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keys[n1+<span class="hljs-number">1</span>]=root-&gt;keys[n];<br>        root-&gt;keys[n]=root-&gt;child[n]-&gt;keys[<span class="hljs-number">1</span>];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[n1 + <span class="hljs-number">1</span>] = root-&gt;child[n]-&gt;child[<span class="hljs-number">0</span>];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[n1 + <span class="hljs-number">1</span>]-&gt;parent = root-&gt;child[n<span class="hljs-number">-1</span>];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keynum++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n2; j++) &#123;<br>            root-&gt;child[n]-&gt;keys[j] = root-&gt;child[n]-&gt;keys[j + <span class="hljs-number">1</span>];<br>            root-&gt;child[n]-&gt;child[j - <span class="hljs-number">1</span>] = root-&gt;child[n]-&gt;child[j];<br>        &#125;<br>        root-&gt;child[n]-&gt;child[n2<span class="hljs-number">-1</span>]=root-&gt;child[n]-&gt;child[n2];<br>        root-&gt;child[n]-&gt;keys[n2] = <span class="hljs-literal">NULL</span>;<br>        root-&gt;child[n]-&gt;child[n2] = <span class="hljs-literal">nullptr</span>;<br>        root-&gt;child[n]-&gt;keynum--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keys[n1+<span class="hljs-number">1</span>]=root-&gt;keys[n];<br>        root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keynum++;<br>        <span class="hljs-type">int</span> n3 = n2 + n1+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n1 + <span class="hljs-number">2</span>; j &lt;= n3; j++) &#123;<br>            root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keys[j] = root-&gt;child[n]-&gt;keys[j - n1<span class="hljs-number">-1</span>];<br>            root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;child[j<span class="hljs-number">-1</span>]=root-&gt;child[n]-&gt;child[j];<br>            root-&gt;child[n<span class="hljs-number">-1</span>]-&gt;keynum++;<br>        &#125;<br>        root-&gt;child[n]=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> index = root-&gt;keynum;<br>        <span class="hljs-keyword">while</span> (index &gt; n &amp;&amp; key &lt; root-&gt;keys[index]) &#123;<br>            root-&gt;keys[index<span class="hljs-number">-1</span>]=root-&gt;keys[index];<br>            root-&gt;child[index<span class="hljs-number">-1</span>]=root-&gt;child[index];<br>            index--;<br>        &#125;<br>        root-&gt;child[root-&gt;keynum]= <span class="hljs-literal">nullptr</span>;<br>        root-&gt;keynum--;<br>        <span class="hljs-keyword">if</span>(root-&gt;parent== <span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;keynum==<span class="hljs-number">0</span>)&#123;<br>            root-&gt;child[<span class="hljs-number">0</span>]-&gt;parent= <span class="hljs-literal">nullptr</span>;<br>            root=root-&gt;child[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//删除节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(btree* &amp;root,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==root)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=root-&gt;keynum;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(key&lt;root-&gt;keys[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;root-&gt;keys[i])&#123;<br>                <span class="hljs-built_in">del</span>(root-&gt;child[i],key);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> min=(root-&gt;level/<span class="hljs-number">2</span>+root-&gt;level%<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>==i)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;child[i]-&gt;keynum&gt;=min&amp;&amp;root-&gt;child[i+<span class="hljs-number">1</span>]-&gt;keynum&gt;=min)&#123;<br>                <span class="hljs-built_in">del</span>(root-&gt;child[i],key);<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;child[<span class="hljs-number">0</span>]!= <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;keynum&gt;=min)&#123;<br>                <span class="hljs-keyword">if</span>(root-&gt;keys[i]==key)&#123;<br>                    <span class="hljs-type">int</span> temp= <span class="hljs-built_in">findmax</span>(root-&gt;child[i<span class="hljs-number">-1</span>]);<br>                    root-&gt;keys[i]=temp;<br>                    <span class="hljs-built_in">del</span>(root-&gt;child[i<span class="hljs-number">-1</span>],temp);<br>                    <span class="hljs-built_in">merge</span>(root,key,min,i);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;root-&gt;keys[i])&#123;<br>                    <span class="hljs-keyword">if</span>(root-&gt;child[i<span class="hljs-number">-1</span>]-&gt;keynum&lt;min)&#123;<br>                        <span class="hljs-built_in">merge</span>(root,key,min,i);<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(root-&gt;child[i]-&gt;keynum&lt;min)&#123;<br>                        <span class="hljs-built_in">merge</span>(root,key,min,i);<br>                    &#125;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">merge</span>(root,key,min,i);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;root-&gt;keynum;j++)&#123;<br>                <span class="hljs-keyword">if</span>(root-&gt;keys[j]==key)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=j;d&lt;root-&gt;keynum;d++)&#123;<br>                root-&gt;keys[d]=root-&gt;keys[d+<span class="hljs-number">1</span>];<br>            &#125;<br>            root-&gt;keys[root-&gt;keynum]=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">if</span>(root-&gt;keynum&gt;min)&#123;<br>                root-&gt;keynum--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                root-&gt;keynum--;<br>                <span class="hljs-type">int</span> index=root-&gt;parent-&gt;keynum;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=root-&gt;keynum;k&gt;<span class="hljs-number">0</span>;k--)&#123;<br>                    root-&gt;keys[k+<span class="hljs-number">1</span>]=root-&gt;keys[k];<br>                &#125;<br>                <span class="hljs-keyword">while</span> (index&gt;<span class="hljs-number">0</span>&amp;&amp;key&lt;=root-&gt;parent-&gt;keys[index])&#123;<br>                    index--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>==index)&#123;<br>                    root-&gt;keys[root-&gt;keynum+<span class="hljs-number">1</span>]=root-&gt;parent-&gt;keys[<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    root-&gt;keys[root-&gt;keynum+<span class="hljs-number">1</span>]=root-&gt;parent-&gt;keys[index];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderprint</span><span class="hljs-params">(btree* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>!=root)&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;root-&gt;keynum;i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;child[i]!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-built_in">inorderprint</span>(root-&gt;child[i]);<br>            &#125;<br>            cout&lt;&lt;root-&gt;keys[i+<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;child[i]!= <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">inorderprint</span>(root-&gt;child[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="红黑树-RB-tree"><a href="#红黑树-RB-tree" class="headerlink" title="红黑树(RB-tree)"></a>红黑树(RB-tree)</h4><p><strong>概念</strong>：</p><ul><li><strong>红黑树</strong>是AVL树的变种，它<strong>是每一个节点或者着成红色，或者着成黑色的一棵二叉查找树。</strong></li><li>对红黑树的操作<strong>在最坏情形下花费O(logN)时间</strong>，它的插入操作使用的是非递归形式实现</li><li>红黑树的<strong>高度最多是2log(N+1)</strong></li></ul><p><strong>特性</strong>：</p><ul><li>红黑树是具有<strong>着色性质</strong>的<strong>二叉查找树</strong>，也就意味着树的节点值是<strong>有序的</strong>，且每个节点<strong>只可能是红色或者黑色</strong></li><li>红黑树的<strong>根是黑色的</strong></li><li>如果<strong>一个节点是红色的</strong>，那么它的<strong>子节点必须是黑色的</strong></li><li>从<strong>一个节点到一个空指针</strong>的<strong>每一条路径必须包含相同数目的黑色节点</strong></li></ul><p><strong>自顶向下插入操作</strong>：</p><ol><li><p>如果使用自底向上插入的话还需要进行逐步递归是他们保证满足红黑树特性，效率就降低了。</p></li><li><p>令<em>X为新插入节点(在下面的第三操作中为当前节点)，P为X的父节点，G为P的父节点(也就是X的祖父节点)，GP为G的父节点(也就是P的祖父节点，X的曾祖父节点)</em></p></li><li><p>因为红黑树是一颗二叉查找树，因此在<strong>插入时需要查找要插入的值的正确位置</strong>，在这个<strong>查找路径中</strong>，如果<strong>遇到节点(X)为黑色而子节点全部为红色</strong>，我们就进行<code>翻转操作</code>，也就是<strong>将该节点(X)着成红色，子节点全部着成黑色</strong>。<strong>翻转后</strong>:</p><blockquote><p>如果翻转后发现<strong>P和X节点都是红色</strong>就需要根据树的结构进行<code>旋转操作</code></p><ol><li>如果<strong>X，P，G形成”一字形”<strong>，则</strong>对P的父节点G</strong>(也就是X的祖父节点)<strong>与P进行</strong><code>单旋转</code>，并<strong>将新根也就是P着成黑色，新根的子节点都着成红色</strong>。</li><li>如果<strong>X，P，G形成”之字形”<strong>，则对</strong>G与X节点</strong>进行<code>双旋转</code>，并<strong>将新根着成黑色(也就是X节点)<strong>，然后</strong>将新根的子节点着成红色</strong></li></ol></blockquote></li><li><p>如果<strong>该节点(X)是黑色则继续将X下降</strong>，直到<strong>找到红色节点继续翻转</strong>，<strong>或者找到指定插入位置</strong>，找到指定位置也就是当前节点位置X就进行插入，<strong>新节点也是红色，需要重新判断其父节点是否为红色，为红色又需要进行翻转操作来调整</strong>。</p></li></ol><p><strong>自顶向下删除操作</strong></p><ol><li><p>自顶向下删除也需要保证红黑树的性质，插入是插入一片红色的叶子节点，那么反过来<strong>我们删除一个红色叶子节点就不会破坏红黑树性质</strong>，<strong>自顶向下插入的翻转操作是将红色节点减少，并将红色节点上浮</strong>，因为<strong>删除是插入的逆过程，因此删除的翻转操作就是要将树中的红色节点增多，并将红色节点下沉，这样我们删除红色叶子节点的概率更大，并且不会破坏红黑树性质</strong></p></li><li><p>删除操作一共有5种情况需要解决</p><blockquote><ol><li>要<strong>删除节点cur跟其兄弟节点s原本颜色为黑色</strong>，<strong>父亲节点p为红色</strong></li><li><strong>s的两个儿子都是红色</strong>，这样双旋转和单旋转都可以，这里优先选择<code>ps单选转</code>调整，<em>情况1-case4</em></li><li><strong>s的左儿子为红色</strong>，需要<code>ps.l双旋转</code>调整(s.l为s的左儿子)，<em>情况2-case1</em></li><li><strong>s的右儿子为红色</strong>，需要<code>ps单旋转</code>调整，<em>情况3-case2</em></li><li><strong>s有两个黑色儿子</strong>，直接<code>cur,p,s颜色翻转操作</code>调整，<em>情况4-case3</em></li><li><strong>p和cur为黑色</strong>，<strong>s为红色</strong>，需要<code>交换sp节点的颜色</code>，并且sp<code>单旋转</code>调整，<em>情况5-case5</em></li><li><strong>cur为红色</strong>，可以继续<code>将cur下降</code>，也就是当前cur指向原本cur的子节点，如果为红色继续下降，如果为黑色就判断是否需要操作</li></ol></blockquote></li><li><p><strong>tomove指向要删除节点也就是目标节点，而p指向真正要删除的叶子节点</strong>，cur则while循环完后则是指向nil节点，因为将tomove标记完，就进行cur和p就查找tomove右子树的最小值节点进行删除，而while循环终止条件为cur&#x3D;&#x3D;nil情况，因此p指向真正要删除的节点</p></li><li><p><strong>找到tomove和p后，将tomove的data等于p的data，将p删除</strong>，因为p为叶子节点，将p的父节点指向nil。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529614.png" alt="image"><em>情况2-case1</em></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529615.png" alt="image"><em>情况3-case2</em></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529616.png" alt="image"><em>情况4-case3</em></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529617.png" alt="image-20240502001308851"><em>情况1-case4</em></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529618.png" alt="image"><em>情况5-case5</em></p><p><strong>计算红黑树层数</strong>：</p><ul><li>需要<strong>对log2(树中总共节点数+1)向上取整</strong></li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Height</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">log2</span>(count+<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;red,black&#125; colortype;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    RBNode *left,*right,*parent;<br>    colortype color;   <span class="hljs-comment">//颜色</span><br>    <span class="hljs-built_in">RBNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val,RBNode* l,RBNode* r,RBNode* p,colortype c=red):<span class="hljs-built_in">data</span>(val),<br>                                                                        <span class="hljs-built_in">left</span>(l),<span class="hljs-built_in">right</span>(r),<span class="hljs-built_in">parent</span>(p),<span class="hljs-built_in">color</span>(c)&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RBtree</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RBtree</span>()&#123;<br>        nil=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RBNode</span>(INT_MAX, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>,black);<br>        root= <span class="hljs-literal">nullptr</span>;<br>        t=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RBNode</span>(INT_MIN,nil,nil,nil,black);<br>        size=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">RBtree</span>()&#123;<br>        <span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">delete</span> t;<br>        <span class="hljs-keyword">delete</span> nil;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span></span>;      <span class="hljs-comment">//插入操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span></span>;       <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-function">RBNode* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span></span>;   <span class="hljs-comment">//查找操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//打印操作,层序遍历</span><br>    <span class="hljs-comment">//清空操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">clear</span>(root);<br>        root= <span class="hljs-literal">nullptr</span>;<br>        t-&gt;right=nil;<br>        size=<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">overturnred</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val,RBNode* &amp;cur)</span></span>;    <span class="hljs-comment">//翻转操作,将当前节点变成红色，子节点变成黑色</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">overturnblack</span><span class="hljs-params">(<span class="hljs-type">int</span> val,RBNode* &amp;cur)</span></span>;   <span class="hljs-comment">//翻转操作，将当前节点变成黑色，子节点变成红色</span><br>    <span class="hljs-function">RBNode* <span class="hljs-title">SingleRotatewithleft</span><span class="hljs-params">(RBNode* &amp;k1)</span></span>;<br>    <span class="hljs-function">RBNode* <span class="hljs-title">SingleRotatewithright</span><span class="hljs-params">(RBNode* &amp;k1)</span></span>;<br>    <span class="hljs-function">RBNode* <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val,RBNode* &amp;k1)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(val&lt;k1-&gt;data)&#123;<br>            <span class="hljs-keyword">return</span> k1-&gt;left=val&lt;k1-&gt;left-&gt;data? <span class="hljs-built_in">SingleRotatewithleft</span>(k1-&gt;left): <span class="hljs-built_in">SingleRotatewithright</span>(k1-&gt;left);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> k1-&gt;right=val&lt;k1-&gt;right-&gt;data? <span class="hljs-built_in">SingleRotatewithleft</span>(k1-&gt;right): <span class="hljs-built_in">SingleRotatewithright</span>(k1-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(RBNode* &amp;rt)</span></span>;<br>    <span class="hljs-comment">// 计算红黑树层数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Height</span><span class="hljs-params">(<span class="hljs-type">int</span> nodeCount)</span> </span>&#123;<br>        <span class="hljs-comment">// 红黑树的层数为 log2(nodeCount+1)</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">log2</span>(nodeCount+<span class="hljs-number">1</span>));<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    RBNode* root;<br>    RBNode* nil;   <span class="hljs-comment">//空节点，color为黑色</span><br>    RBNode* t;  <span class="hljs-comment">//根标记，用于删除操作的便捷</span><br>    <span class="hljs-type">int</span> size;<br>&#125;;<br><br><span class="hljs-function">RBNode* <span class="hljs-title">RBtree::SingleRotatewithleft</span><span class="hljs-params">(RBNode *&amp;k1)</span> </span>&#123;<br>    RBNode* k2;<br>    k2=k1-&gt;left;<br>    k1-&gt;left=k2-&gt;right;<br>    k2-&gt;right=k1;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-function">RBNode* <span class="hljs-title">RBtree::SingleRotatewithright</span><span class="hljs-params">(RBNode *&amp;k1)</span> </span>&#123;<br>    RBNode* k2;<br>    k2=k1-&gt;right;<br>    k1-&gt;right=k2-&gt;left;<br>    k2-&gt;left=k1;<br>    <span class="hljs-keyword">return</span> k2;<br>&#125;<br><br><span class="hljs-comment">//翻转操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::overturnred</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val,RBNode* &amp;cur)</span> </span>&#123;<br>    cur-&gt;color=red;<br>    cur-&gt;left-&gt;color=cur-&gt;right-&gt;color=black;<br>    RBNode* p=cur-&gt;parent;<br>    <span class="hljs-keyword">if</span>(p-&gt;color==red)&#123;<br>        RBNode* g=p-&gt;parent;<br>        g-&gt;color=red;<br>        <span class="hljs-keyword">if</span>((val&lt;g-&gt;data)!=(val&lt;p-&gt;data))&#123;     <span class="hljs-comment">//双旋转</span><br>            p= <span class="hljs-built_in">Rotate</span>(val,g);<br>        &#125;<br>        cur= <span class="hljs-built_in">Rotate</span>(val,g-&gt;parent);<br>        cur-&gt;color=black;<br>    &#125;<br>    root-&gt;color=black;<br>&#125;<br><br><br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">nullptr</span>)&#123;<br>        root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RBNode</span>(val,nil,nil, t,black);<br>        t-&gt;right=root;<br>        size++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    RBNode *cur,*p;<br>    cur=p=root;<br>    <span class="hljs-keyword">while</span> (cur!=nil)&#123;<br>        p=cur;<br>        <span class="hljs-keyword">if</span>(cur-&gt;left-&gt;color==red&amp;&amp;cur-&gt;right-&gt;color==red)&#123;<br>            <span class="hljs-built_in">overturnred</span>(val,cur);<br>        &#125;<br>        cur=val&lt;p-&gt;data?p-&gt;left:p-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cur!=nil)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cur=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RBNode</span>(val, nil, nil, p);<br>    <span class="hljs-keyword">if</span>(val&lt;p-&gt;data)&#123;<br>        p-&gt;left=cur;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        p-&gt;right=cur;<br>    &#125;<br>    <span class="hljs-built_in">overturnred</span>(val,cur);<br>    size++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::overturnblack</span><span class="hljs-params">(<span class="hljs-type">int</span> val, RBNode *&amp;cur)</span> </span>&#123;<br>    cur-&gt;color=red;<br>    RBNode* p=cur-&gt;parent;<br>    RBNode* s=val&lt;p-&gt;data?p-&gt;left:p-&gt;right;<br>    <span class="hljs-comment">//case4:要删除节点cur跟其兄弟节点s原本颜色为黑色，父亲节点p为红色，s的两个儿子都是红色，这样双旋转和单旋转都可以，这里优先选择ps单选转</span><br>    <span class="hljs-comment">//case2:要删除节点cur跟其兄弟节点s原本颜色为黑色，父亲节点p为红色，s的右儿子为红色情况，需要ps单旋转调整</span><br>    <span class="hljs-keyword">if</span>(s-&gt;right-&gt;color==red)&#123;<br>        val=s-&gt;right-&gt;data;<br>    &#125;<br>    <span class="hljs-comment">//case1:要删除节点cur跟其兄弟节点s原本颜色为黑色，父亲节点p为红色，s的左儿子为红色的情况,需要ps.l双旋转调整</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s-&gt;left-&gt;color==red)&#123;<br>        val=s-&gt;left-&gt;data;<br>    &#125;<br>        <span class="hljs-comment">//case3:要删除节点cur跟其兄弟节点s原本颜色为黑色，父亲节点p为红色，s有两个黑儿子(nil节点也是黑色),直接将颜色翻转即可</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//翻转操作</span><br>        <span class="hljs-keyword">if</span>(s!=nil)&#123;<br>            s-&gt;color=red;<br>        &#125;<br>        p-&gt;color=black;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((val&lt;s-&gt;data)!=(val&lt;p-&gt;data))&#123;<br>        <span class="hljs-built_in">Rotate</span>(val,p);<br>    &#125;<br>    RBNode* g=p-&gt;parent;<br>    <span class="hljs-built_in">Rotate</span>(val,g);<br>    <span class="hljs-comment">//将调整完的cur的新祖父也就是s或者s的左儿子变成红色，也就是删除完cur后将颜色调整到之前cur在翻转前的情况</span><br>    g-&gt;color=red;<br>    g-&gt;left-&gt;color=g-&gt;right-&gt;color=black;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::del</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    RBNode* tomove=nil;  <span class="hljs-comment">//找到删除节点</span><br>    RBNode *g,*p,*s,*cur;<br>    g=p=t,s=t-&gt;left,cur=root;<br>    <span class="hljs-keyword">while</span> (cur!=nil)&#123;<br>        <span class="hljs-comment">//翻转颜色</span><br>        <span class="hljs-keyword">if</span>(cur-&gt;left-&gt;color==black&amp;&amp;cur-&gt;right-&gt;color==black)&#123;<br>            <span class="hljs-built_in">overturnblack</span>(val,cur);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            g=p;p=cur;<br>            <span class="hljs-keyword">if</span>(val&lt;p-&gt;data)&#123;<br>                cur=p-&gt;left,s=p-&gt;right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tomove=cur,cur=p-&gt;right,s=p-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">//case5:此时肯定p和cur都为黑色，因为如果p为红色早就翻转了，s肯定是红色，将s变成黑色，p变为红色，sp单旋转调整</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;color==black)&#123;<br>                s-&gt;color=black;<br>                p-&gt;color=red;<br>                <span class="hljs-comment">//单旋转完，cur新祖父变为s,将s重新更改</span><br>                g= <span class="hljs-built_in">Rotate</span>(val,g);<br>                s=val&lt;p-&gt;data?p-&gt;left:p-&gt;right;<br>                <span class="hljs-comment">//调整完该情况就重新检查上述操作</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//else，cur一定为红色，则可以直接继续将cur继续下降</span><br>        &#125;<br>        g=p;p=cur;<br>        <span class="hljs-keyword">if</span>(val&lt;p-&gt;data)&#123;<br>            cur=p-&gt;left,s=p-&gt;right;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tomove=cur,cur=p-&gt;right,s=p-&gt;left;<br>        &#125;<br>    &#125;<br>    root-&gt;color=black;   <span class="hljs-comment">//保证红黑树性质2不被破坏，也就是根一定为黑色</span><br><br>    <span class="hljs-comment">//判断是否找到真正要删除的节点，如果找不到就退出</span><br>    <span class="hljs-keyword">if</span>(tomove==nil&amp;&amp;tomove-&gt;data!=val)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到要删除对应值的节点&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//tomove是要删除的节点，而p指向的是真正要删除的节点</span><br>    tomove-&gt;data=p-&gt;data;<br>    <span class="hljs-keyword">if</span>(g-&gt;left==p) g-&gt;left=nil;<br>    <span class="hljs-keyword">else</span> g-&gt;right=nil;<br>    <span class="hljs-keyword">delete</span> p;<br>    size--;<br>&#125;<br><br><span class="hljs-function">RBNode* <span class="hljs-title">RBtree::find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root!= <span class="hljs-literal">nullptr</span>)&#123;<br>        RBNode* cur=root;<br>        <span class="hljs-keyword">while</span> (cur!=nil)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;data==val) <span class="hljs-keyword">return</span> cur;<br>            cur=val&lt;cur-&gt;data?cur-&gt;left:cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur==nil)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;树中没有指定值节点&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;树为空&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    queue&lt;RBNode*&gt;q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> h= <span class="hljs-built_in">Height</span>(size);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(ans==h+<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        RBNode* cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur== <span class="hljs-literal">nullptr</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;null&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;color==red)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;\033[31m&quot;</span>&lt;&lt;cur-&gt;data&lt;&lt;<span class="hljs-string">&quot;\033[0m&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==nil) cout&lt;&lt;<span class="hljs-string">&quot;nil&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;cur-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,ans))&#123;<br>            cout&lt;&lt;endl;<br>            cnt=<span class="hljs-number">0</span>,ans++;<br>        &#125;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RBtree::clear</span><span class="hljs-params">(RBNode* &amp;rt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(rt!=nil)&#123;<br>        <span class="hljs-built_in">clear</span>(rt-&gt;left);<br>        <span class="hljs-built_in">clear</span>(rt-&gt;right);<br>        <span class="hljs-keyword">delete</span> rt;<br>        rt=nil;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    RBtree rBtree;<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">15</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">65</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">60</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">70</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">64</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">66</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">85</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">55</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">63</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">80</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">90</span>);<br>    rBtree.<span class="hljs-built_in">insert</span>(<span class="hljs-number">45</span>);<br>    rBtree.<span class="hljs-built_in">del</span>(<span class="hljs-number">65</span>);<br>    rBtree.<span class="hljs-built_in">del</span>(<span class="hljs-number">50</span>);<br>    rBtree.<span class="hljs-built_in">del</span>(<span class="hljs-number">30</span>);<br>    rBtree.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表(哈希表)"></a>散列表(哈希表)</h3><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h5><ul><li><strong>散列(hashing)<strong>是一种用于以</strong>常数平均时间</strong>执行插入、删除和查找的技术。</li><li>散列不支持排序，所以散列表是无序的。</li><li>散列是一种存储结构(实质是一个<strong>数组</strong>，用于存储关键字值，关键字的存储<em>下标</em>就是根据关键字<em>映射</em>(通过散列函数也就是哈希函数)出来的位置)，**根据记录的存储位置与关键字之间存在对应关系(散列(哈希)函数)**，–<strong>也就是通过哈希函数对关键字值的处理，得出该关键字值在散列表中的存储位置</strong></li></ul><h5 id="散列函数-哈希函数"><a href="#散列函数-哈希函数" class="headerlink" title="散列函数(哈希函数)"></a><strong>散列函数(哈希函数)</strong></h5><blockquote><p>散列函数特性：</p><ol><li>简单快速</li><li>均匀性：需要让关键字均匀分布在哈希表中</li></ol></blockquote><ul><li>用于将关键字值<strong>映射</strong>到数组中的一个函数，一般的方法为<strong>关键字%表的大小</strong></li><li>该函数我们需要<strong>在单元之间均匀地分配关键字</strong>，好的办法就是表的大小是<strong>素数</strong>，这将让散列函数算起来简单并且关键字分配比较均匀</li><li>如果关键字是<strong>字符串</strong>的时候，通常我们<strong>将字符串中的每个字符转换为ASCII码并求和</strong>，得到一个int型的数，就可以对它进行散列函数映射到哈希表中，一个更好的方法是：根据horner法则，计算一个<strong>（32的）多项式函数</strong>。</li><li><strong>多个</strong>关键字<strong>映射</strong>到<strong>同一个</strong>数组下标或者数组单元的情况叫做<strong>冲突</strong></li></ul><p><strong>常用哈希函数</strong>：</p><ol><li><p>关键字是字符串：根据horner法则，计算一个（32的）多项式函数。</p><p><strong>介绍</strong>：如果<strong>关键字特别长</strong>，那么散列函数计算起来会花过多的时间，而且前面的字符还会左移出最终的结果。因此这样情况下，<strong>不使用所有的字符</strong>。此时<strong>关键字的长度和性质会影响选择</strong>。例如只取奇数位置上的字符来实现散列函数。这里的思想是用计算散列函数省下来的时间来补偿由此产生的对均匀分布函数的轻微干扰</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* key,<span class="hljs-type">int</span> tablesize)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashval=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*key!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        hashval=(hashval&lt;&lt;<span class="hljs-number">5</span>)+*key;    <span class="hljs-comment">//右移五次等于乘2的五次方也就是32</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> hashval%tablesize;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>直接寻址法</strong><br><strong>介绍</strong>:取<strong>关键字或关键字的某个线性函数值为散列地址</strong>，即<strong>H(key)&#x3D;key或者H(key)&#x3D;a*key+b（a,b为常数）。</strong><br>举例:[‘A’,‘B’,‘D’,‘A’,‘C’,‘E’,‘F’,‘C’] ,求该字符数组里每个字符的出现次数(数组中只有大写字母)。<br>分析:我们可以知道’A’-‘Z’的ASCLL码是65-90,则哈希函数可以通过直接寻址法H(key)&#x3D;key-‘A’（对应定义中的a&#x3D;1,b&#x3D;-‘A’即65）,这样针对每一个key,都可以将它的H(key)值当成数组下标放在一个长度为26的int数组中统计长度<br>假设字符数组为a,int数组为b。即b[a[i]-‘A’]++(i表示a数组的下标索引)。<br>结果<br>b[0]&#x3D;2(代表A出现两次)；b[1]&#x3D;1(代表B出现一次)，b[2]&#x3D;2(代表C出现两次)…</p></li><li><p><strong>数字分析法</strong><br><strong>介绍</strong>:<strong>分析一组数据中相同位(个位,十位,百位…)的数字出现频率</strong>，如果该位数字<strong>出现结果较为集中</strong>，如果<strong>取其作为构造散列地址的依据则很容易出现哈希冲突</strong>,反之，<strong>如果该位数字出现结果较为平均,则取其作为构造散列地址的依据则不容易出现哈希冲突。</strong><br>举例:某公司招聘了一些实习生,其生日分别为[19990104,20000910,20000315,20001128,20001014,19990413,19990920,20000517],对其进行hash处理。<br>分析<br>如果取8位数作为散列地址,虽然很难出现哈希冲突,但是空间浪费很大，因此考虑只取其中几位作为散列地址,即能减少空间浪费又能降低哈希冲突的可能性,观察上面8组数据，前4位集中在1999,2000，如果取前4位则很容易出现哈希冲突，而后四位分布相对分散，不容易出现哈希冲突，因此取后四位比较符合。<br>结果<br>H(19990104)&#x3D;104,H(20000910)&#x3D;910,H(20000315)&#x3D;315…</p></li><li><p><strong>折叠法</strong><br><strong>介绍</strong>:折叠法是把<strong>关键字值分成自左向右分成位数相等的几部分</strong>，<strong>每一部分的位数应与散列表地址(也就是数组下标)的位数相同</strong>，只有<strong>最后一部分的位数可以短一些</strong>。把<strong>这些部分的数据叠加起来（去除进位）</strong>，就可以得到关键字值的散列地址。<br>有两种叠加方法：<br>(1)**移位法(shift floding)**：把各部分的最后一位对齐相加。<br>(2)**分界法(floding at the boudaries)**：沿各部分的分界来回折叠(即第偶数个加数和移位法反过来)，然后对其相加。<br>举例:key&#x3D;1234791，散列地址为2位<br>分析<br>将key分成12,34,79,1四部分<br>(1)移位法:12+34+79+1<br>(2)分界法:12+43+79+1(即第偶数个加数和移位法反过来)<br>结果<br>(1)移位法:H(1234791)&#x3D;35(相加为135，去除进位1)<br>(2)分界法:H(1234791)&#x3D;44(相加为144，去除进位1)</p></li><li><p><strong>平方取中法</strong><br><strong>介绍</strong>：当<strong>无法确定关键字中哪几位分布较均为时</strong>，可以<strong>求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址</strong>。这是因为:平方后中间几位和关键字中每一位都有关，故不同关键字会以较高的概率产生不同的散列地址。<br>举例:关键字序列:{3213,3113,3212,4312}。<br>分析:<br>3213^2&#x3D;10323369<br>3113^2&#x3D;9690769<br>3212^2&#x3D;10316944<br>4312^2&#x3D;18593344<br>取平方值中间4位为散列地址(3113的平方值前面补0凑成8位)<br>结果<br>H(3213)&#x3D;3233,H(3113)&#x3D;6907,H(3212)&#x3D;3169,H(4312)&#x3D;5933</p></li></ol><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h5><ul><li><p><strong>负载因子(local factor)<strong>为</strong>散列表中的元素个数与散列表的大小的比值</strong>。</p><blockquote><ol><li>负载因子为0.7-0.75比较合理，负载因子在哈希表中的意义就是当你这个哈希表的负载因子达到你设定的值就进行扩容为后面的存储更多数据做准备。</li><li>java封装的数据结构也是使用的分离链接法，但是其不同的是，他不是完全的数组加链表的形式，它是当<strong>链表达到一定长度时就将链表转化为红黑树</strong>。</li><li>java封装的哈希表的数据结构的负载因子为什么为0.75呢</li></ol><ul><li>是因为<strong>当负载因子等于1</strong>的时候也就意味着关键字均匀分布并且几乎存满了哈希表(数组的每个下标都有关键字填充)才进行扩容的情况，关键字数量多就会<strong>造成大量的哈希冲突</strong>，这也造成了数组加红黑树的情况出现的更多，而这样<strong>底层的红黑树变得更加复杂</strong>，<strong>大大降低了查询速度</strong>，这种情况就是<strong>牺牲了时间来保证空间的利用率.</strong></li><li>当<strong>负载因子为0.5</strong>时，也就意味着<strong>当数组中的元素达到一半就开始扩容</strong>，虽然填充的元素少了，哈希冲突减少了，查询速度提高了，但是<strong>空间利用率降低了</strong>，原本1m的数据现在需要2m的空间存储，这就是<strong>牺牲空间来保证时间的效率</strong></li><li>当<strong>负载因子为0.75</strong>，<strong>时间和空间达到了平衡</strong>，所以java封装的哈希表结构的负载因子默认为0.75.</li></ul></blockquote></li><li><p><strong>分离链接法</strong>：就是一个<strong>数组加链表</strong>来解决冲突问题的，将映射到同一个数组下标的所有关键字保留在一个表中，而这个表就是链表，<strong>将同一个数组下标的所有关键字通过链表连接起来</strong>，该方法使用的比较多。分离链接散列的基本法则是<strong>使得表的大小尽量与预料的关键字个数差不多</strong>(也就是<strong>负载因子约等于1</strong>)，这样也就是能够<strong>保证关键字均匀分布在散列表中</strong>，使得查找时间减少。</p><blockquote><ol><li><strong>插入</strong>：插入时可以选择头插法插入链表中，如果插入重复元素，定义链表时可以选择多增加一个计数的域，来记录这个元素出现次数</li><li><strong>查找</strong>：对要查找的关键字进行哈希函数的操作，得到映射的数组下标，然后在该下标指向的链表中查找指定关键字</li><li><strong>删除</strong>：找到对应的数组下标，遍历链表找到要删除的关键字的节点，然后判断它的存储个数(cnt)，如果大于1就让cnt-1，如果等于1就是删除该节点</li><li><strong>缺点</strong>：需要指针，给新单元分配空间需要时间，导致算法的速度减慢，与此同时还需要对链表的数据结构进行实现。</li></ol></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分离链接法</span><br><span class="hljs-comment">//定义链表</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">listnode</span>&#123;<br>    T data;<br>    listnode* next;<br>    <span class="hljs-type">int</span> cnt;<br>&#125;;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hashtable</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i*i &lt;= num; i++) &#123;<br>            <span class="hljs-keyword">if</span>(num % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//找出大于tablesize最近的素数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isPrime</span>(size)) &#123;<br>            size++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">loadfactor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>)count/(<span class="hljs-type">float</span>)tablesize;<br>    &#125;<br>    <span class="hljs-function">listnode&lt;T&gt;* <span class="hljs-title">createNode</span><span class="hljs-params">(T data)</span></span>&#123;<br>        listnode&lt;T&gt;* list=(listnode&lt;T&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listnode&lt;T&gt;));<br>        list-&gt;data=data;<br>        list-&gt;next= <span class="hljs-literal">nullptr</span>;<br>        list-&gt;cnt=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-built_in">hashtable</span>(<span class="hljs-type">int</span> size)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;tablesize=<span class="hljs-built_in">prime</span>(size);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-keyword">this</span>-&gt;tablesize;i++)&#123;<br>            listnode&lt;T&gt;*list=(listnode&lt;T&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listnode&lt;T&gt;));<br>            list-&gt;next=<span class="hljs-literal">NULL</span>;<br>            list-&gt;cnt=<span class="hljs-number">0</span>;<br>            v.<span class="hljs-built_in">push_back</span>(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//散列函数(哈希函数)，用于将关键字处理得到映射的数组下标，这里用了简单的哈希函数，在不同场景有不同的函数设计</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> data%<span class="hljs-keyword">this</span>-&gt;tablesize;<br>    &#125;<br><br>    <span class="hljs-function">listnode&lt;T&gt;* <span class="hljs-title">findnode</span><span class="hljs-params">(listnode&lt;T&gt;* head,T data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head!= <span class="hljs-literal">nullptr</span>)&#123;<br>            listnode&lt;T&gt;* p=head;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">if</span>(p-&gt;data==data)&#123;<br>                    <span class="hljs-keyword">return</span> p;<br>                &#125;<br>                p=p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">loadfactor</span>()&gt;<span class="hljs-number">1</span>||<span class="hljs-built_in">loadfactor</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> size= <span class="hljs-keyword">this</span>-&gt;tablesize;<br>            <span class="hljs-keyword">this</span>-&gt;tablesize=<span class="hljs-built_in">prime</span>(count*<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size;i&lt; <span class="hljs-keyword">this</span>-&gt;tablesize;i++)&#123;<br>                listnode&lt;T&gt;*list=(listnode&lt;T&gt;*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listnode&lt;T&gt;));<br>                list-&gt;next=<span class="hljs-literal">NULL</span>;<br>                list-&gt;cnt=<span class="hljs-number">0</span>;<br>                v.<span class="hljs-built_in">push_back</span>(list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> index= <span class="hljs-built_in">hash</span>(data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==v[index]-&gt;next)&#123;<br>            listnode&lt;T&gt;* list= <span class="hljs-built_in">createNode</span>(data);<br>            v[index]-&gt;next=list;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            listnode&lt;T&gt;* tail=<span class="hljs-built_in">findnode</span>(v[index]-&gt;next,data);<br>            <span class="hljs-keyword">if</span>(tail==<span class="hljs-literal">NULL</span>)&#123;<br>                listnode&lt;T&gt;* list= <span class="hljs-built_in">createNode</span>(data);<br>                listnode&lt;T&gt;* p=v[index]-&gt;next;<br>                v[index]-&gt;next=list;<br>                v[index]-&gt;next-&gt;next=p;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tail-&gt;cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;count++;<br>    &#125;<br>    <span class="hljs-function">listnode&lt;T&gt;* <span class="hljs-title">find</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-type">int</span> index= <span class="hljs-built_in">hash</span>(data);<br>        listnode&lt;T&gt;* p=<span class="hljs-built_in">findnode</span>(v[index]-&gt;next,data);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-keyword">this</span>-&gt;tablesize;i++)&#123;<br>            listnode&lt;T&gt;* p=v[i]-&gt;next;<br>            cout&lt;&lt;<span class="hljs-string">&quot;索引为&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span>(p== <span class="hljs-literal">nullptr</span>)&#123;<br>                cout&lt;&lt;endl;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (p!= <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;p-&gt;cnt;j++)<br>                    cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                p=p-&gt;next;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(T data)</span></span>&#123;<br>        <span class="hljs-type">int</span> index= <span class="hljs-built_in">hash</span>(data);<br>        listnode&lt;T&gt;* tail=v[index]-&gt;next;<br>        listnode&lt;T&gt;* p=v[index];<br>        <span class="hljs-keyword">while</span> (tail-&gt;next!= <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tail-&gt;data==data)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p=tail;<br>            tail=tail-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tail-&gt;data==data)&#123;<br>            <span class="hljs-keyword">if</span>(tail-&gt;cnt&gt;<span class="hljs-number">1</span>)&#123;<br>                tail-&gt;cnt--;<br>                count--;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            p-&gt;next=tail-&gt;next;<br>            <span class="hljs-keyword">delete</span> tail;<br>            count--;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br>    vector&lt;listnode&lt;T&gt;*&gt;v;<br>    <span class="hljs-type">int</span> tablesize;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>开放定址法</strong>：该算法的结构就只有<strong>一个数组</strong>。如果有<strong>哈希冲突发生</strong>，那么就尝试<strong>选择其他的单元</strong>，直到<strong>找到空单元就进行插入</strong>。函数F是冲突解决的办法。对于开放定址法来说，<strong>负载因子应该低于0.5</strong>（只要表足够大，这样总能够找到一个空单元才能解决冲突），而该方法的<strong>删除操作建议是懒惰删除</strong>，也就是<strong>删除对应的值，但是数组的长度不会变</strong>。开放地址法也分为三个方法：</p><blockquote><ol><li><strong>线性探测法</strong>：通过哈希函数，找到关键字对应的数组下标，如果<strong>该单元非空</strong>，则我们进行向后查找(<strong>也就是在这个数组下标的后面进行查找空单元</strong>)，如果<strong>达到数组的最后一个单元都没找到空单元</strong>就<strong>返回到数组的第一个单元(也就是数组下标为0)再进行向后查找</strong>；如果<strong>该单元是空单元</strong>，则<strong>直接进行插入</strong>。如果表可以多于一半被填满，线性探测就不是好方法，<strong>如果元素较少使用线性探测法</strong>，如果数据量大就不建议使用</li><li><strong>平方探测法</strong>：是用来消除线性探测中一次聚集问题的冲突解决方法，平方探测法就是冲突函数为二次函数的探测方法，<strong>流行的选择是F(i)&#x3D;i<sup>2</sup>(i为冲突次数)<strong>，通过哈希函数，找到关键字对应的数组下标，如果该</strong>单元是空的就插入</strong>，如果<strong>该单元非空</strong>，则<strong>该单元的冲突次数+1也就是i&#x3D;1</strong>，通过<strong>F(i)计算得到向后移动的单元</strong>，所以算出等于1就向后移动一单元，如果所处的单元还是非空，则冲突次数再次+1,然后再向后移动F(i)位，i为2则移动四个单元(<strong>移动的单元不是从所处的单元在移动4位，而是从原本的单元也就是开始通过哈希函数计算出来的单元开始移动四位</strong>)，如此<strong>递推下去，直到找到空的单元</strong>，如果<strong>达到最后一单元</strong>，则从<strong>数组下标0重新开始</strong>。</li><li><strong>双散列</strong>：双散列的意思是映射数组下标时，使用<strong>两个散列函数进行计算映射位置</strong>，对于双散列，<strong>流行的一种选择是F(i)&#x3D;i*hash<sub>2</sub>(X)<strong>，hash<sub>2</sub>(X)为第二个哈希函数，i为探测次数，也就是当我</strong>插入时</strong>，通过<strong>第一个哈希函数计算出映射的数组下标</strong>，如果该单元是<strong>空单元</strong>，就<strong>直接插入</strong>，如果<strong>非空</strong>，则<strong>通过第二哈希函数计算向后移动的位数</strong>，比方说，当我插入映射到数组下标8的位置，但是下标为8的单元非空，则需要向后移动，而此时i为1，然后通过哈希2计算出移动位置，如果移动后的单元还是非空，则此时i等于2，计算出移动位数后，需要重新回到数组下标8进行移动，直到找到空单元为止。<strong>哈希2函数的选取很重要</strong>，如果选择的不好则将会是灾难性的，像<strong>hash<sub>2</sub>(X)&#x3D;R-(X mod R)这种函数会比较好</strong>，R的选择需要根据情况设定，然后<strong>保证表的大小为素数很重要</strong></li></ol></blockquote></li><li><p><strong>再散列</strong>：对于<strong>使用平方探测的开放定址法</strong>，如果<strong>表的元素填的太满</strong>，性能则会大大降低，则我们就<strong>新建立一个原来的散列表的两倍大小的散列表(并且使用一个相关的新散列函数)<strong>，然后</strong>扫描原始的散列表</strong>，通过新的散列函数<strong>计算每个已经插入在原表中的数据的新的映射下标并将其插入新表之中</strong>，双散列建立的时机可以实时根据负载因子决定，当负载因子到达指定值就进行再散列操作。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//开放定址法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hashtable</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>&#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isprime</span>(size))&#123;<br>            size++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-built_in">hashtable</span>(<span class="hljs-type">int</span> size)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;tablesize= <span class="hljs-built_in">prime</span>(size);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tablesize;i++)&#123;<br>            v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//线性探测法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash1</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-type">int</span> index=key%tablesize;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (v[index]!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">1</span>)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;没有空余的位置插入&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index==tablesize<span class="hljs-number">-1</span>)&#123;<br>                cnt++;<br>                index=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-comment">//平方探测法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash2</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-type">int</span> index=key%tablesize;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,n=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (v[index]!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;没有空余的位置插入&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            cnt++;<br>            cnt*=cnt;<br>            index=index+cnt-n;<br>            n=cnt;<br>            <span class="hljs-keyword">if</span>(index&gt;tablesize<span class="hljs-number">-1</span>)&#123;<br>                i++;<br>                index=index-tablesize;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">localfactor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>)count/(<span class="hljs-type">float</span>)tablesize;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">localfactor</span>()&gt;<span class="hljs-number">0.5</span>||<span class="hljs-built_in">localfactor</span>()==<span class="hljs-number">0.5</span>)&#123;<br>            <span class="hljs-type">int</span> size=tablesize*<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=tablesize;i&lt;size;i++)&#123;<br>                v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">NULL</span>);<br>            &#125;<br>            tablesize=size;<br>        &#125;<br>        <span class="hljs-type">int</span> index=<span class="hljs-built_in">hash2</span>(key);<br>        <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>)&#123;<br>            v[index]=key;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-type">int</span> index=key%tablesize;<br>        <span class="hljs-type">int</span> size=tablesize;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index;i&lt;=size+index;i++)&#123;<br>            <span class="hljs-keyword">if</span>(v[i]==key)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i==tablesize<span class="hljs-number">-1</span>)&#123;<br>                size=<span class="hljs-number">0</span>;<br>                i=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;为找到&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-type">int</span> index=<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>)&#123;<br>            count--;<br>            v[index]=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tablesize;i++)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;索引为&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;v[i]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-type">int</span> tablesize;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><strong>可扩散列</strong>：当<strong>处理数据量太大以至于装不进主存的情况下</strong>，此时主要<strong>考虑是检索数据所需的磁盘存取次数</strong>，而可扩散列，它允许用两次磁盘访问就能够执行一次查找操作，插入操作也是很少的磁盘访问。可扩散列有点<strong>类似于B树的结构</strong>。<strong>可扩散列无法存在重复关键字</strong></p><blockquote><ol><li>在可扩散列中，我们用<strong>D表示根所使用的比特数(也称其为目录)<strong>，</strong>目录的所存的元素个数为2<sup>D</sup><strong>，</strong>d<sub>L</sub>为树叶节点中的元素共有的最高位位数，因此d<sub>L</sub>应该小于等于D</strong></li><li><strong>D就是用来区分存储节点的位置的依据</strong>，例如我们的数据由前俩个比特进行区分，则该结构的节点应该能够存储4个元素，然后d<sub>L</sub>应该等于2，因为数据需要根据前两位跟目录的元素进行匹对来存储到对应的节点，因此它的共有最高位应该为2，如图5-23</li><li>如果插入数据时，<strong>节点元素已经满了，我们就需要进行分裂节点来存储</strong>，例如上述讲的图5-23当D&#x3D;2时，我们插入100100时，发现10为根节点的叶子节点元素已经满了，就分裂该叶子节点，分裂完发现根节点也满了则需要对根节点分裂，<strong>因此根节点分裂后应该以3比特进行将数据分开存储，因为2<sup>3</sup>等于8，因此根节点分裂后为8个元素(如图5-24)<strong>，但是</strong>叶子节点只有5个</strong>，因此有<strong>一些根节点跟其他根节点共用一个叶子节点，直到再次插入让它们共用的节点，才进行更改根节点指向(如图5-25)。</strong></li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529619.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529620.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191529621.png" alt="image"></p></li></ul><h3 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆(优先队列)"></a>堆(优先队列)</h3><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p><strong>概念</strong>：</p><ul><li><p>优先队列是一个根据优先性而先去执行操作的一种特殊队列，平常队列是先进先出，但是优先队列是根据优先级选择先出的元素。优先队列的主要操作有插入和删除最小值</p></li><li><p><strong>堆(heap)<strong>通常是指</strong>二叉堆</strong>，因为二叉堆的使用次数最频繁，所以我们平常认为的堆就是二叉堆</p></li><li><p><strong>二叉堆</strong>：二叉堆是由<strong>一颗完全二叉树实现</strong>的，完全二叉树是**一颗底层必须从左往右依次插入且底层以上的节点都是填满的树(最后一层也就是叶子节点可以不是填满的，但是已经插入的元素必须是从左到右的中间不空缺元素的)**称为完全二叉树</p></li><li><p>完全二叉树是一个<strong>很有规律的树</strong>，因此<strong>用一个动态数组实现是效率最好的选择</strong>，在动态数组中是按照<strong>从上到下从左到右依次插入数组</strong>中，数组下标为0处不放元素。</p><blockquote><p>用数组实现的完全二叉树的性质有：</p><ol><li>对于<strong>数组中任意一个位置i上的元素</strong>，其<strong>左儿子在数组位置2i上</strong>，<strong>右儿子在</strong>左儿子后的单元也就是<strong>数组下标为(2i+1)的位置</strong>，它的<strong>父亲在i&#x2F;2的位置上</strong>。</li><li><strong>数组下标为0的地方是不放我们要存的元素的</strong></li></ol></blockquote></li></ul><p><strong>性质</strong>：</p><ul><li>堆也就是通常认为的二叉堆(binary heap)，是由一颗完全二叉树实现的</li><li>堆中的主要操作有插入和删除最小值操作，<strong>堆的删除其实就是删除最小值而不是删除指定值</strong></li><li>堆有<strong>堆序性质</strong>，也就是<strong>堆中的任意子树也是一个堆</strong>，因此<strong>任意节点就应该小于它的子节点</strong>，因为堆需要快速查找最小元，因此<strong>我们将最小元放在根节点上</strong>。</li><li>其<strong>结构体</strong>应该包含<strong>一个数组(动态)<strong>，</strong>堆中存储的有效元素个数</strong>，<strong>数组的容量</strong>以便于扩容</li></ul><p><strong>最大堆&#x2F;大根堆</strong>：任意节点应该<strong>大于</strong>它的所有后裔</p><p><strong>最小堆&#x2F;小根堆</strong>：任意节点应该<strong>小于</strong>它的所有后裔</p><p>**插入操作(上浮)**：</p><ul><li>先遵从<strong>堆从上到下，从左到右依次插入</strong>，我们将数据按照这个准则插入到数组。</li><li>然而，插入后，我们还需要进行<strong>检查这个堆是否有堆序性</strong>，如果没有就需要进行调整</li><li><strong>插入数据跟根节点进行比较，如果根节点的值比插入数据大，就需要交换，然后一路向上检查比较，直到根节点。</strong></li></ul><p>**删除操作(下沉)**：</p><ul><li>堆的<strong>删除操作是删除最小值的操作</strong>，而不是删除指定值的操作</li><li>我们创建堆时，都将<strong>最小值放到根节点</strong>，因此删除我们只需要将根节点删除掉</li><li>但是删除根节点后，我们的堆序性就无法保证，如何保证堆序性以及堆的性质(也就是完全二叉树的性质)呢</li><li>我们<strong>需要将根节点的值与叶子层的最右边元素进行交换</strong>，然后<strong>删除交换后处在叶子节点(也就是原来的根节点)的节点</strong>，然后让<strong>现在的根节点跟左右子节点的最小节点比较</strong>，如果<strong>大于就交换，直到检查到叶子节点</strong>，则就调整成功了。</li></ul><p><strong>构建堆</strong></p><ul><li>构建堆的操作就<strong>是将一个无序的树，构造成一个堆</strong></li><li>一个堆满足完全二叉树的特性以及堆序性，因此我们<strong>需要对这个无序树进行调整</strong>，让其成为一个堆。</li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">heap</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">heap</span>(<span class="hljs-type">int</span> maxsize)&#123;<br>        key=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[maxsize+<span class="hljs-number">1</span>];<br>        key[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;maxsize+<span class="hljs-number">1</span>;i++)&#123;<br>            key[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        size=<span class="hljs-number">0</span>;<br>        capacity=maxsize;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">if</span>(key[i]==data)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        key[size+<span class="hljs-number">1</span>]=data;<br>        <span class="hljs-type">int</span> index=size+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> i=index;<br>            index=index/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(key[index]&gt;key[i])&#123;<br>                <span class="hljs-type">int</span> temp=key[index];<br>                key[index]=key[i];<br>                key[i]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(size==capacity)&#123;<br>            <span class="hljs-type">int</span> *an=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>*capacity];<br>            capacity=capacity*<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=size;i++)&#123;<br>                an[i]=key[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span>[] key;<br>            key=an;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(key[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)&#123;<br>            key[<span class="hljs-number">1</span>]=data;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">adjust</span>(data);<br>        &#125;<br>        size++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deladjust</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index*<span class="hljs-number">2</span>&lt;=size)&#123;<br>            <span class="hljs-type">int</span> mn;<br>            <span class="hljs-keyword">if</span>(key[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                mn=index*<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key[index*<span class="hljs-number">2</span>]&gt;key[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])&#123;<br>                mn=index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mn=index*<span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(key[index]&gt;key[mn])&#123;<br>                <span class="hljs-type">int</span> temp=key[index];<br>                key[index]=key[mn];<br>                key[mn]=temp;<br>            &#125;<br>            <span class="hljs-built_in">deladjust</span>(mn);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delmin</span><span class="hljs-params">()</span></span>&#123;<br>        key[<span class="hljs-number">1</span>]=key[size];<br>        key[size]=<span class="hljs-number">0</span>;<br>        size--;<br>        <span class="hljs-built_in">deladjust</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>            key[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        size=<span class="hljs-number">0</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;成功清除堆中数据&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>,ans=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>            cout&lt;&lt;key[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span>(i==ans)&#123;<br>                cout&lt;&lt;endl;<br>                ans=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,cnt)+i;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *key;    <span class="hljs-comment">//动态数组，用来存储树节点的元素</span><br>    <span class="hljs-type">int</span> size;    <span class="hljs-comment">//堆中存在的有效元素个数</span><br>    <span class="hljs-type">int</span> capacity;    <span class="hljs-comment">//数组容量</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="d-堆"><a href="#d-堆" class="headerlink" title="d-堆"></a>d-堆</h4><p><strong>概念</strong>：</p><ul><li><strong>d-堆</strong>是二叉堆的简单推广，<strong>它的所有的节点都有d个子节点</strong>，<strong>d-堆的底层也是由一颗完全树构成的</strong>，二叉堆是由完全二叉树构成，3-堆则就是由完全三叉树构成</li><li>当<strong>堆太大不能完全装入主存的时候</strong>，<strong>d-堆就很有用</strong>，因为<strong>d-堆能够以与B-树大致相同的方式发挥作用</strong></li><li>d-堆的高度比较浅</li><li>d-堆的性质跟二叉堆相同。因为二叉堆是d-堆的一种特殊情况。</li></ul><h4 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h4><p><strong>概念</strong>：</p><ul><li>左式堆是<strong>一种能够高效的支持合并操作的堆</strong>，左式堆的<strong>底层也是由二叉树实现</strong>，但是左式堆不是平衡的(<strong>不由完全二叉树实现的</strong>)，<strong>左式堆趋向于不平衡</strong>。</li><li>左式堆也像二叉堆一样拥有着堆的特性(有序性和结构性)，<strong>左式堆是最小堆</strong></li><li>左式堆是一个<strong>拥有堆序性的二叉树(不是二叉堆)加上NPL特性的一棵树</strong>，<strong>任意节点X的NPL(X)(零路径长)为从X到一个没有两个儿子的节点的最短路径的长，因此，具有0个或1个儿子的节点的Npl为0，而Npl(NULL)&#x3D;-1.</strong></li></ul><p><strong>性质</strong>：</p><ul><li><strong>任意一个节点的零路径长比它的子节点的零路径长的最小值+1</strong></li><li><strong>对于堆中的每一个节点X，左儿子的零路径长大于等于右儿子的零路径长</strong></li><li>在右路径上有r个节点的左式树必然至少有2<sup>r</sup>-1个节点</li><li>对左式堆的右路径的插入和合并操作可能会破坏左式堆的性质，需要进行调整</li></ul><p><strong>合并操作</strong></p><ul><li>插入其实就是合并的一个特殊情况</li><li>如果两个左式堆合并，有一个堆为空就返回另外一个堆，否则<strong>比较两个堆的根值</strong></li><li><strong>递归进去</strong>，我们<strong>将大的根值的堆与小的根值的堆的右子堆合并</strong></li><li>然后递归返回后，**将新的堆作为原来小的根值的堆的右孩子(也叫合并)**。</li><li><strong>如果这样形成的堆的右子堆的零路径长大于左子堆的，就将左子堆跟右子堆交换，并且更新零路径长，就完成了合并的操作。</strong></li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">heapNode</span>&#123;<br>    <span class="hljs-type">int</span> data;    <span class="hljs-comment">//数据</span><br>    heapNode* left;    <span class="hljs-comment">//左子节点指针</span><br>    heapNode* right;   <span class="hljs-comment">//右子节点指针</span><br>    <span class="hljs-type">int</span> Npl;     <span class="hljs-comment">//零路径长</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">leftheap</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">leftheap</span>()&#123;<br>        root=<span class="hljs-keyword">new</span> heapNode;<br>        root-&gt;left= <span class="hljs-literal">nullptr</span>;<br>        root-&gt;right= <span class="hljs-literal">nullptr</span>;<br>        root-&gt;data=INT_MAX;<br>        root-&gt;Npl=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> heapNode;<br>        p-&gt;data=data;<br>        p-&gt;left= <span class="hljs-literal">nullptr</span>;<br>        p-&gt;right= <span class="hljs-literal">nullptr</span>;<br>        p-&gt;Npl=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">merge</span><span class="hljs-params">(heapNode* h1,heapNode* h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h1-&gt;left== <span class="hljs-literal">nullptr</span>)&#123;<br>            h1-&gt;left=h2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            h1-&gt;right= <span class="hljs-built_in">findmerge_node</span>(h1-&gt;right,h2);<br>            <span class="hljs-keyword">if</span>(h1-&gt;left-&gt;Npl&lt;h1-&gt;right-&gt;Npl)&#123;<br>                heapNode* p=h1-&gt;left;<br>                h1-&gt;left=h1-&gt;right;<br>                h1-&gt;right=p;<br>            &#125;<br>            h1-&gt;Npl=h1-&gt;right-&gt;Npl+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h1;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">findmerge_node</span><span class="hljs-params">(heapNode* h1,heapNode* h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==h1)&#123;<br>            <span class="hljs-keyword">return</span> h2;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==h2)&#123;<br>            <span class="hljs-keyword">return</span> h1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h1-&gt;data&lt;h2-&gt;data)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(h1,h2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(h2,h1);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        heapNode* add= <span class="hljs-built_in">createNode</span>(data);<br>        <span class="hljs-keyword">if</span>(root-&gt;data==INT_MAX)&#123;<br>            root=add;<br>        &#125; <span class="hljs-keyword">else</span><br>            root=<span class="hljs-built_in">findmerge_node</span>(root,add);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delmin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        heapNode* h1=root-&gt;left;<br>        heapNode* h2=root-&gt;right;<br>        <span class="hljs-keyword">delete</span> root;<br>        root= <span class="hljs-built_in">findmerge_node</span>(h1,h2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">print</span><span class="hljs-params">(heapNode* p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p!= <span class="hljs-literal">nullptr</span>)&#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-built_in">print</span>(p-&gt;left);<br>            <span class="hljs-built_in">print</span>(p-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(root);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    heapNode* root;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h4><p><strong>概念</strong>：</p><ul><li><strong>斜堆</strong>是<strong>左式堆的自调节形式</strong>，斜堆和左式堆间的关系类似于伸展树和AVL树间的关系</li><li>斜堆是<strong>具有堆序性的二叉树</strong>，但是<strong>不存在对树的结构限制</strong></li><li>不同于左式堆，<strong>关于任意节点的零路径长的任何信息都不保留，因为斜堆的右路径在任何时刻都可以任意长</strong></li></ul><p><strong>合并操作</strong></p><ul><li>斜堆的合并大概都跟左式堆的合并操作一样，但是交换操作不一样，<strong>斜堆的交换是无条件的</strong></li><li><strong>就是说当进行将大的根值的堆与小的根值的堆的右子堆合并后，我们就需要进行左子树跟右子树交换的操作，并不是只有到最后小的根值的堆跟新的堆合并后在进行交换</strong></li><li>就是<strong>每个合并的步骤就需要交换左右子树</strong>。</li></ul><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">heapNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    heapNode* left;<br>    heapNode* right;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">skewheap</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">skewheap</span>()&#123;<br>        root=<span class="hljs-keyword">new</span> heapNode;<br>        root-&gt;data=INT_MAX;<br>        root-&gt;left= <span class="hljs-literal">nullptr</span>;<br>        root-&gt;right= <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        <span class="hljs-keyword">auto</span> p=<span class="hljs-keyword">new</span> heapNode;<br>        p-&gt;data= data;<br>        p-&gt;left= <span class="hljs-literal">nullptr</span>;<br>        p-&gt;right= <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">merge</span><span class="hljs-params">(heapNode* h1,heapNode* h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(h1-&gt;left== <span class="hljs-literal">nullptr</span>)&#123;<br>            h1-&gt;left=h2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            h1-&gt;right= <span class="hljs-built_in">findmerge_node</span>(h1-&gt;right,h2);<br>            heapNode* p=h1-&gt;left;<br>            h1-&gt;left=h1-&gt;right;<br>            h1-&gt;right=p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h1;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">findmerge_node</span><span class="hljs-params">(heapNode* h1,heapNode* h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==h1)&#123;<br>            <span class="hljs-keyword">return</span> h2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==h2)&#123;<br>            <span class="hljs-keyword">return</span> h1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h1-&gt;data&lt;h2-&gt;data)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(h1,h2);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(h2,h1);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>&#123;<br>        heapNode* add= <span class="hljs-built_in">createNode</span>(data);<br>        <span class="hljs-keyword">if</span>(root-&gt;data==INT_MAX)&#123;<br>            root=add;<br>        &#125;<span class="hljs-keyword">else</span><br>            root=<span class="hljs-built_in">findmerge_node</span>(root,add);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delmin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span>==root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        heapNode* h1=root-&gt;left;<br>        heapNode* h2=root-&gt;right;<br>        <span class="hljs-keyword">delete</span> root;<br>        root= <span class="hljs-built_in">findmerge_node</span>(h1,h2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> root-&gt;data;<br>    &#125;<br>    <span class="hljs-function">heapNode* <span class="hljs-title">print</span><span class="hljs-params">(heapNode* p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(p!= <span class="hljs-literal">nullptr</span>)&#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-built_in">print</span>(p-&gt;left);<br>            <span class="hljs-built_in">print</span>(p-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(root);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    heapNode* root;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><strong>概念</strong>：</p><ul><li>一个<strong>图(graph)<strong>G&#x3D;(V,E)<strong>由顶点集V和边集E组成</strong>，</strong>每一条边就是一个点对(u,w)，其中u，w∈V</strong>，有时边称作弧，如果<strong>点对是有序的，那么组成的图叫做有向图，反之就是无向图</strong>。有时候<strong>边还具有第三种成分，称作权或值。</strong></li><li>图中的<strong>一条路径是一个顶点序列w1,w2,w3….wn，使得(w<sub>i</sub>,w<sub>i+1</sub>)∈E，1&lt;i&lt;N；</strong>这样一<strong>条路径的长度就为该路径的边数</strong>。如果图中<strong>含有一条从顶点到自身的边(u,u)，那么路径v,v称作为环</strong>。而我们讨论的图一般是无环的。</li><li><strong>简单路径是一条路径上的所有顶点都是互异的，但第一个顶点和最后一个顶点可能相同。</strong></li><li><strong>当一个长至少为1的路径中的第一个顶点等于最后一个顶点时，则称为圈</strong>，对于<strong>无向图的圈，要求边是互异的</strong>，意思就是u到v跟v到u是一条边形成的不满足无向图的圈。</li><li>无向图中的<strong>每一个顶点到其他顶点都有一条路径的称作这个无向图连通的，具有这种性质的有向图称为强连通，反之就是弱连通</strong>。</li><li><strong>完全图的每一对顶点间都存在一条边的图</strong></li></ul><p><strong>图的表示</strong>：</p><ul><li><strong>表示的图的一种简单方法</strong>是<strong>使用一个二维数组</strong>，称为<strong>邻接矩阵表示法</strong>，<strong>对于每条边(u,v)，我们将数组an[u] [v]&#x3D;1</strong>；<strong>否则数组的元素等于0</strong>，如果<strong>边有权</strong>，我们就<strong>令an[u] [v]的值等于该权</strong>，而<strong>用一个很大或者很小的权作为标记表示不存在的边。</strong>但是该方法的空间代价太大，如果图是稠密的，可以用这种方法。空间需求O(|V|²)；</li><li>如果<strong>图是稀疏</strong>的，我们就<strong>用邻接表(数组+链表)来表示</strong>，数组的<strong>元素个数代表着图中有多少个节点</strong>，<strong>每个索引的链表存该索引顶点邻接的所有顶点</strong>。顶点的<strong>名称不一定是数字</strong>，因此<strong>需要将顶点通过哈希函数映射到数组中</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>后台开发</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程</title>
    <link href="/2024/05/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/19/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>概念</strong>：</p><ul><li><strong>Linux系统编程就是基于linux提供的系统调用函数接口来进行编程</strong></li><li><strong>系统调用严格意义来讲是系统函数而非真系统调用</strong>，比方说<strong>read函数，他其实是将真正的系统调用函数sys_read函数封装了一层来提供的</strong>，所以read函数只能说是系统函数</li><li>对于Linux的C++开发程序员来说，在Linux系统下开发以及懂得使用Linux的系统函数尤为重要</li></ul><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p><strong>概念</strong>：</p><ul><li><code>静态库</code>是<strong>在可执行程序运行前就加入到执行码中，成为执行程序的一部分</strong></li><li>在生成可执行程序后，<strong>可执行程序的占用空间包括了静态库的大小</strong></li><li>静态库<strong>适用于对于空间要求较低，对时间要求较高的核心程序</strong></li></ul><p><strong>制作静态库及使用</strong>：</p><ol><li><p>准备好要制作静态库的程序文件和声明文件.h</p></li><li><p><code>生成目标文件</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c 程序文件.cpp -o 程序文件.o<br>//可以生成多个目标文件，最后将这些全部做到一个静态库中<br></code></pre></td></tr></table></figure></li><li><p><code>生成静态库</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ar rcs lib库名.a 目标文件<span class="hljs-number">1.</span>o 目标文件<span class="hljs-number">2.</span>o ...<br></code></pre></td></tr></table></figure></li><li><p><code>使用静态库</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在要使用静态库程序中引用.h文件</span><br><span class="hljs-comment">//然后编译程序文件时使用静态库</span><br><span class="hljs-comment">//c++</span><br>g++ 运行程序.cpp lib库名.a -o 运行程序<br><br>    <br><span class="hljs-comment">//c</span><br>gcc 运行程序.cpp lib库名.a -o 运行程序<br></code></pre></td></tr></table></figure></li></ol><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p><strong>概念</strong>：</p><ul><li><code>动态库(共享库)</code>是<strong>在执行程序启动时加载到执行程序中，可以被多个执行能够程序共享使用</strong></li><li><strong>动态库是不会占用执行程序空间</strong>，也就是执行程序中的占用空间里不包含动态库，而可执行程序可调用动态库</li><li>动态库<strong>适用于对空间要求较高，对时间要求较低的核心程序</strong></li></ul><p><strong>制作动态库及使用</strong>：</p><ol><li><p>准备好要制作动态库的程序文件和声明文件.h</p></li><li><p><code>生成与位置无关的代码将.c或.cpp生成.o文件</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c 文件.cpp -o 文件.o -fPIC<br>//-fPIC参数将会生成与位置无关代码<br></code></pre></td></tr></table></figure></li><li><p><code>制作动态库</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -shared -o lib库名.so 目标文件.o 目标文件1.o ...<br></code></pre></td></tr></table></figure></li><li><p><code>使用动态库</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">//编译可执行程序时，指定所使用的动态库<br>//-l：指定库名<br>//-L：指定库路径<br><span class="hljs-meta prompt_">#</span><span class="language-bash">c</span><br>gcc 可执行程序.cpp -o 可执行程序.out -l 库名 -L 库路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">c++</span><br>gcc 可执行程序.cpp -o 可执行程序.out -l 库名 -L 库路径<br></code></pre></td></tr></table></figure></li><li><p>运行可执行文件.out</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">报错</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">./test.out: error <span class="hljs-keyword">while</span> loading shared libraries: libadd.so: cannot open shared object file: No such file or directory</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>使用动态库后的.out程序运行报错解决</strong>：</p><ul><li><p>原因：</p><blockquote><p><strong>链接器</strong>：工作于链接阶段，工作时需要-l和-L</p><p><strong>动态链接器</strong>：工作于程序运行阶段，<strong>工作时需要提供动态库所在目录位置(会去默认目录去找)</strong></p><p>原因：因为使用动态库，所使用的是动态链接器，<strong>则工作时需要找到动态库，因为他在默认目录未找到，所以导致报错</strong></p></blockquote></li><li><p>解决：</p><blockquote><ol><li><p><strong>设置临时环境变量</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LD_LIBRARY_PATH=库路径<br><br>./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行成功</span><br></code></pre></td></tr></table></figure></li><li><p>**编辑终端配置文件(永久)**：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">去到你对应的终端，bash就是.bashrc,zsh就是.zshrc</span><br>vim .zshrc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加,库路径建议使用绝对路径</span><br>export LD_LIBRARY_PATH=库路径<br><span class="hljs-meta prompt_">#</span><span class="language-bash">保存</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">生效配置文件</span><br>source .zshrc<br><br>./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行成功</span><br></code></pre></td></tr></table></figure></li></ol></blockquote></li></ul><h2 id="open-close函数"><a href="#open-close函数" class="headerlink" title="open&#x2F;close函数"></a>open&#x2F;close函数</h2><p><strong>函数原型</strong>：</p><ul><li><p><code>int open(const char *pathname,int flags)</code>：<strong>用来打开一个文件和创建一个文件(如果没有该文件就创建)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:打开文件的路径名;<br><br>flags:操作标志参数,多个可以使用|包括;<br><span class="hljs-comment">//flags参数选择:</span><br>O_RDONLY:只读;<br>O_WRONLY:只写;<br>O_RDWR:读和写;<br>O_APPEND:追加;<br>O_CREAT:创建;<br>O_EXCL:文件是否存在;<br>O_TRUNC:截断;<br>O_NONBLOCK:非阻塞;<br><span class="hljs-comment">//返回值</span><br>成功:返回新的文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li><li><p><code>int open(const char *pathname,int flags,mode_t mode)</code>：<strong>用来打开一个文件和创建一个文件(如果没有该文件就创建)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">int</span> flags,<span class="hljs-type">mode_t</span> mode)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//参数</span></span><br><span class="hljs-function">pathname:打开文件的路径名;</span><br><br>flags:操作标志参数,多个可以使用|包括;<br><span class="hljs-comment">//flags参数选择:</span><br>O_RDONLY:只读;<br>O_WRONLY:只写;<br>O_RDWR:读和写;<br>O_APPEND:追加;<br>O_CREAT:创建;<br>O_EXCL:文件是否存在;<br>O_TRUNC:截断;<br>O_NONBLOCK:非阻塞;<br><br>mode:为创建新文件设置权限参数,权限受到umask影响(默认文件操作权限);<br><span class="hljs-comment">//例如：rw-r--r-- 0644</span><br><span class="hljs-comment">//文件权限=mode&amp;(~umask)</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回新的文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li><li><p><code>int close(int fd)</code>：<strong>关闭打开的文件描述符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要关闭文件的文件描述符;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li></ul><p><strong>open常见错误</strong>：</p><ul><li>打开文件不存在(文件不存在，并且不设置创建参数)</li><li>以写方式打开只读文件(打开文件没有对应权限)</li><li>以只写方式打开目录</li></ul><h2 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read&#x2F;write函数"></a>read&#x2F;write函数</h2><p><strong>函数原型</strong>：</p><ul><li><p><code>ssize_t read(int fd,void *buf,size_t count)</code>：原本<strong>是用于文件读取的操作，但是也可以用与socket的接收以及读取数据的操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:是一个指向读或写数据的缓冲区指针;<br><br>count:缓冲区长度;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回读到的字节数,<span class="hljs-number">0</span>，表示已经到达文件末尾;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br><span class="hljs-number">-1</span>:<br>- 如果read返回<span class="hljs-number">-1</span>并且errno等于EAGIN或EWOULDBLOCK,说明不是read失败而是read以非阻塞读文件并且文件无数据<br>- 如果errno==EINTR，被异常终止，需要重启<br>- 如果errno==ECONNRESET,说明连接被重置<br>    <br><span class="hljs-comment">//创建缓冲区，可以使用BUFSIZ，BUFSIZ=4096</span><br><span class="hljs-type">char</span> buf[BUFSIZ];<br></code></pre></td></tr></table></figure></li><li><p><code>ssize_t write(int fd,const void *buf,size_t count)</code>：<strong>用于进行文件写数据的操作</strong>，但是<strong>也可以用于socket通信的发送以及写数据的操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:待写出数据的缓冲区;<br><br>count:数据大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回写入的字节数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li></ul><p><strong>实现cp命令</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> fd1=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd1==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open argv1 error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> fd2=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd2==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open argv2 error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>((n=<span class="hljs-built_in">read</span>(fd1,buf,<span class="hljs-number">1024</span>))!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">write</span>(fd2,buf,n);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd1);<br>    <span class="hljs-built_in">close</span>(fd2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行</span><br><span class="hljs-comment">//g++ test.cpp -o test</span><br><span class="hljs-comment">//./test add.h add1.h</span><br><span class="hljs-comment">//发现add1.h的内容跟add.h一样</span><br></code></pre></td></tr></table></figure><h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p><strong>函数原型</strong>：</p><p><code>off_t lseek(int fd, off_t offset, int whence)</code>：<strong>用于读写文件偏移</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:文件描述符;<br><br>offset:偏移量;<br><br>whence:起始偏移位置;<br><span class="hljs-comment">//whence参数选择</span><br>SEEK_SET:文件开头;<br>SEEK_CUR:当前位置;<br>SEEK_END:文件末尾;<br><br><span class="hljs-comment">//返回值</span><br>成功:较起始位置向后偏移量;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>lseek同样允许超过文件结尾设置偏移量，文件会因此扩展</li><li>注意文件”读”和”写”使用同一偏移位置</li></ul></blockquote><p><strong>应用场景</strong>:</p><ul><li>文件的”读”和”写”使用同一偏移位置</li><li>使用lseek获取文件大小(lseek(fd,0,SEEK_END);)</li><li>使用lseek扩展文件大小，要想使文件大小真正扩展，必须引起IO操作</li></ul><h2 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h2><p><strong>概念</strong>：</p><ul><li>Linux中也提供了一种用来查看错误原因的变量以及函数</li><li><strong>errno是Linux中的一个全局变量，当你程序发生报错时，会进行设置errno来告诉你报错的原因，而errno是一个整数</strong>，这个整数会对应着一个错误原因</li><li><strong>strerror函数是可以解读errno来返回这个errno所对应的原因</strong></li><li><strong>perror函数是可以设置报错提示，并且将errno的错误原因一起输出</strong></li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>char *strerror(int errnum)</code>：<strong>可以解读errno来返回这个errno所对应的原因</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>errnum:errno;<br></code></pre></td></tr></table></figure></li><li><p><code>void perror(const char *s)</code>：<strong>可以设置报错提示，并且将errno的错误原因一起输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;cstdio&gt;</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>s:要设置的报错提示;<br></code></pre></td></tr></table></figure></li></ul><h2 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h2><p><strong>概念</strong>：</p><ul><li><code>阻塞</code>：当<strong>进程调用一个阻塞的系统函数时，该进程将会置于睡眠状态</strong>，这时内核调度其他进程运行，<strong>直到该进程等待的时间发生(<strong>比如网络上接收到包，或者调用sleep指定的睡眠时间到了)，</strong>它才可能继续运行</strong></li><li><code>非阻塞</code>：当调用非阻塞的系统函数时，<strong>如果不能立即得到结果，则不会阻塞当前线程或进程</strong>，但是<strong>调用者需要定时轮询查看处理状态</strong></li><li>产生阻塞的场景：读设备文件(dev目录)、读网络文件等等</li><li><code>阻塞、非阻塞是文件的属性</code>，而文件属性是可以修改的</li></ul><p><strong>阻塞示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> n;<br>    n=<span class="hljs-built_in">read</span>(STDIN_FILENO,buf,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read STDIN_FILENO&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//如果我不按键盘输入东西，它将会一直等待也就是阻塞</span><br></code></pre></td></tr></table></figure><p><strong>阻塞示例2</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> fd,n;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NOBLOCK);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open /dev/tty&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>  <br>tryagain:<br>    n=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(errno!=EAGAIN)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read /dev/tty&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-built_in">write</span>(STDOUT_FILENO,<span class="hljs-string">&quot;try again\n&quot;</span>,<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;try again\n&quot;</span>));<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">goto</span> tryagain;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//虽然设置了非阻塞文件属性，但是没有设置超时限制和结束限制，导致一直阻塞</span><br></code></pre></td></tr></table></figure><p><strong>非阻塞示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TRY <span class="hljs-string">&quot;try again\n&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TIMEOUT <span class="hljs-string">&quot;time out\n&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> fd,n,i;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open /dev/tty&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open /dev/tty ok... %d\n&quot;</span>,fd);<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        n=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(errno!=EAGAIN)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read /dev/tty&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">write</span>(STDOUT_FILENO,MSG_TRY,<span class="hljs-built_in">strlen</span>(MSG_TRY));<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)&#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,MSG_TIMEOUT,<span class="hljs-built_in">strlen</span>(MSG_TIMEOUT));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//这种方式也不是最优的，最优的应该为响应的模式，当你们有需求我才响应，而不是我以轮询的方式去查看</span><br></code></pre></td></tr></table></figure><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p><strong>概念</strong>：</p><ul><li><code>fcntl函数</code>可以<strong>用来改变一个已经打开的文件的访问控制属性</strong></li></ul><p><strong>函数原型</strong>：</p><p><code>int fcntl(int fildes,int cmd,.../* arg */)</code>：可以<strong>用来改变一个已经打开的文件的访问控制属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">int</span> cmd, ...<span class="hljs-comment">/* arg */</span>)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fildes:要操作的文件描述符;<br><br>cmd:函数行为参数;<br><span class="hljs-comment">//行为参数选择:</span><br>F_GETFL:获取文件属性;<br>F_SETFL:设置文件属性;<br><br>...:可变参数，也就是设置文件属性时可以加入文件属性作为第三个参数;<br><br><br><span class="hljs-comment">//返回值</span><br>F_GETFL:会返回文件属性;<br><br>F_SETFL:<span class="hljs-number">-1</span>以外的值;<br></code></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="stat-lstat函数"><a href="#stat-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h3><p><strong>函数原型</strong>：</p><ul><li><code>int stat(const char *path,struct stat *buf)</code>：<strong>获取文件属性</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:文件路径或文件名;<br><br>buf:inode结构体指针,传出参数;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int lstat(const char *path,struct stat *buf)</code>：<strong>获取文件属性</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:文件路径或文件名;<br><br>buf:inode结构体指针,传出参数;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p>inode结构体：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191516573.png" alt="image-20240425122528875"></p><p><strong>应用场景</strong>：</p><ul><li><code>buf.st_size</code>：获取文件大小</li><li><code>buf.st_mode</code>：获取文件类型</li><li><code>buf.st_mode</code>：获取文件权限</li></ul><p><strong>判断文件类型</strong>：</p><ul><li><p>我们可以通过st_mode中给出的一些宏来进行判断文件类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">st_mode给出的宏:<br>m:st_mode<br><span class="hljs-number">1.</span><span class="hljs-built_in">S_ISREG</span>(m)：判断文件是不是普通文件;<br><span class="hljs-number">2.</span><span class="hljs-built_in">S_ISDIR</span>(m)：判断文件是不是目录;<br><span class="hljs-number">3.</span><span class="hljs-built_in">S_ISCHR</span>(m)：判断文件是不是设备文件;<br><span class="hljs-number">4.</span><span class="hljs-built_in">S_ISBLK</span>(m)：判断是否为块设备文件;<br><span class="hljs-number">5.</span><span class="hljs-built_in">S_ISFIFO</span>(m)：判断是否为管道;<br><span class="hljs-number">6.</span><span class="hljs-built_in">S_ISLNK</span>(m)：判断是否为符号链接;<br><span class="hljs-number">7.</span><span class="hljs-built_in">S_ISSOCK</span>(m)：判断是否为soket套接字;<br></code></pre></td></tr></table></figure></li><li><p>使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sb;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">stat</span>(argv[<span class="hljs-number">0</span>],&amp;sb);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">S_ISREG</span>(sb.st_mode))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It&#x27;s a regular\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：<strong>stat是不能够穿透符号链接，而lstat是能够穿透符号链接</strong>，也就是说当用stat对符号链接文件操作时，判断文件类型确是普通文件，而用lstat对符号链接文件操作时，判断文件类型确是符号链接</p></blockquote></li></ul><h3 id="link-unlink函数"><a href="#link-unlink函数" class="headerlink" title="link&#x2F;unlink函数"></a>link&#x2F;unlink函数</h3><p><strong>函数原型</strong>：</p><ul><li><code>int link(const char *oldpath,const char *newpath)</code>：<strong>可以为已经存在的文件创建目录项(硬链接)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>oldpath:要创建硬链接文件路径;<br><br>newpath:硬链接文件保存的地址;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int unlink(const char *pathname)</code>：<strong>删除一个文件的目录项(硬链接)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:要删除目录项的文件路径;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>Linux删除文件的机制，是不断将inode中的st_nlink-1,直至减到为0为止。无目录项对应的文件，将会被操作系统择机释放</li><li><strong>unlink函数特征</strong>：<strong>清除文件时，如果文件的硬链接数到0了</strong>，没有dentry对应，则该文件仍不会马上被释放。<strong>要等到所有打开该文件的进程关闭该文件，系统才会择机将该文件释放掉</strong></li></ul></blockquote><p><strong>实现mv命令</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">link</span>(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">unlink</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="隐式回收"><a href="#隐式回收" class="headerlink" title="隐式回收"></a>隐式回收</h3><p><strong>概念</strong>：<strong>当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空 间会被释放</strong>，这一特性称之为隐式回收系统资源</p><h3 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h3><p><strong>函数原型</strong>：</p><p><code>int symlink(const char *oldpath,const char *newpath)</code>：<strong>用于创建文件的软链接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *linkpath)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>target:要创建软连接的文件目标地址;<br><br>linkpath:软连接文件保存地址;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h3 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h3><p><strong>函数原型</strong>：</p><p><code>ssize_t readlink(const char *path,char *buf,size_t bufsiz)</code>：<strong>用于读取符号链接(软链接)文件内容，得到链接所指向的文件名</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *restrict pathname, <span class="hljs-type">char</span> *restrict buf,<span class="hljs-type">size_t</span> bufsiz)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>pathname:要读取内容的软链接文件路径;<br><br>buf:将读入的内容保存的缓冲区;<br><br>bufsiz:缓冲区大小;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回实际读到的字节数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h3 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h3><p><strong>函数原型</strong>：</p><p><code>int rename(const char *oldpath,const char *newpath)</code>：<strong>为文件重命名</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>oldpath:原来的文件名;<br><br>newpath:新的文件名;<br></code></pre></td></tr></table></figure><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h3><p><strong>函数原型</strong>:</p><p><code>char *getcwd(char *buf,size_t size)</code>：<strong>获取进程当前工作目录</strong>(man卷3)，相当于pwd命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>buf:将获取到的信息存入的缓冲区;<br><br>size:缓冲区大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:buf中保存当前进程工作目录位置;<br><br>失败:<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h3><p><strong>函数原型</strong>:</p><p><code>int chdir(const char *path)</code>：<strong>改变当前进程的工作目录</strong>，其实就是cd命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:要进入的工作目录;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h3 id="opendir-closedir函数"><a href="#opendir-closedir函数" class="headerlink" title="opendir&#x2F;closedir函数"></a>opendir&#x2F;closedir函数</h3><p><strong>函数原型</strong>:</p><ul><li><code>DIR *opendir(const char *name)</code>：<strong>根据传入的目录名打开一个目录</strong>,DIR*类似于FILE*</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>name:目录名;<br><span class="hljs-comment">//参数支持相对路径、绝对路径</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回指向该目录结构体指针;<br><br>失败:返回<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li><code>int closedir(DIR *dirp)</code>：<strong>关闭指定打开的目录</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h3 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h3><p><strong>函数原型</strong>:</p><ul><li><code>struct dirent *readdir(DIR *dirp)</code>：<strong>读取指定目录</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dirp);<br><br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回目录项结构体指针;<br><br>失败:返回<span class="hljs-literal">NULL</span>,errno;<br><span class="hljs-comment">//注意：读取数据结束时也返回NULL值，所以需要借助errno进一步区分</span><br><br><br><span class="hljs-comment">//dirent结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> &#123;<br>    <span class="hljs-type">ino_t</span> d_ino;       <span class="hljs-comment">/* Inode number */</span><br>    <span class="hljs-type">off_t</span> d_off;       <span class="hljs-comment">/* Not an offset; see below */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> d_reclen;    <span class="hljs-comment">/* Length of this record */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;      <span class="hljs-comment">/* Type of file; not supported by all filesystem types */</span><br>    <span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* Null-terminated filename */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="rewinddir函数"><a href="#rewinddir函数" class="headerlink" title="rewinddir函数"></a>rewinddir函数</h3><p><strong>函数原型</strong>:</p><p><code>void rewinddir(DIR *dirp)</code>：<strong>回卷目录读写位置至起始位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewinddir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br></code></pre></td></tr></table></figure><h3 id="telldir-seekdir函数"><a href="#telldir-seekdir函数" class="headerlink" title="telldir&#x2F;seekdir函数"></a>telldir&#x2F;seekdir函数</h3><p><strong>函数原型</strong>:</p><ul><li><code>long telldir(DIR *dirp)</code>：<strong>获取目录读写位置</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:与dirp相关的目录当前读写位置;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>void seekdir(DIR *dirp,long loc)</code>：<strong>修改&#x2F;跳转目录指定的读写位置</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dirp, <span class="hljs-type">long</span> loc)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br>loc:一般telldir的返回值决定;<br></code></pre></td></tr></table></figure><h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p><strong>思路</strong>：</p><ol><li>判断命令行参数，获取用户要查询的目录名(argv[1])，还需要判断argc&#x3D;&#x3D;1-&gt;.&#x2F;目录</li><li>判断用户指定的是否是目录，使用stat S_ISDIR()</li><li>读目录，opendir()，readdir()，closedir()</li><li>递归读取目录文件，普通文件直接打印，目录就拼接出绝对路径，递归调用opendir()</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH_LEN 256</span><br><br><span class="hljs-comment">//第二个参数为函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fetchdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir,<span class="hljs-type">void</span>(*fcn)(<span class="hljs-type">char</span> *))</span></span>&#123;<br>    <span class="hljs-type">char</span> name[PATH_LEN];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *sdp;<br>    DIR *dp;<br><br>    <span class="hljs-keyword">if</span>((dp=<span class="hljs-built_in">opendir</span>(dir))==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;fetchdir：can&#x27;t open %s\n&quot;</span>,dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">//读取目录项</span><br>    <span class="hljs-keyword">while</span> ((sdp=<span class="hljs-built_in">readdir</span>(dp))!=<span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(sdp-&gt;d_name,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span>||<span class="hljs-built_in">strcmp</span>(sdp-&gt;d_name,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(dir)+<span class="hljs-built_in">strlen</span>(sdp-&gt;d_name)+<span class="hljs-number">2</span>&gt;<span class="hljs-built_in">sizeof</span>(name))&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;fetchdir：name %s %s too long\n&quot;</span>,dir,sdp-&gt;d_name);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">sprintf</span>(name,<span class="hljs-string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);<br>            <span class="hljs-comment">//利用函数指针调用函数</span><br>            (*fcn)(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">closedir</span>(dp);<br>&#125;<br><br><span class="hljs-comment">//处理目录/文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isfile</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sbuf;<br><br>    <span class="hljs-comment">//文件名无效</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stat</span>(name,&amp;sbuf)==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;isfile：can&#x27;t access %s\n&quot;</span>,name);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//判断是否为目录</span><br>    <span class="hljs-keyword">if</span>((sbuf.st_mode&amp;S_IFMT)==S_IFDIR) <span class="hljs-built_in">fetchdir</span>(name,isfile); <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8ld %s\n&quot;</span>,sbuf.st_size,name);    <span class="hljs-comment">//不是目录，则是普通文件，直接打印文件名</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(argc==<span class="hljs-number">1</span>) <span class="hljs-built_in">isfile</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span> (--argc&gt;<span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//可一次查询多个目录</span><br>            <span class="hljs-built_in">isfile</span>(*++argv);    <span class="hljs-comment">//循环调用该函数处理各个命令行传入的目录</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><strong>函数原型</strong>：</p><ul><li><code>int dup(int oldfd)</code>：<strong>将已有的文件描述符文件里的内容复制到新建的文件描述符文件中</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>oldfd:已有文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:新文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int dup2(int oldfd,int newfd)</code>：<strong>将一个文件描述符newfd重定向到指定文件描述符oldfd的文件</strong>，重定向完，对newfd所指向文件操作也就是对oldfd所指向文件操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>oldfd:已有文件描述符;<br><br>newfd:要重定向的文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回newfd;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：对于dup2,如果oldfd不是有效的文件描述符，会报错，但是newfd文件描述符不会关闭</p></blockquote><p><strong>fcntl实现dup</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd1=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd1 = %d\n&quot;</span>,fd1);<br>    <span class="hljs-type">int</span> newfd=<span class="hljs-built_in">fcntl</span>(fd1,F_DUPFD,<span class="hljs-number">0</span>);   <span class="hljs-comment">//0被占用，fcntl使用文件描述符表中可用的最小文件描述符返回</span><br>    <span class="hljs-comment">//也可以指定一个&lt;1024的文件描述符x，如果文件描述符没有被占用就可以直接使用，如果被占用系统自动找寻大于等于x没有被占用的文件描述符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;newfd = %d\n&quot;</span>,newfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p><strong>函数原型</strong>：</p><p><code>pid_t fork(void)</code>：<strong>创建一个子进程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:父进程接收到返回值新子进程<span class="hljs-built_in">ID</span>(PID),创建出来的子进程接收到返回值<span class="hljs-number">0</span>;<br><br>失败:父进程接收到<span class="hljs-number">-1</span>,errno，子进程没被创建成功;<br></code></pre></td></tr></table></figure><p><strong>创建子进程</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//用来检测子进程创建后是否是从头运行还是从fork()开始</span><br>    <span class="hljs-comment">//应该只打印一次，因为子进程会从fork()开始</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;before fork -1&quot;</span>&lt;&lt;std::endl;<br><br><br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-comment">//子进程创建失败</span><br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//说明当前进程是子进程</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;child is created&quot;</span>&lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//说明当前进程为父进程</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;parent process: my child is &quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>    &#125;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;end of file&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getpid-getppid函数"><a href="#getpid-getppid函数" class="headerlink" title="getpid&#x2F;getppid函数"></a>getpid&#x2F;getppid函数</h3><p><strong>函数原型</strong>:</p><ul><li><code>pid_t getpid(void)</code>：<strong>获取当前进程ID(PID)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程PID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><ul><li><code>pid_t getppid(void)</code>：<strong>获取当前子进程的父进程ID(PID)</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回当前子进程的父进程PID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><p><strong>循环创建子进程</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-type">pid_t</span> pid=fork();<br>        <span class="hljs-comment">//子进程创建失败</span><br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m parent \n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(i);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m child&quot;</span>&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getuid-getgid函数"><a href="#getuid-getgid函数" class="headerlink" title="getuid&#x2F;getgid函数"></a>getuid&#x2F;getgid函数</h3><p><strong>函数原型</strong>:</p><ul><li><code>uid_t getuid(void)</code>：<strong>获取当前进程实际用户ID</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uid_t</span> <span class="hljs-title">getuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程实际用户ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><ul><li><code>uid_t geteuid(void)</code>：<strong>获取当前进程有效用户ID</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uid_t</span> <span class="hljs-title">geteuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程有效用户ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><ul><li><code>gid_t getgid(void)</code>：<strong>获取当前进程使用用户组ID</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">gid_t</span> <span class="hljs-title">getgid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程使用用户组ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><ul><li><code>gid_t getegid(void)</code>：<strong>获取当前进程有效用户组ID</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">gid_t</span> <span class="hljs-title">getegid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br>成功:当前进程有效用户组ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure><h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><p><strong>概念</strong>:</p><ul><li><p><strong>父子进程共享遵循读时共享写时复制</strong>，例如：有一个全局变量cnt&#x3D;100，当我父进程或者子进程读cnt时，将会共享这个cnt的值也就是100,但是当父进程或子进程要更改其值也就是写时，将会给当前进程copy一个cnt过来再改，因此当父进程或子进程修改cnt(只修改自己进程中的cnt),子进程或父进程读cnt得到的值还是cnt</p></li><li><p><strong>父子进程不会共享全局变量</strong></p></li><li><p>父子进程相同处：刚fork后，data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p></li><li><p>父子进程不同处：进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p></li><li><p><code>父子进程共享</code>：</p><blockquote><ol><li><strong>文件描述符</strong></li><li><strong>mmap映射区</strong></li></ol></blockquote></li></ul><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p><strong>概念</strong>：</p><ul><li><code>exec函数族</code>可以<strong>让子进程或父进程执行指定的某个可执行程序</strong></li><li><strong>当进程调用exec时，则进程中的代码段将会换成你要exec的可执行程序的代码段，以此来执行指定程序</strong>，但是进程ID没变</li><li><strong>exec不能返回的！</strong></li></ul><h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p><code>int execl(const char *path,const char *arg,...)</code>：<strong>加载一个进程(可执行程序)，用于加载普通和系统的可执行程序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg,...)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>path:可执行文件路径;<br><br>arg:argv[<span class="hljs-number">0</span>],所以跟path一样;<br><br>...:用来传入执行可执行文件的参数，可变参数;<br><span class="hljs-comment">//注意：结尾得传入NULL来作为哨兵来结束参数输入</span><br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p><code>int execlp(const char *file,const char *arg,...)</code>：<strong>借助PATH环境变量加载一个进程</strong>，用于加载系统可执行程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg,...)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>file:可执行文件的文件名;<br><br>arg:argv[<span class="hljs-number">0</span>]，所以还是传入可执行文件名;<br><br>...:用来传入执行可执行文件的参数，可变参数;<br><span class="hljs-comment">//注意：结尾得传入NULL来作为哨兵来结束参数输入</span><br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//因为只有报错时才会返回值，所以不需要判断返回值</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;exec error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m parent:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行结果：将会打印当前目录下文件信息</span><br></code></pre></td></tr></table></figure><h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p><code>int execvp(const char *file,const char *argv[])</code>：<strong>使用自定义环境变量env加载一个进程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>file:可执行文件的文件名;<br><br>argv[]:可变参数，类似于main函数中的argv[];<br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="exec函数族特点"><a href="#exec函数族特点" class="headerlink" title="exec函数族特点"></a><strong>exec函数族特点</strong></h4><ul><li><p>exec函数一旦调用成功即执行新的程序，只有失败才返回！</p></li><li><p>函数名中的字母含义：</p><blockquote><ol><li>l (list)：命令行参数列表</li><li>p (path)：搜索file时使用path变量</li><li>v (vector)：使用命令行参数数组</li><li>e (environment)：使用环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量</li></ol></blockquote></li><li><p>只有exeve函数是系统调用函数</p></li></ul><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><p><strong>孤儿进程</strong>：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程</p><p><strong>僵尸进程</strong>：进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程</p><blockquote><p>注意：</p><ul><li>僵尸进程是不能使用kill命令清除掉的，因为kill命令只是用来终止进程的，而僵尸进程已经终止</li><li>需要使用kill命令将父进程kill掉，然后由init接收僵尸进程并回收</li></ul></blockquote><p><strong>概念</strong>：</p><ul><li><strong>一个进程在终止时</strong>会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在按其中保存了一些信息，<strong>如果是正常退出则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个</strong></li><li>这个进程的父进程<strong>可以调用wait或waitpid获取这些信息，彻底清除掉这个进程</strong></li><li><strong>wait、waitpid都只能够一次回收一个进程</strong></li></ul><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p><strong>函数原型</strong>：</p><p><code>pid_t wait(int *status)</code>：父进程调用wait函数可以回收子进程终止信息，有三个功能:</p><blockquote><ol><li>阻塞等待子进程退出(死亡)</li><li>回收子进程残留资源</li><li>获取子进程结束状态(退出原因)</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>status:传出参数，子进程退出状态;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回被回收子进程的进程ID;<br><br>失败:<span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p><strong>子进程退出信息</strong>：</p><p>要想进一步获取退出状态和原因需要借助一些宏函数</p><ul><li><p><code>WIFEXITED(status)</code>：判断子进程是否正常终止，为真则正常终止<code>WEXITSTATUS(status)</code>：只有当子进程是正常终止才调用查看子进程返回值</p></li><li><p><code>WIFSIGNALED(status)</code>：判断子进程是否是被信号终止的，为真为是</p><p><code>WTERMSIG(status)</code>：只有当子进程是被信号终止时，用来查看子进程是被哪个信号终止</p></li><li><p><code>WIFSTOPPED(status)</code>：判断子进程是否被信号阻塞，为真则是</p><p><code>WSTOPSIG(status)</code>：只有当子进程是被信号阻塞时，用来查看子进程被哪个信号阻塞的</p><p><code>WIFCONTINUED(status)</code>：查看子进程是否被恢复</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid,wpid;<br>    pid=fork();<br><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;---child,my id=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;<span class="hljs-string">&quot;,going to sleep 10s\n&quot;</span>;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;--------child die--------&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">73</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//wpid=wait(NULL);  //不关心子进程结束原因</span><br>        wpid=<span class="hljs-built_in">wait</span>(&amp;status);     <span class="hljs-comment">//如果子进程未终止，父进程阻塞在这个函数上</span><br>        <span class="hljs-keyword">if</span>(wpid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;wait error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFEXITED</span>(status))&#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;child exit with &quot;</span>&lt;&lt;<span class="hljs-built_in">WEXITSTATUS</span>(status)&lt;&lt;std::endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFSIGNALED</span>(status))&#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;child kill with signal &quot;</span>&lt;&lt;<span class="hljs-built_in">WTERMSIG</span>(status)&lt;&lt;std::endl;<br>        &#125;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I am parent,pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getgid</span>()&lt;&lt;<span class="hljs-string">&quot;,myson=&quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;被回收的进程ID=&quot;</span>&lt;&lt;wpid&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p><strong>函数原型</strong>：</p><p><code>pid_t waitpid(pid_t pid,int *status,int options)</code>：<strong>作用同wait一样</strong>(父进程调用wait函数可以回收子进程终止信息)，但<strong>可指定pid进程清理，可以不阻塞</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">int</span> *status,<span class="hljs-type">int</span> options)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pid:要被回收的子进程ID;<br><span class="hljs-comment">//参数列表：</span><br>&gt; <span class="hljs-number">0</span>:回收指定ID的子进程;<br><span class="hljs-number">-1</span>:回收任意子进程(相当于wait);<br><span class="hljs-number">0</span>:回收和当前调用waitpid一个组的所有子进程;<br>&lt; <span class="hljs-number">-1</span>:回收指定进程组内的任意子进程;<br><br>status:传出参数，子进程退出状态;<br><br>options:函数行为标志位参数;<br><span class="hljs-comment">//标志位参数有，可以看第二卷man手册:</span><br><span class="hljs-number">0</span>:阻塞;<br>WNOHANG:不阻塞;<br><br><br><br><br><br><span class="hljs-comment">//返回值</span><br>返回值&gt;<span class="hljs-number">0</span>:表示成功回收的子进程pid;<br><br>返回值=<span class="hljs-number">0</span>:函数调用时，参数三指定WNOHANG,并且没有子进程结束;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>waitpid回收多个进程</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">pid_t</span> pid,wpid;<br>    pid=fork();<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i)&#123;<br>        <span class="hljs-comment">/* while((wpid=waitpid(-1,NULL,0)))&#123;    //使用阻塞方式回收子进程</span><br><span class="hljs-comment">            std::cout&lt;&lt;&quot;wait child &quot;&lt;&lt;wpid&lt;&lt;std::endl;</span><br><span class="hljs-comment">        &#125; */</span><br>        <span class="hljs-comment">//使用非阻塞</span><br>        <span class="hljs-keyword">while</span>((wpid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,WNOHANG))!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(wpid&gt;<span class="hljs-number">0</span>)&#123;<br>                std::cout&lt;&lt;<span class="hljs-string">&quot;wait child &quot;</span>&lt;&lt;wpid&lt;&lt;std::endl;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wpid==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(i);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m &quot;</span>&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;th child,pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p><strong>概念</strong>：</p><ul><li><code>进程间通信(IPC)</code>：<strong>也就是进程与进程之间进行通信、共享和数据传递</strong> ，叫作进程间通信</li><li>进程间通信的<code>实质</code>就是<strong>在两个进程间放置一个缓冲区，让两个进程在缓冲区里进行读和写来进行通信。</strong></li></ul><p><strong>进程间通信方式</strong>：</p><ul><li>管道(使用最简单)</li><li>信号(开销最小)</li><li>mmap共享映射区(无血缘关系)</li><li>本地套接字socket(最稳定)</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p><ul><li><code>管道</code>是一种最基本的IPC机制，<strong>作用于有血缘关系的进程之间，完成数据传递。</strong></li><li>管道的<strong>本质是一个伪文件(实为内核缓冲区)</strong></li><li>由两个文件描述符引用的，一个表示读端，一个表写端</li><li>管道是内核使用环形队列机制，借助内核缓冲区实现的</li></ul><p><strong>局限性</strong>：</p><ul><li>数据<strong>不能自己写，自己读</strong></li><li><strong>管道中数据不可反复读取</strong>，一旦读走，管道中的相应内容不再存在</li><li><strong>采用半双工通信方式</strong>，数据只能在单方向上流动</li></ul><p><strong>特点</strong>：</p><ol><li>**它是半双工的(即数据只能在一个方向上流动)**，具有固定的读端和写端</li><li>它<code>只能用于具有亲缘关系的进程之间的通信</code>(父子进程或兄弟进程之间)</li><li><strong>它可以看成是一种特殊的文件(伪文件)<strong>，对于它的</strong>读写也可以使用普通的read、write等函数</strong>。但是它不是普通的文件，并不属于其他任何文件系统，并且<strong>只存在于内存中</strong></li></ol><h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><p><strong>函数原型</strong>：</p><p><code>int pipe(int pipefd[2])</code>：<strong>创建并打开管道</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pipefd[<span class="hljs-number">0</span>]:读端的文件描述符;<br><br>pipefd[<span class="hljs-number">1</span>]:写端的文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">//父进程写，子进程读，则父进程需要关闭读端，子进程需要关闭写端</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret,fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> *str=<span class="hljs-string">&quot;hello pipe\n&quot;</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    ret=<span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//父进程关闭读端</span><br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>],str,<span class="hljs-built_in">strlen</span>(str));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写完数据就关闭</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//子进程关闭写端</span><br>        ret=<span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>],buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, ret);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//读完数据就关闭读端</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h4><ol><li><p><code>读管道</code>：</p><blockquote><ol><li>管道中有数据，read返回实际读到的字节数.</li><li>管道中无数据：<ul><li>管道写端被全部关闭，read返回0</li><li>写端没有全部关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li></ul></li></ol></blockquote></li><li><p><code>写管道</code>：</p><blockquote><ol><li>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li><li>管道读端没有全部关闭：<ul><li>管道已满，write阻塞</li><li>管道未满，write将数据写入，并返回实际写入的字节数</li></ul></li></ol></blockquote></li></ol><p><strong>兄弟进程通信</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-comment">//父进程写，子进程读，则父进程需要关闭读端，子进程需要关闭写端</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret,fd[<span class="hljs-number">2</span>],i;<br>    <span class="hljs-type">pid_t</span> pid;<br>    ret=<span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)&#123;<br>        pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//关闭父进程的读端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//关闭父进程的写端</span><br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//兄</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//关闭兄进程的读端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>],STDOUT_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp ls error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) &#123;   <span class="hljs-comment">//弟</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//关闭弟进程的写端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>],STDIN_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;wc&quot;</span>,<span class="hljs-string">&quot;wc&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp ls error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p><ul><li><code>FIFO(命名管道)</code>：<strong>是Linux基础文件类型中的一种</strong>，<strong>各进程可以打开这个文件进行read&#x2F;write</strong>，实际上是在读写内核通道，这样就是实现了进程间通信</li><li>FIFO文件<strong>在磁盘上没有数据块，仅仅用来标识内核中的一条通道</strong>。</li><li>在Linux终端中可以使用mkfifo命令，进行创建FIFO文件</li></ul><p><strong>特点</strong>：</p><ol><li>FIFO<code>可以在无血缘关系的进程之间交换数据</code>，与pipe不同。</li><li>它以一种特殊设备文件形式存在于文件系统中，所以<strong>我们应该用对文件的操作对待它</strong></li></ol><h4 id="mkfifo函数"><a href="#mkfifo函数" class="headerlink" title="mkfifo函数"></a>mkfifo函数</h4><p><strong>函数原型</strong>：</p><p><code>int mkfifo(const char *pathname,mode_t mode)</code>：<strong>用来创建FIFO文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:fifo文件路径名;<br><br>mode:为创建新文件设置权限参数,权限受到umask影响(默认文件操作权限);<br><span class="hljs-comment">//例如：rw-r--r-- 0644</span><br><span class="hljs-comment">//文件权限=mode&amp;(~umask)</span><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="FIFO进程通信"><a href="#FIFO进程通信" class="headerlink" title="FIFO进程通信"></a>FIFO进程通信</h4><p>先创建一个myfifo的fifo文件</p><p>写端：test.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd,i;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//int fd=mkfifo(&quot;myfifo&quot;,0644);</span><br>    fd=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;hello itcast %d\n&quot;</span>,i++);<br>        <span class="hljs-built_in">write</span>(fd,buf,<span class="hljs-built_in">strlen</span>(buf));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读端：testr.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd,len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;./a.out fifoname\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    fd=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        len=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,len);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);   <span class="hljs-comment">//多个读端时应增加睡眠秒数，放大效果</span><br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h3><h4 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I&#x2F;O"></a>存储映射I&#x2F;O</h4><p><strong>概念</strong>：</p><ul><li><code>存储映射I/O</code><strong>使一个磁盘文件与存储空间中的一个缓冲区相映射</strong>，当从缓冲区取数据相当于读文件中相应字节，将数据存入缓冲区，则相应的字节就自动写入文件。</li><li><strong>存储映射可以</strong>在不适用read和write函数的情况下，<strong>使用地址(指针)完成I&#x2F;O操作</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191516574.png" alt="image-20240429083055810"></p><p><strong>使用注意事项</strong>：</p><ol><li>用于创建映射区的文件大小为0,实际指定非0大小创建映射区，出”总线错误(SIGBUS)”</li><li>用于创建映射区的文件大小为0,实际指定0大小创建映射区，出”无效参数”</li><li>用于创建映射区文件的读写属性为只读，映射区属性为读写，出”无效参数”</li><li>创建映射区需要读权限，当访问权限指定为MAP_SHARED时，mmap的读写权限应该&lt;&#x3D;文件的open权限</li><li>文件描述符fd,在mmap创建映射区完成即可关闭，后续访问文件，用地址访问</li><li>offset必须是4096的整数倍(MMU映射的最小单位为4k)</li><li>对申请的映射区内存，不能越界访问。</li><li>munmap用于释放的地址，必须是mmap申请返回的地址</li><li>映射区访问权限为MAP_PRIVATE，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上</li><li>映射区访问权限为MAP_PRIVATE，只需要open文件时，有读权限用于创建映射区即可</li></ol><h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><p><strong>函数原型</strong>：</p><p><code>void *mmap(void *addr,size_t length,int prot,int flags,int fd,off_t offset)</code>：<strong>创建共享内侧映射区</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> off)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>addr:建立映射区的首地址，由Linux内核指定，使用时，直接传入<span class="hljs-literal">NULL</span>;<br><br>length:欲创建映射区的大小(小于等于文件实际大小);<br><br>prot:映射区权限;<br><span class="hljs-comment">//选择:</span><br>PROT_READ:读;<br>PROT_WRITE:写;<br>PROT_READ|PROT_WRITE:读写;<br>PROT_NONE:没有访问权限;<br>...:更多的看man手册第二卷的mmap函数;<br><br>flags:标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区);<br><span class="hljs-comment">//选择:</span><br>MAP_SHARED:会将映射区所做的操作反映到物理设备(磁盘)上;<br>MAP_PRIVATE:映射区所做的修改不会反映到物理设备;<br>...:更多的看man手册第二卷的mmap函数;<br><br><span class="hljs-comment">//需要先有文件</span><br>fd:用于创建共享内存映射区的那个文件的文件描述符;<br><br>offset:默认<span class="hljs-number">0</span>,表示映射文件全部。偏移位置,取值必须是<span class="hljs-number">4096</span>的整数倍;<br><br><span class="hljs-comment">//返回值</span><br>成功:共享内存映射区的首地址;<br><br>失败:返回<span class="hljs-built_in">MAP_FAILED</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>),errno;<br><span class="hljs-comment">//返回一个将-1强转成void*的宏</span><br></code></pre></td></tr></table></figure><p><strong>mmap函数保险调用方式</strong>：</p><ol><li>open(pathname,O_RDWR,0644);</li><li>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,fd,0);</li></ol><h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><p><strong>函数原型</strong>：</p><p><code>int munmap(void *addr,size_t length)</code>：<strong>释放共享内存映射区</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>addr:要释放的映射区的首地址，也是mmap函数的返回值;<br><br>length:映射区大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> fd;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/* lseek(fd,10,SEEK_END);</span><br><span class="hljs-comment">    write(fd,&quot;\0&quot;,1); */</span><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-number">20</span>);   <span class="hljs-comment">//可以代替lseek操作来扩展文件</span><br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">lseek</span>(fd,<span class="hljs-number">0</span>,SEEK_END);<br>    p=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//使用p对文件进行读写操作</span><br>    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;hello mmap&quot;</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;-------&quot;</span>&lt;&lt;p&lt;&lt;std::endl;<br><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,len);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><p><strong>概念</strong>：</p><ul><li><p><strong>父子等有血缘关系的进程之间也可以通过mmap建立映射区来完成数据通信</strong>，但相应的要在创建映射区的时候指定对应的标志位参数flags：</p><blockquote><ul><li>MAP_PRIVATE:父子进程各自独占映射区(私有映射)</li><li>MAP_SHARED:父子进程共享映射区(共享映射)</li></ul></blockquote></li><li><p><strong>要想父子进程通信，则flags应该置于MAP_SHARED</strong></p></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> var=<span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> *p;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> fd;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// unlink(&quot;testmap&quot;);     //删除临时文件目录项，使之具备被释放的条件</span><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-number">4</span>);<br>    p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// p=(int *)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0);</span><br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        *p=<span class="hljs-number">2000</span>;    <span class="hljs-comment">//写共享内存,因为映射区为int*类型所以，只能写整形变量</span><br>        var=<span class="hljs-number">1000</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;child,*p=&quot;</span>&lt;&lt;*p&lt;&lt;<span class="hljs-string">&quot;,var=&quot;</span>&lt;&lt;var&lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;parent,*p=&quot;</span>&lt;&lt;*p&lt;&lt;<span class="hljs-string">&quot;,var=&quot;</span>&lt;&lt;var&lt;&lt;std::endl;<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p, <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//如果子进程和父进程输出的*p一致说明他们能通信</span><br><span class="hljs-comment">//使用私有权限不能够通信</span><br></code></pre></td></tr></table></figure><h4 id="mmap无血缘关系进程通信"><a href="#mmap无血缘关系进程通信" class="headerlink" title="mmap无血缘关系进程通信"></a>mmap无血缘关系进程通信</h4><p>示例：</p><p>写端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    student stu=&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>&#125;,*p;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-built_in">sizeof</span>(stu));<br>    p=(<span class="hljs-keyword">struct</span> student*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-built_in">sizeof</span>(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">memcpy</span>(p,&amp;stu,<span class="hljs-built_in">sizeof</span>(stu));<br>        stu.id++;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-built_in">sizeof</span>(stu));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    student stu,*p;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    p=(<span class="hljs-keyword">struct</span> student*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-built_in">sizeof</span>(stu),PROT_READ,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;id=%d,name=%s,age=%d\n&quot;</span>,p-&gt;id,p-&gt;name,p-&gt;age);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-built_in">sizeof</span>(stu));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p><strong>概念</strong>：</p><ul><li><code>匿名映射</code>：<strong>可以不需要创建文件来创建共享内存映射区</strong>，在mmap函数的<code>flags标志位参数添加上MAP_ANON或MAP_ANONYMOUS来实现,-1代替fd</code></li><li>之前使用mmap映射时，我们都是使用创建一个文件来创建共享内存映射区，但是我们也可以使用匿名映射，来避免需要创建文件来创建共享内存映射区</li><li><code>只能用于血缘关系进程间通信</code></li><li>也可以使用open(“&#x2F;dev&#x2F;zero”)来当作映射区，因为&#x2F;dev&#x2F;zero可以提供很大的空间，你想要多少他就给多少，这样就不需要扩展文件，直接创建映射区(虽然不是匿名映射)</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> var=<span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> *p;<br>    p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">40</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        *p=<span class="hljs-number">7000</span>;<br>        var=<span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child,*p=%d,var=%d\n&quot;</span>,*p,var);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent,*p=%d,var=%d\n&quot;</span>,*p,var);<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p><ul><li><p><code>信号(SIGNAL)</code>：给我们提供了一个信息，表示某件事件发生。在我们生活中随处可见，如：古代战争摔杯为号;体育比赛中的信号枪</p></li><li><p>常用信号可以使用kill -l和man 7 signal来查看</p></li><li><p>特点：</p><blockquote><ol><li>简单</li><li>不能携带大量信息</li><li>满足某个特设条件才发送</li></ol></blockquote></li></ul><p><strong>信号的机制</strong>：</p><ul><li>A给B发送信号，B收到信号之前执行自己的代码，<strong>收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行</strong></li><li>由于信号是通过软件方法实现的，其实现手段导致信号有很强的延时性。但相对于用户来说，这个延迟时间非常短，不易察觉</li><li><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理</strong>。</li></ul><p><strong>与信号相关的事件和状态</strong>：</p><ul><li><p><strong>产生信号状态</strong>：</p><blockquote><ol><li>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</li><li>系统调用产生，如：kill、raise、abort</li><li>软件条件产生，如：定时器alarm</li><li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li><li>命令产生，如：kill命令</li></ol></blockquote></li><li><p><strong>递达状态</strong>：递达并且到达进程</p></li><li><p><strong>未决状态</strong>：产生和递达之间的状态，<strong>主要由于阻塞(屏蔽)导致该状态</strong></p></li><li><p><strong>信号的处理方式</strong>：</p><blockquote><ol><li>执行默认动作</li><li>忽略(丢弃)</li><li>捕捉(调用户处理函数)</li></ol></blockquote></li><li><p>**阻塞信号集(信号屏蔽字)<strong>：将某些信号加入集合，对他们设置屏蔽，</strong>当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)**，在解除屏蔽前，一直处于未决态</p></li><li><p><strong>未决信号集</strong>：</p><blockquote><ol><li>信号产生，未决信号集中描述该信号的位立刻翻转为1,表信号处于未决状态。当信号被处理对应位翻转回为0。</li><li><strong>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集</strong>。在屏蔽解除前，信号一直处于未决状态</li></ol></blockquote></li></ul><p><strong>信号四要素</strong>：</p><ol><li>信号编号</li><li>信号名称</li><li>信号对应事件</li><li>信号默认处理动作</li></ol><blockquote><p>注：信号使用之前，应先确定4要素，而后使用</p></blockquote><p><strong>默认处理动作</strong>：</p><ul><li><strong>Term</strong>：终止进程</li><li><strong>Ign</strong>：忽略信号(默认及时对该种信号忽略操作)</li><li><strong>Core</strong>：停止进程，生成Core文件。(查验进程死亡原因，用于gdb调试)</li><li><strong>Stop</strong>：停止(暂停)进程</li><li><strong>Cont</strong>：继续运行进程</li></ul><p><strong>常规信号一览表</strong>：</p><ol><li><strong>SIGHUP</strong>：本信号在用户终端结束时发出，通常是在终端的控制进程结束时，通知同一会话期内的各个作业，这时他们与控制终端不在关联。比如，登录Linux时，系统会自动分配给登录用户一个控制终端，在这个终端运行的所有程序，包括前台和后台进程组，一般都属于同一个会话。当用户退出时，所有进程组都将收到该信号，这个信号的默认操作是终止进程。此外对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</li><li><strong>SIGINT</strong>：程序终止信号。当用户按下CRTL+C时通知前台进程组终止进程。</li><li><strong>SIGQUIT</strong>：Ctrl+\控制，进程收到该信号退出时会产生core文件，类似于程序错误信号。</li><li>SIGILL：执行了非法指令。通常是因为可执行文件本身出现错误，或者数据段、堆栈溢出时也有可能产生这个信号。</li><li>SIGTRAP：由断点指令或其他陷进指令产生，由调试器使用。</li><li>SIGABRT：调用abort函数产生，将会使程序非正常结束。</li><li><strong>SIGBUS</strong>：非法地址。包括内存地址对齐出错。比如访问一个4个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法地址的非法访问触发。</li><li><strong>SIGFPE</strong>：发生致命的算术运算错误。</li><li><code>SIGKILL</code>：用来立即结束程序的运行。</li><li><strong>SIGUSR1</strong>：留给用户使用，用户可自定义。</li><li><strong>SIGSEGV</strong>：访问未分配给用户的内存区。或操作没有权限的区域。</li><li><strong>SIGUSR2</strong>：留给用户使用，用户可自定义。</li><li><strong>SIGPIPE</strong>：管道破裂信号。当对一个读进程已经运行结束的管道执行写操作时产生。</li><li><strong>SIGALRM</strong>：时钟定时信号。由alarm函数设定的时间终止时产生。</li><li><strong>SIGTERM</strong>：程序结束信号。shell使用kill产生该信号，当结束不了该进程，尝试使用SIGKILL信号。</li><li>SIGSTKFLT：堆栈错误。</li><li><strong>SIGCHLD</strong>：子进程结束，父进程会收到。如果子进程结束时父进程不等待或不处理该信号，子进程会变成僵尸进程。</li><li>SIGCONT：让一个停止的进程继续执行。</li><li><code>SIGSTOP</code>：停止进程执行。暂停执行。</li><li>SIGTSTP：停止运行，可以被忽略。Ctrl+z。</li><li>SIGTTIN：当后台进程需要从终端接收数据时，所有进程会收到该信号，暂停执行。</li><li>SIGTTOU：与SIGTTIN类似，但在写终端时产生。</li><li>SIGURG：套接字上出现紧急情况时产生。</li><li>SIGXCPU：超过CPU时间资源限制时产生的信号。</li><li>SIGXFSZ：当进程企图扩大文件以至于超过文件大小资源限制时产生。</li><li>SIGVTALRM：虚拟使用信号。计算的是进程占用CPU调用的时间。</li><li>SIGPROF：包括进程使用CPU的时间以及系统调用的时间。</li><li>SIGWINCH：窗口大小改变时。</li><li>SIGIO：文件描述符准备就绪，表示可以进行输入输出操作。</li><li>SIGPWR：电源失效信号。</li><li>SIGSYS：非法的系统调用。</li></ol><blockquote><p>注：<strong>9号和19号信号不允许忽略和捕捉，只能执行默认动作，甚至不能将其设置为阻塞</strong></p></blockquote><h4 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h4><h5 id="kill函数-命令"><a href="#kill函数-命令" class="headerlink" title="kill函数&#x2F;命令"></a>kill函数&#x2F;命令</h5><p><strong>kill命令产生信号</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -SIGKILL pid;<br>//pid为要kill的进程ID<br></code></pre></td></tr></table></figure><p><strong>kill函数</strong>：</p><p><code>int kill(pid_t pid,int sig)</code>：<strong>发送信号给指定进程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>pid:进程ID;<br>pid&gt; <span class="hljs-number">0</span>:发送信号给指定的进程;<br>pid=<span class="hljs-number">0</span>:发送信号给与调用kill函数进程属于同一进程的所有进程;<br>pid&lt; <span class="hljs-number">-1</span>:取|pid|(绝对值)发给对应进程组;<br>pid=<span class="hljs-number">-1</span>:发送给进程有权限发送的系统中所有进程;<br><br>sig:信号;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent,pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child pid=%d,ppid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">getppid</span>());<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">kill</span>(<span class="hljs-built_in">getppid</span>(), SIGKILL);   <span class="hljs-comment">//杀死进程</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他几个发信号函数</strong>：</p><ul><li><code>int raise(int sig)</code>;</li><li><code>void abort(void)</code>;</li></ul><h5 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h5><p><strong>概念</strong>：</p><ul><li>alarm函数可以设置定时器，在指定seconds后，内核会给当前进程发送SIGALRM信号，进程收到该信号，默认动作终止</li><li><strong>每个进程都有且只有唯一个定时器</strong></li></ul><p><strong>函数原型</strong>：</p><p><code>unsigned int alarm(unsigned int seconds)</code>：<strong>设置定时器，在指定seconds后，内核会给当前进程发送SIGALRM信号，进程收到该信号，默认动作终止</strong>，使用自然计时法.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>seconds:闹钟时长(秒);<br><span class="hljs-comment">//alarm(0)等于取消闹钟;</span><br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回<span class="hljs-number">0</span>或上次定时剩余的秒数;<br>返回<span class="hljs-number">0</span>就是没有用alarm定时;<br>无失败;<br></code></pre></td></tr></table></figure><p><strong>time命令</strong>：查看程序执行时间，实际时间&#x3D;用户时间+内核时间+等待时间</p><h5 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h5><p><strong>函数原型</strong>：</p><p><code>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value)</code>：<strong>设置定时器，精度可达微秒，可以实现周期定时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_value,<span class="hljs-keyword">struct</span> itimerval *old_value)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>which:指定定时形式;<br><span class="hljs-comment">//选择</span><br>ITIMER_REAL:自然时间计时法(计算自然时间，也就是在这之间程序终止，时间一到依然发送信号);  -&gt;发送SIGALRM信号<br><span class="hljs-built_in">ITIMER_VIRTUAL</span>(用户空间):虚拟时间计时法(只计算进程占用cpu的时间);  -&gt;发送SIGTVALRM信号<br><span class="hljs-built_in">ITIMER_PROF</span>(用户+内核):运行时间计时法(计算占用cpu及执行系统调用的时间);   -&gt;发送SIGPROF信号<br><br>new_value:定时秒数;<br><br>old_value:传出参数，上次定时剩余时间;<br><br><br><span class="hljs-comment">//参数类型结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_interval; <span class="hljs-comment">/* Interval for periodic timer */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_value;    <span class="hljs-comment">/* Time until next expiration */</span><br>&#125;;<br><br>it_interval:用来设定两次定时任务之间间隔的时间;<br>it_value:定时的时长;<br>两个参数都设置为<span class="hljs-number">0</span>,则清<span class="hljs-number">0</span>操作也就是取消闹钟;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br>    <span class="hljs-type">time_t</span>      tv_sec;         <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-type">suseconds_t</span> tv_usec;        <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br><br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h4><p><strong>概念</strong>：</p><ul><li>在Linux中阻塞信号集和未决信号集都是存在于PCB中，并且Linux不允许我们直接在上面操作，但是我们又想对阻塞信号集或未决信号集操作就得需要以下函数</li><li>我们可以通过自定义的信号集来跟阻塞信号集进行位运算来影响阻塞信号集的各个信号位的值，阻塞信号集受到影响也将影响未决信号集</li></ul><h5 id="信号集设定函数"><a href="#信号集设定函数" class="headerlink" title="信号集设定函数"></a>信号集设定函数</h5><ul><li><p><code>int sigemptyset(sigset_t *set)</code>：<strong>将某个信号集清0</strong></p></li><li><p><code>int sigfillset(sigset_t *set)</code>：<strong>将某个信号集全部置为1</strong></p></li><li><p><code>int sigaddset(sigset_t *set,int signum)</code>：<strong>把某一个信号(signum)加入到某个自定义的信号集(set)</strong></p></li><li><p><code>int sigdelset(sigset_t *set,int signum)</code>：<strong>把某一个信号(signum)从某个自定义信号集(set)中移出</strong></p></li><li><p><code>int sigismember(const sigset_t *set,int signum)</code>：<strong>查看某一个信号(signum)是否在某个自定义信号集(set)中</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">sigset_t</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>set:自定义信号集;<br><br>signum:信号;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br>sigismember返回值:<br><span class="hljs-number">0</span>:set没有signum;<br><span class="hljs-number">1</span>:set有signum;<br><span class="hljs-number">-1</span>,errno:失败;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h5 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h5><p><strong>函数原型</strong>：</p><p><code>int sigprocmask(int how,const sigset_t *set,sigset_t *oldset)</code>：<strong>用来屏蔽信号和解除屏蔽</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>how:函数行为设置位，设置函数执行所需要做的行为;<br><span class="hljs-comment">//选择:</span><br>SIG_BLOCK:当how设置为此值，set表示需要屏蔽信号.相当于mask=mask|set;<br>SIG_UNBLOCK:当how设置为此值，set表示需要解除屏蔽的信号.相当于mask=mask&amp;~set;<br>SIG_SETMASK:当how设置为此值，set表示用于替代原始屏蔽集的新屏蔽集.相当于mask=set,若调用sigprocmask解除了对当前某个若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达;<br><br>set:传入参数，自定义信号集，是一个位图，set中哪位置为<span class="hljs-number">1</span>,就表示当前进程屏蔽哪个信号;<br><br>oldset:传出参数,保存旧的信号屏蔽集，不需要可以传<span class="hljs-literal">NULL</span>;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：屏蔽信号，只是将信号处理延后执行(延至解除屏蔽)，而忽略表示将信号丢弃处理</p></blockquote><h5 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h5><p><strong>函数原型</strong>：</p><p><code>int sigpending(sigset_t *set)</code>：<strong>读取当前进程的未决信号集</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>set:传出参数,当前进程的未决信号集;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><p><strong>概念</strong>：</p><ul><li>信号捕捉使是提供给开发者使用信号捕捉的函数在程序中捕捉到递达到该进程下的信号，然后自定义其的处理方式或者其他操作</li></ul><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><p><strong>函数原型</strong>：</p><p><code>sighandler_t signal(int signum,sighandler_t handler)</code>：<strong>注册一个信号捕捉函数</strong>，设定指定信号需要被捕捉，注册完后，由内核捕捉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>signum:信号;<br><br>handler:捕捉后行为参数，是一个函数指针也就是<span class="hljs-type">sighandler_t</span>定义的函数;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回指向前一个此信号的处理(回调)函数的指针;<br><br>失败:返回SIG_ERR;<br></code></pre></td></tr></table></figure><blockquote><p>注：该函数由ANSI定义，在不同版本的Linux中可能有不同的行为，因此我们<code>推荐使用sigaction函数</code></p></blockquote><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-comment">//捕捉后行为函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_cath</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;catch you! %d\n&quot;</span>,signo);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">signal</span>(SIGINT,sig_cath);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//./test运行</span><br>./test<br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^\zsh: <span class="hljs-built_in">quit</span> (core dumped)  ./test <br></code></pre></td></tr></table></figure><p><strong>验证signal返回值</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun1&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun2&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">void</span> (*res)(<span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">if</span>( (res=<span class="hljs-built_in">signal</span>(SIGINT,fun1)) == SIG_ERR )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br><br>    <span class="hljs-keyword">if</span>( (res=<span class="hljs-built_in">signal</span>(SIGINT,fun2)) == SIG_ERR )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    <span class="hljs-built_in">res</span>(SIGINT);<span class="hljs-comment">//signal返回 指向前一个处理SIGINT的函数 的指针,也就是指向fun1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//如果按照man手册所说，我们两次raise,一次raise打印fun1,一次raise打印fun2,则此时的返回值res会是fun1的函数指针，因此调用res就会打印fun1</span><br><span class="hljs-comment">//事实确实如此，运行结果如下：</span><br>&gt; ./test<br>fun1<br>fun2<br>fun1<br></code></pre></td></tr></table></figure><h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p><strong>函数原型</strong>：</p><p><code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)</code>：<strong>用来注册一个信号的捕捉函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> &#123;<br>    <span class="hljs-built_in">void</span> (*sa_handler)(<span class="hljs-type">int</span>);   <span class="hljs-comment">//捕捉后行为函数</span><br>    <span class="hljs-built_in">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);  <span class="hljs-comment">//一般不用，要想信号携带复杂数据或结构替数据需要用这个函数</span><br>    <span class="hljs-type">sigset_t</span> sa_mask;   <span class="hljs-comment">//只作用于信号捕捉函数执行期间，当我们执行信号捕捉函数时，如果相同的信号递达，则有可能产生异常，因此sa_mask可以设定进行屏蔽</span><br>    <span class="hljs-type">int</span> sa_flags;   <span class="hljs-comment">//传0,则默认本信号默认屏蔽，则sa_mask本信号位置为1,传1则不屏蔽。</span><br>    <span class="hljs-built_in">void</span> (*sa_restorer)(<span class="hljs-type">void</span>);    <span class="hljs-comment">//废弃了</span><br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act,<span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>signum:要捕捉的信号编号;<br><br>act:传入参数,指定新的信号处理方式;<br><br>oldact:传出参数,输出上一次的信号处理方式(不为<span class="hljs-number">0</span>的话)，不需要可以传入<span class="hljs-literal">NULL</span>;<br><br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><p><strong>特性</strong>：</p><ul><li>进程正常运行时，默认PCB中有一个信号屏蔽字mask，它决定了进程自动屏蔽哪些信号，当注册了某个信号捕捉函数，捕捉到该信号以后，要调用信号捕捉函数，而信号捕捉函数有可能执行很长时间，在这期间所屏蔽的信号不由mask来指定，而是用act中的sa_mask来指定，调用完信号处理函数后，再恢复为mask</li><li>当sa_flag&#x3D;0时，xxx信号捕捉函数执行期间，xxx信号会自动被该进程屏蔽</li><li>阻塞的常规信号不支持排队，多次产生只记录一次(也就是只处理一次)。(后32个实时信号支持排队)</li></ul><p><strong>示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_catch</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(signo==SIGINT)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;catch you!! %d\n&quot;</span>,signo);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(signo==SIGQUIT)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----catch you!! %d\n&quot;</span>,signo);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act,oldact;<br>    act.sa_handler=sig_catch;   <span class="hljs-comment">//设置回调函数</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);   <span class="hljs-comment">//将sa_mask屏蔽字清0,在sig_catch工作时有效</span><br>    act.sa_flags=<span class="hljs-number">0</span>;    <span class="hljs-comment">//默认处理动作</span><br><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);  <span class="hljs-comment">//注册信号捕捉函数</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">sigaction</span>(SIGQUIT,&amp;act,&amp;oldact);  <span class="hljs-comment">//注册信号捕捉函数</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>验证返回值</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun1&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun2&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act,oldact;<br>    act.sa_handler=fun1;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    act.sa_flags=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);<br>    <span class="hljs-keyword">if</span> (ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    act.sa_handler=fun2;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    oldact.<span class="hljs-built_in">sa_handler</span>(SIGINT);    <span class="hljs-comment">//sigaction传出参数oldact的sa_handler指向前一个处理SIGINT的函数的指针,也就是指向fun1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//跟signal结果一致</span><br>&gt; ./test<br>fun1<br>fun2<br>fun1<br></code></pre></td></tr></table></figure><h5 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h5><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191516575.png" alt="image-20240501211733359"></p><h4 id="子进程回收"><a href="#子进程回收" class="headerlink" title="子进程回收"></a>子进程回收</h4><h5 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h5><p><strong>产生条件</strong></p><ul><li><strong>当子进程状态发生变化，就会产生SIGCHLD信号</strong>(例如子进程终止)</li></ul><h5 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/types/sigset_t.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">catch_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-type">pid_t</span> wpid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">// while((wpid=wait(NULL))!=-1)&#123;</span><br>    <span class="hljs-comment">//循环回收多个子进程，防止多个子进程一起终止导致sa_mask屏蔽只回收一个，出现僵尸进程</span><br>    <span class="hljs-keyword">while</span>((wpid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,&amp;status,<span class="hljs-number">0</span>))!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFEXITED</span>(status))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------catch child id %d,ret=%d\n&quot;</span>,wpid,<span class="hljs-built_in">WEXITSTATUS</span>(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//使用阻塞屏蔽字来避免注册信号捕捉函数之前子进程终止</span><br>    <span class="hljs-type">sigset_t</span> mask;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;mask);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;mask,SIGCHLD);<br>    <span class="hljs-built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-keyword">if</span> ((pid=fork())==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>        act.sa_handler=catch_child;<br>        <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>        act.sa_flags=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sigaction</span>(SIGCHLD,&amp;act,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//解除阻塞</span><br>        <span class="hljs-built_in">sigprocmask</span>(SIG_UNBLOCK,&amp;mask,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m parent,pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-comment">/* while (1) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        &#125; */</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m child pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h4><p><strong>概念</strong>：</p><ul><li>系统调用分为两类：慢速系统调用和其他系统调用</li><li><code>慢速系统调用</code>：<strong>可能会使进程永远阻塞的一类系统调用</strong>，如果在阻塞期间收到一个信号，<strong>该系统调用就被中断，不再继续执行</strong>。这一类系统调用有read、write、pause、wait…</li></ul><p><strong>慢速系统调用中断问题</strong>：</p><ul><li>慢速系统调用被信号中断后将不会再被执行，而我们可以<strong>利用</strong>注册信号捕捉函数的<strong>sa_flags参数来设置被信号中断后系统调用是否重启。</strong></li><li><strong>不重启(默认)<strong>：<code>SA_INTERRURT</code>，</strong>重启</strong>：<code>SA_RESTART</code></li></ul><p><strong>扩展</strong>：</p><ul><li>sa_flags还有很多可选参数，如:捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可以将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号</li><li>如果<strong>想要信号传递复杂信息(例如结构体)<strong>，需要</strong>将sa_flags设置为SA_SIGINFO</strong>,然后使用void (*sa_sigaction)(int, siginfo_t *, void *); 这个函数来进行传递</li></ul><h2 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p><strong>概念</strong>：</p><ul><li><code>进程组</code>，也称之为作业，<strong>代表一个或多个进程的集合，每个进程都有属于的一个进程组</strong>，是为了简化对多个进程的管理</li><li>当<strong>父进程创建子进程的时候，默认子进程与父进程属于同一进程组</strong>。**进程组ID(PGID)&#x3D;&#x3D;第一个进程ID(组长进程)**。所以组长进程标识，其进程组ID&#x3D;&#x3D;其进程ID</li><li>可以使用kill -SIGKILL -进程组ID(取负值)来将整个进程组内的进程全部杀死</li><li>一个进程可以为自己或子进程设置进程组ID</li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>概念</strong>：</p><ul><li><strong>在Linux中，会话（Session）是指用户与操作系统交互的一段时间</strong></li><li><strong>我们常见的Linux session一般是指shell session</strong>。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。这表明<strong>会话是我们和shell交互的一个过程。</strong></li><li>tty:文字终端，只能输入命令无图形化</li><li>pts:虚拟终端，有图形化界面</li></ul><p><strong>创建会话注意事项</strong>：</p><ol><li><strong>调用进程不能是进程组组长</strong>，该进程变成新会话首进程</li><li>该进程成为一个新进程组的组长进程</li><li>需要root权限(ubuntu不需要)</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>该调用进程是组长进程，则出错返回</li><li><strong>建立新会话时，先调用fork，父进程终止，子进程调用setsid()-创建新会话</strong></li></ol><h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><p><strong>函数原型</strong>：</p><p><code>pid_t getsid(pid_t pid)</code>：<strong>获取进程所属的会话ID</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getsid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pid:进程ID;<br><span class="hljs-comment">//pid=0表示查看当前进程session ID</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回调用进程的会话ID;<br><br>失败:<span class="hljs-number">-1.</span>errno;<br></code></pre></td></tr></table></figure><h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><p><strong>函数原型</strong>：</p><p><code>pid_t setsid(void)</code>：<strong>创建一个会话，并以自己的进程ID设置进程组ID，同时也是新会话的ID</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">setsid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回调用进程的会话ID;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>调用了setsid函数的进程，既是新的会长，也是新的组长</li><li>调用进程不能是组长进程</li></ul></blockquote><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> ((pid=fork())&lt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process PID is %d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Group ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getpgid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Session ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getsid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">setsid</span>();   <span class="hljs-comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程，该进程组id即为会话进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Changed:\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process PID is %d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Group ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getpgid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Session ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getsid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//示例输出，每个人的输出结果都不一样</span><br>./test<br>child process PID is <span class="hljs-number">18261</span><br>Group ID of child is <span class="hljs-number">18260</span><br>Session ID of child is <span class="hljs-number">16952</span><br><br>~/test<br>&gt; Changed:<br>child process PID is <span class="hljs-number">18261</span><br>Group ID of child is <span class="hljs-number">18261</span><br>Session ID of child is <span class="hljs-number">18261</span><br></code></pre></td></tr></table></figure><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><strong>概念</strong>：</p><ul><li><code>守护进程</code>：叫做<strong>Daemon(精灵)进程</strong>，<strong>是Linux中的后台服务进程，通常独立于(脱离)控制终端并且周期性地执行某种人物或等待处理某些发生的事情</strong>，一般采用以d结尾的名字</li><li>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互，<strong>不受用户登陆、注销的影响</strong>，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现、ftp服务器、nfs服务器等</li><li>创建守护进程，最关键一步是调用setsid函数创建一个新的Session,并成为Session Leader</li></ul><p><strong>创建守护进程模型</strong>：</p><ol><li><strong>创建子进程，父进程退出</strong>。所有工作在子进程中进行形式上脱离了控制终端</li><li><strong>在子进程中创建新会话，使用setsid()函数</strong>，使子进程完全独立出来，脱离控制</li><li>**根据需要，改变守护进程工作目录，使用chdir()函数，防止占用可卸载的文件系统(例如U盘)**，防止放在可卸载的文件系统，使得守护进程服务无法执行</li><li><strong>重设文件权限掩码，使用umask()函数，防止继承的文件创建屏蔽字拒绝某些权限</strong>，增加守护进程灵活性</li><li>**关闭或重定向文件描述符，继承的打开文件不会用到(针对012默认文件描述符)**，重定向的话将012重定向到&#x2F;dev&#x2F;null这个空洞文件下，浪费系统资源，无法卸载</li><li>开始执行守护进程核心工作守护进程退出处理程序模型</li></ol><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid=fork();<br>    <span class="hljs-comment">//父进程终止</span><br>    <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//创建新会话</span><br>    pid=<span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;setsid error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//改变工作目录位置</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">chdir</span>(<span class="hljs-string">&quot;/home/moon/test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;chdir error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">umask</span>(<span class="hljs-number">0022</span>);  <span class="hljs-comment">//改变文件访问权限掩码</span><br>    <span class="hljs-built_in">close</span>(STDIN_FILENO);   <span class="hljs-comment">//关闭文件描述符0</span><br>    <span class="hljs-type">int</span> fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>,O_RDWR);   <span class="hljs-comment">//fd --&gt;0</span><br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">dup2</span>(fd, STDOUT_FILENO);   <span class="hljs-comment">//重定向 stdout和stderr </span><br>    <span class="hljs-built_in">dup2</span>(fd, STDERR_FILENO);<br>    <span class="hljs-comment">//模拟守护进程业务</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行</span><br>./test<br><span class="hljs-comment">//直接结束，是因为放到后台运行了，使用ps aux或者ps ajx查看</span><br>    <br><span class="hljs-comment">//终止命令</span><br>kill <span class="hljs-number">-9</span> test的进程ID<br></code></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p><strong>概念</strong>：</p><ul><li><p><code>线程</code>：<strong>可以看作是轻量级进程(LWP)，有独立的PCB，没有独立的进程地址空间(共享)</strong></p></li><li><p>在Linux下：</p><blockquote><p>线程：最小的执行单位</p><p>进程：最小分配资源单位，可看成是只有一个线程的进程</p></blockquote></li><li><p><code>ps -Lf 进程ID</code>：**可以查看线程号(LWP)**，CPU执行的最小单位</p></li><li><p>轻量级进程(LWP)，也有PCB，创建线程使用的底层函数和进程一样，都是克隆clone</p></li><li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p></li><li><p><strong>进程可以蜕变成线程</strong></p></li><li><p>线程可看作寄存器和栈的集合</p></li></ul><blockquote><p>注：线程ID和线程号是两个东西</p><ul><li><strong>线程ID：用来标识线程的</strong></li><li><strong>线程号：标识线程身份交给CPU使用分配执行时间</strong></li></ul></blockquote><p><strong>线程共享资源</strong>：</p><ol><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</li></ol><p><strong>线程非共享资源</strong>：</p><ol><li>线程ID</li><li>处理器现场(寄存器值)和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ol><p><strong>线程优缺点</strong>：</p><ul><li><p>优点：</p><blockquote><ol><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ol></blockquote></li><li><p>缺点：</p><blockquote><ol><li>库函数，不稳定</li><li>调试、编写困难、gdb不支持</li><li>对信号支持不好</li></ol></blockquote></li></ul><blockquote><p>注：优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大</p></blockquote><h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><p><strong>注</strong>：</p><ul><li><strong>在Linux环境中，所有线程特点，失败均直接返回错误号！</strong></li><li>所以得到的ret就是错误号，<code>需要通过strerror来对错误号进行解读，说明错误原因</code></li></ul><h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><p><strong>函数原型</strong>：</p><p><code>pthread_t pthread_self(void)</code>：<strong>获取线程ID</strong>，其作用对应进程中getpid()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">//pthread_t 类型，在Linux下本质是无符号整数(%lu)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:获取当前线程ID;<br></code></pre></td></tr></table></figure><h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><p><strong>函数原型</strong>：</p><p><code>int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg)</code>：<strong>创建一个新线程</strong>，其作用对应进程中fork()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">//pthread_t 类型，在Linux下本质是无符号整数(%lu)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> detachstate;  <span class="hljs-comment">//线程的分离状态</span><br>    <span class="hljs-type">int</span> schedpolicy;  <span class="hljs-comment">//线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;  <span class="hljs-comment">//线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;  <span class="hljs-comment">//线程的继承性</span><br>    <span class="hljs-type">int</span> scope;  <span class="hljs-comment">//线程的作用域</span><br>    <span class="hljs-type">size_t</span> guardsize;  <span class="hljs-comment">//线程栈末尾的警戒缓冲区大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;  <span class="hljs-comment">//线程的栈设置</span><br>    <span class="hljs-type">void</span>* stackaddr;  <span class="hljs-comment">//线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;  <span class="hljs-comment">//线程栈的大小</span><br>&#125;<span class="hljs-type">pthread_attr_t</span>;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread,<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>thread:传出参数，新创建的子线程ID;<br><br>attr:线程属性参数，通常传<span class="hljs-literal">NULL</span>，表示使用线程默认属性;<br><br>start_routine:函数指针，子线程回调函数。创建成功，pthread_create函数返回时，该函数会被自动调用;<br><br>arg:线程主函数执行期间所使用的参数(参数<span class="hljs-number">3</span>函数的参数，没有传<span class="hljs-literal">NULL</span>);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><p><strong>设置线程属性</strong></p><ul><li><code>pthread_attr_t</code>：线程属性结构体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> detachstate;  <span class="hljs-comment">//线程的分离状态</span><br>    <span class="hljs-type">int</span> schedpolicy;  <span class="hljs-comment">//线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;  <span class="hljs-comment">//线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;  <span class="hljs-comment">//线程的继承性</span><br>    <span class="hljs-type">int</span> scope;  <span class="hljs-comment">//线程的作用域</span><br>    <span class="hljs-type">size_t</span> guardsize;  <span class="hljs-comment">//线程栈末尾的警戒缓冲区大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;  <span class="hljs-comment">//线程的栈设置</span><br>    <span class="hljs-type">void</span>* stackaddr;  <span class="hljs-comment">//线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;  <span class="hljs-comment">//线程栈的大小</span><br>&#125;<span class="hljs-type">pthread_attr_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_attr_init(pthread_attr_t *attr)</code>：<strong>初始化线程属性结构体</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>attr:传出参数,要初始化的线程属性结构体;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_attr_destroy(pthread_attr_t *attr)</code>：<strong>销毁线程属性所占用的资源</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>attr:要销毁的线程属性结构体;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate)</code>：<strong>设置线程属性是分离还是非分离状态</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>attr:线程属性结构体;<br><br>detachstate:分离状态;<br><span class="hljs-comment">//取值：</span><br>PTHREAD_CREATE_DETACHED:分离状态;<br>PTHREAD_CREATE_JOINABLE:非分离状态;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><p><strong>pthread_create()示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">//子线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//主线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),tid);<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：因为线程是不共享errno变量，所以直接返回的就是errno，<strong>所以得到的ret就是errno编号，需要通过strerror来对errno说明错误原因</strong></p></blockquote><p><strong>创建多个子线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">sleep</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--I&#x27;m %dth thread:pid=%d,tid=%lu\n&quot;</span>,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-comment">//因为线程共享i变量，而线程创建和启动可能会有延迟，可能会直到i改变了才开始运行，所以得定义一个局部变量，但是也有另一个方法</span><br>        <span class="hljs-type">int</span> *arg=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(i);<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,arg);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-comment">// sleep(i);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--I&#x27;m %dth thread:pid=%d,tid=%lu\n&quot;</span>,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,(<span class="hljs-type">void</span> *)&amp;i);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">sleep</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置线程属性示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread：pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">pthread_attr_t</span> attr;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_init error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置线程分离</span><br>    <span class="hljs-built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);<br>    <span class="hljs-comment">//设置线程非分离</span><br>    <span class="hljs-comment">// pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_JOINABLE);</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_setdetachstate error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,&amp;attr,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_attr_destroy</span>(&amp;attr);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_destroy error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h4><p><strong>函数原型</strong>：</p><p><code>void pthread_exit(void *retval)</code>：<strong>退出当前线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>retval:表示线程退出状态(退出值)，无退出值，传<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><strong>exit函数是退出进程的函数，所以不能使用exit退出线程</strong>，要不然会将这个进程杀死导致其他线程也被删除！</li><li>return是返回到调用者，也不是退出的意思，但是你也可以返回</li><li>pthread_exit是将调用该函数的线程退出</li></ul></blockquote><h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><p><strong>函数原型</strong>：</p><p><code>int pthread_join(pthread_t thread,void **retval)</code>：<strong>阻塞等待线程退出(回收指定线程)，获取线程退出状态</strong>。其作用对应进程中waitpid()函数，线程不回收跟进程一样会产生僵尸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>thread:线程ID;<br><br>retval:传出参数，存储线程结束状态。因为线程结束回调函数返回值为<span class="hljs-type">void</span>*,所以接受返回值就需要<span class="hljs-type">void</span>**;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>&#123;<br>    <span class="hljs-type">int</span> var;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *tval;<br>    tval=(thrd *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> thrd));<br>    tval-&gt;var=<span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">strcpy</span>(tval-&gt;str,<span class="hljs-string">&quot;hello thread&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)tval;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *retval;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,(<span class="hljs-type">void</span> **)&amp;retval);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,retval-&gt;var,retval-&gt;str);<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>&#123;<br>    <span class="hljs-type">int</span> var;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-comment">/* struct thrd *tval;</span><br><span class="hljs-comment">    tval=(thrd *)malloc(sizeof(struct thrd)); */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>* tval=(thrd *)arg;<br>    tval-&gt;var=<span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">strcpy</span>(tval-&gt;str,<span class="hljs-string">&quot;hello thread&quot;</span>);<br>    <span class="hljs-comment">//返回的是主线程的arg地址，所以我在回收后直接使用arg也可以的到返回值</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)tval;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> arg;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *retval;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,(<span class="hljs-type">void</span> *)&amp;arg);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,(<span class="hljs-type">void</span> **)&amp;retval);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,retval-&gt;var,retval-&gt;str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,arg.var,arg.str);<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><p><strong>函数原型</strong>：</p><p><code>int pthread_detach(pthread_t thread)</code>：<strong>实现线程分离，可以将指定线程分离出线程组自立门户，线程结束后自动释放资源，不会残留资源在内核中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>thread:待分离线程ID;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><code>线程分离状态</code>：指定该状态，<strong>线程主动与主控线程断开关系，线程结束后，其退出状态不由其他线程获取，而直接自己自动释放</strong>。网络、多线程服务器常用！</li><li>进程若有该分离机制，将不会产生僵尸进程。</li><li><strong>也可以使用pthread_create函数参2(线程属性)来设置线程分离。</strong></li></ul></blockquote><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置线程分离,线程终止会自动清理pcb,无需回收</span><br>    ret=<span class="hljs-built_in">pthread_detach</span>(tid);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_detach error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;join ret=%d\n&quot;</span>,ret);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//运行</span><br>&gt; ./test<br>thread:pid=<span class="hljs-number">12954</span>,tid=<span class="hljs-number">139659550131904</span><br>join ret=<span class="hljs-number">22</span><br>pthread_join error：Invalid argument  <span class="hljs-comment">//发现找不到这个线程，说明线程被pthread_detach分离了</span><br></code></pre></td></tr></table></figure><h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><p><strong>函数原型</strong>：</p><p><code>int pthread_cancel(pthread_t thread)</code>：<strong>杀死(取消)线程</strong>，对应进程中的kill()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>thread:要杀死(取消)的线程ID;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><strong>杀死(取消)一个线程，并不是立即杀死(取消)，而是得等到到达了一个取消点，再进行取消</strong></li><li><code>取消点</code>：<strong>是线程检查是否被取消，并按请求进行动作的一个位置，通常是一些系统调用的位置</strong>，可以用man 7 pthreads 查看具备这些取消点的系统调用列表</li><li><strong>被pthread_cancel()杀死的线程，将会返回-1，使用pthread_join()函数回收</strong></li></ul></blockquote><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread：pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>    ret=<span class="hljs-built_in">pthread_cancel</span>(tid); <span class="hljs-comment">//终止线程</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_cancel error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>    <br>    <br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">//运行</span><br>&gt; ./test<br>main:pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482618086656</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br><span class="hljs-comment">//将会打印5次thread就阻塞在主线程的while中则tid线程被终止了</span><br></code></pre></td></tr></table></figure><h4 id="pthread-testcancel函数"><a href="#pthread-testcancel函数" class="headerlink" title="pthread_testcancel函数"></a>pthread_testcancel函数</h4><p><strong>函数原型</strong>：</p><p><code>void pthread_testcancel(void)</code>：<strong>为pthread_cancel函数自定义添加取消点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_testcancel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//将以下两句注释则无法取消这个线程因为没有取消点</span><br>        <span class="hljs-comment">/* printf(&quot;thread：pid=%d,tid=%lu\n&quot;,getpid(),pthread_self());</span><br><span class="hljs-comment">        sleep(1); */</span><br>        <span class="hljs-built_in">pthread_testcancel</span>();  <span class="hljs-comment">//自定义取消点，添加取消点则线程可以被杀死</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    ret=<span class="hljs-built_in">pthread_cancel</span>(tid); <span class="hljs-comment">//终止线程</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_cancel error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//如果没有取消点，则将会一直阻塞在子线程的while(1)循环中</span><br></code></pre></td></tr></table></figure><h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul><li><strong>malloc和mmap申请的内存可以被其他线程释放(因为线程共享内存)</strong></li><li><strong>应避免在多线程模型中调用fork，除非马上exec</strong>，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</li><li>信号的复杂语义很难和多线程共存，<strong>应避免在多线程引入信号机制</strong></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>概念</strong>：</p><ul><li><code>同步</code>：即协同步调，<strong>按预定的先后次序运行</strong></li><li><code>线程同步</code>：<strong>指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能</strong></li><li><strong>同步目的：为了避免数据混乱，解决与时间有关的错误</strong>。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制</li><li><strong>所有”多个控制流，共同操作一个共享资源”的情况，都需要同步</strong></li></ul><p><strong>数据混乱原因</strong>：</p><ol><li>资源共享</li><li>调度随机(意味着数据访问会出现竞争)</li><li>线程间缺乏必要的同步机制</li></ol><h3 id="互斥量-锁-mutex"><a href="#互斥量-锁-mutex" class="headerlink" title="互斥量(锁)mutex"></a>互斥量(锁)mutex</h3><p><strong>函数原型</strong>：</p><ul><li><code>pthread_mutex_t lock</code>：<strong>定义锁(创建锁)</strong></li></ul><blockquote><p>注：<strong>pthread_mutex_t类型</strong>，其本质是一个结构体，为简化理解，应用时可忽略其实现细节，<strong>简单当成整数看待</strong></p></blockquote><ul><li><code>int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr)</code>：<strong>初始化互斥</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex,<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:要初始化的互斥量(锁);<br><br>mutexattr:锁属性参数，通常传入<span class="hljs-literal">NULL</span>,表示默认属性;<br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_MUTEX_INITIALIZER;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex)</code>：<strong>加锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex)</code>：<strong>解锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code>：<strong>尝试加锁(非阻塞)，成功就加锁，失败则返回</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号 如：EBUSY;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code>：<strong>销毁互斥锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>互斥锁mutex变量的取值为0或1</li><li>尽量保证锁的粒度，越小越好**(访问贡献数据前加锁，访问结束立即解锁)**</li></ul></blockquote><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-comment">//定义一把互斥锁(需要全局变量)</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">//加锁</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello &quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world\n&quot;</span>);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_mutex_init error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//初始化互斥锁,可以认为锁的值为1</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">//加锁,mutex--,阻塞线程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HELLO &quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WORLD\n&quot;</span>);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">//解锁，mutex++，唤醒阻塞在锁上的进程</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);   <span class="hljs-comment">//销毁互斥锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_mutex_destroy error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念</strong>：</p><ul><li>死锁是一种使用锁不恰当导致的现象，并不是一把锁</li></ul><p><strong>产生情况</strong>:</p><ol><li>对一个锁反复lock</li><li>两个线程，线程1持有A锁，请求B锁，线程2持有B锁，请求A锁，导致死循环</li></ol><h3 id="读写锁rwlock"><a href="#读写锁rwlock" class="headerlink" title="读写锁rwlock"></a>读写锁rwlock</h3><p><strong>概念</strong>：</p><ul><li>与互斥量类似，但<strong>读写锁</strong>允许更高的并行性。其特性为:<code>写独占，读共享</code></li><li><strong>以读方式给数据加锁 称之为读锁</strong></li><li><strong>以写方式给数据加锁 称之为写锁</strong></li></ul><p><strong>特性</strong>：</p><ul><li><strong>锁只有一把</strong></li><li><strong>写锁优先级高</strong></li><li><strong>写独占，读共享</strong></li></ul><p><strong>读写锁使用特性</strong>：</p><ol><li><strong>读写锁是”写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</strong></li><li><strong>读写锁是”读模式加锁”时，如果线程以读模式对其加锁会成功;如果线程以写模式对其加锁会阻塞</strong></li><li>读写锁是”读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程，那么读写锁会阻塞随后的读模式加锁请求。优先满足写模式锁。<code>读锁、写锁并行阻塞，写锁优先级高</code>。</li><li><strong>读写锁非常适合对于数据结构读的次数大于写的情况</strong></li></ol><p><strong>函数原型</strong>：</p><ul><li><code>int pthread_rwlock_init(pthread_rwlock_t *rwlock,const pthread_rwlockattr_t attr)</code>：<strong>初始化读写锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock,<span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> attr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br>attr:读写锁属性参数，默认属性传<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_RWLOCK_INITIALIZER;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)</code>：<strong>读模式加锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)</code>：<strong>尝试以读模式加锁，成功就加锁，失败则返回</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)</code>：<strong>以写模式加锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)</code>：<strong>尝试以写模式加锁，成功就加锁，失败则返回</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)</code>：<strong>解锁</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)</code>：<strong>销毁读写锁属性所占用资源</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> counter;<br><span class="hljs-comment">//定义一把读写锁(需要全局变量)</span><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">th_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        t=counter;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;======write %d: %lu:counter=%d ++counter=%d\n&quot;</span>,i,<span class="hljs-built_in">pthread_self</span>(),t,++counter);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">th_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span> *)arg;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------read %d: %lu: %d\n&quot;</span>,i,<span class="hljs-built_in">pthread_self</span>(),counter);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">2000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid[<span class="hljs-number">8</span>];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//初始化读写锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_rwlock_init error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        <span class="hljs-comment">// int *arg=new int(i);</span><br>        <span class="hljs-comment">// ret=pthread_create(&amp;tid[i],NULL,th_write,(void *)arg);   //以写模式加锁</span><br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid[i],<span class="hljs-literal">NULL</span>,th_write,(<span class="hljs-type">void</span> *)&amp;i);   <span class="hljs-comment">//以写模式加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-comment">// int *arg=new int(i);</span><br>        <span class="hljs-comment">// ret=pthread_create(&amp;tid[i+3],NULL,th_read,(void *)arg);   //以读模式加锁</span><br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid[i+<span class="hljs-number">3</span>],<span class="hljs-literal">NULL</span>,th_read,(<span class="hljs-type">void</span> *)&amp;i);   <span class="hljs-comment">//以读模式加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;++i)&#123;<br>        ret=<span class="hljs-built_in">pthread_join</span>(tid[i], <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);   <span class="hljs-comment">//销毁读写锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_rwlock_destroy error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><ul><li><strong>条件变量本身不是锁，但是通常需要结合互斥锁来使用</strong></li></ul><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><ul><li><code>int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr)</code>：<strong>初始化条件变量</strong>，一般是动态初始化，在函数体用到再初始化，但是也可以使用静态初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *attr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>attr:条件变量属性参数，默认属性传<span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><p><code>int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex)</code>：</p><blockquote><p>函数作用：</p><ol><li><strong>阻塞等待一个条件cond满足</strong></li><li><strong>释放已掌握的互斥锁mutex(解锁)</strong></li><li><strong>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁(加锁)</strong></li></ol><p>1、2步是一个原子操作</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>mutex:已掌握的互斥锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_cond_timedwait(pthread_cond_t *cond,pthread_cond_mutex_t *mutex,const struct timespec *abstime)</code>：<strong>定时等待一个条件满足</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">pthread_cond_mutex_t</span> *mutex,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abstime)</span></span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span>&#123;<br>    <span class="hljs-type">time_t</span> tv_sec;  <span class="hljs-comment">//秒</span><br>    <span class="hljs-type">long</span> tv_nsec;   <span class="hljs-comment">//纳秒</span><br>&#125;;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>mutex:互斥锁;<br><br>abstime:定时时长,需要传绝对时间;<br>绝对时间:这里的绝对时间是从unix元年也就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>开始，假设abs_timeout=<span class="hljs-number">3</span>就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>日的<span class="hljs-number">0</span>点<span class="hljs-number">0</span>分<span class="hljs-number">3</span>秒;<br><br><span class="hljs-comment">//定时1秒示例</span><br><span class="hljs-type">time_t</span> cur=<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//获取当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> t; <span class="hljs-comment">//定义timespec结构体变量</span><br>t.tv_sec=cur+<span class="hljs-number">1</span>;   <span class="hljs-comment">//定时1秒</span><br>t.tv_nsec=t.tv_sec+<span class="hljs-number">100</span>;<br><span class="hljs-built_in">sem_timedwait</span>(&amp;sem,&amp;t);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_cond_signal(pthread_cond_t *cond)</code>：<strong>通知函数，一次通知至少一个线程</strong>，也可以唤醒多个线程，但是<strong>通常用于通知一个线程</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>pthread_cond_broadcast()</code>：<strong>广播函数，一次通知多个线程</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><ul><li><code>int pthread_cond_destroy(pthread_cond_t *cond)</code>：<strong>销毁条件变量属性所占用资源</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p><strong>概念</strong>：</p><ul><li><code>生产者消费者模型</code>:<strong>由生产者进行生产数据，生产者生产的数据将会放置到一个公共区域，由消费者从公共区域拿取消费</strong></li></ul><p><strong>生产者模型工作流程</strong>：</p><ol><li>生产数据</li><li>加锁 pthread_mutex_lock</li><li>将数据放置到公共区域</li><li>解锁 pthread_mutex_unlock</li><li>通知阻塞在条件变量上的线程 pthread_cond_signal或pthread_cond_broadcast</li><li>循环生产后续数据</li></ol><p><strong>消费者模型工作流程</strong>：</p><ol><li>创建锁 mutex</li><li>初始化 pthread_mutex_init</li><li>加锁 pthread_mutex_lock</li><li>等待条件满足：pthread_cond_wait<ol><li>阻塞等条件变量</li><li>解锁 unlock</li><li>加锁 lock</li></ol></li><li>访问共享数据</li><li>解锁、释放条件变量，释放锁</li></ol><p><strong>实现示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *head;<br><br><span class="hljs-comment">//定义并初始化互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-comment">//定义并初始化条件变量</span><br><span class="hljs-type">pthread_cond_t</span> has_data=PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp=(msg *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> msg));<br>        mp-&gt;num=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;   <span class="hljs-comment">//模拟生产数据</span><br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,mp-&gt;num);<br><br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//头插法，写公共区域，将数据放置到公共区域</span><br>        mp-&gt;next=head;<br>        head=mp;<br>        ret=<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-comment">//通知消费者,唤醒阻塞在条件变量has_data上的线程</span><br>        ret=<span class="hljs-built_in">pthread_cond_signal</span>(&amp;has_data);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_signal error&quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            ret=<span class="hljs-built_in">pthread_cond_wait</span>(&amp;has_data,&amp;mutex);    <span class="hljs-comment">//阻塞等待条件变量,返回时会重新加锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_wait error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//消费数据，读数据</span><br>        <span class="hljs-comment">//头删法，取数据</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp;<br>        mp=head;<br>        head=mp-&gt;next;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer:%d\n&quot;</span>,mp-&gt;num);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁互斥量</span><br><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-built_in">free</span>(mp);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多个消费者示例</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *head;<br><br><span class="hljs-comment">//定义并初始化互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-comment">//定义并初始化条件变量</span><br><span class="hljs-type">pthread_cond_t</span> has_data=PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp=(msg *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> msg));<br>        mp-&gt;num=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;   <span class="hljs-comment">//模拟生产数据</span><br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,mp-&gt;num);<br><br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//头插法，写公共区域，将数据放置到公共区域</span><br>        mp-&gt;next=head;<br>        head=mp;<br>        ret=<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-comment">//通知消费者,唤醒阻塞在条件变量has_data上的线程</span><br>        ret=<span class="hljs-built_in">pthread_cond_signal</span>(&amp;has_data);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_signal error&quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//循环等待，防止虚假唤醒</span><br>        <span class="hljs-keyword">while</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            ret=<span class="hljs-built_in">pthread_cond_wait</span>(&amp;has_data,&amp;mutex);    <span class="hljs-comment">//阻塞等待条件变量,返回时会重新加锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_wait error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//消费数据，读数据</span><br>        <span class="hljs-comment">//头删法，取数据</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp;<br>        mp=head;<br>        head=mp-&gt;next;<br>        <br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁互斥量</span><br><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),mp-&gt;num);<br>        <span class="hljs-built_in">free</span>(mp);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li><code>虚假唤醒</code>：因为pthread_cond_wait会进行解锁操作，多个消费者同时阻塞在一个锁上，<strong>容易导致一个线程消费数据解锁后，另一线程拿到锁，但是公共区域没有数据所导致的虚假唤醒</strong></li></ul></blockquote><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><ul><li><code>信号量</code>：是一个既能保证同步、数据不混乱，又能提高线程并发，<strong>可以用来实现多线程间对共享资源进行共享，相当于初始化为n的互斥量，n值表示可以同时访问共享数据区的线程数</strong></li><li><strong>可以应用于线程、进程间同步</strong></li></ul><h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><ul><li><code>int sem_init(sem_t *sem,int pshared,unsigned int value)</code>：<strong>初始化信号量</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量变量;<br><br>pshared:指定是否在线程、进程间共享;<br><span class="hljs-comment">//选择</span><br><span class="hljs-number">0</span>:表示线程间同步;<br><span class="hljs-number">1</span>(非<span class="hljs-number">0</span>):表示进程间同步;<br><br>value:N值，指定同时访问的线程数;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int sem_wait(sem_t *sem)</code>：<strong>相当于加锁，信号量值大于0，则信号量值–；信号量等于0，则造成阻塞</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int sem_trywait(sem_t *sem)</code>：<strong>尝试加锁，成功则信号量–，失败则返回，非阻塞的sem_wait</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int sem_timedwait(sem_t *sem,const struct timespec *abs_timeout)</code>：<strong>设置定时加锁，定时的sem_wait</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_timedwait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span></span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span>&#123;<br>    <span class="hljs-type">time_t</span> tv_sec;  <span class="hljs-comment">//秒</span><br>    <span class="hljs-type">long</span> tv_nsec;   <span class="hljs-comment">//纳秒</span><br>&#125;;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br>abs_timeout:定时时长，需要传绝对时间;<br>绝对时间:这里的绝对时间是从unix元年也就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>开始，假设abs_timeout=<span class="hljs-number">3</span>就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>日的<span class="hljs-number">0</span>点<span class="hljs-number">0</span>分<span class="hljs-number">3</span>秒;<br><br><span class="hljs-comment">//定时1秒示例</span><br><span class="hljs-type">time_t</span> cur=<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//获取当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> t; <span class="hljs-comment">//定义timespec结构体变量</span><br>t.tv_sec=cur+<span class="hljs-number">1</span>;   <span class="hljs-comment">//定时1秒</span><br>t.tv_nsec=t.tv_sec+<span class="hljs-number">100</span>;<br><span class="hljs-built_in">sem_timedwait</span>(&amp;sem,&amp;t);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int sem_post(sem_t *sem)</code>：<strong>相当于解锁，当信号量&lt;N，则信号量++；当信号量&#x3D;&#x3D;N时，则造成阻塞</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><ul><li><code>int sem_destroy(sem_t *sem)</code>：<strong>释放信号量属性所占用资源</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h可以应用于线程、进程间同步&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure><h4 id="生产者消费者模型-1"><a href="#生产者消费者模型-1" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p><strong>实现示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 5</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> queue[NUM];     <span class="hljs-comment">//全局数组实现环形队列</span><br><span class="hljs-type">sem_t</span> blank_num,prod_num;  <span class="hljs-comment">//共享区空余信号量，生产产品信号量</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;blank_num);  <span class="hljs-comment">//要生产产品得减少空余信号量</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        queue[i]=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,queue[i]);<br>        <span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">//生产成功产品，则产品信号量增加</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br><br>        i=(i+<span class="hljs-number">1</span>)%NUM;   <span class="hljs-comment">//借助下标实现环形</span><br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num);   <span class="hljs-comment">//消费产品，则产品信号量--(产品&gt;0)，否则阻塞</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),queue[i]);<br>        queue[i]=<span class="hljs-number">0</span>;<br>        ret=<span class="hljs-built_in">sem_post</span>(&amp;blank_num);  <span class="hljs-comment">//消费了产品，则产品信号量--</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">sem_init</span>(&amp;blank_num,<span class="hljs-number">0</span>,NUM);  <span class="hljs-comment">//初始化空余信号量为5，线程间共享</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init blank_num error&quot;</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;prod_num,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//初始化产品信号量为0</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init prod_num error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>   <br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多个消费者单个生产者示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_CONSUMERS 3 <span class="hljs-comment">// 设置消费者数量</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> queue[NUM];     <span class="hljs-comment">//全局数组实现环形队列</span><br><span class="hljs-type">sem_t</span> blank_num,prod_num;  <span class="hljs-comment">//共享区空余信号量，生产产品信号量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;blank_num);  <span class="hljs-comment">//要生产产品得减少空余信号量</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        queue[i]=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--producer:%d\n&quot;</span>,queue[i]);<br>        <span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">//生产成功产品，则产品信号量增加</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;   <span class="hljs-comment">//借助下标实现环形</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num);   <span class="hljs-comment">//消费产品，则产品信号量--(产品&gt;0)，否则阻塞</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        <br>        <span class="hljs-comment">// 循环等待直到读取到非零值</span><br>        <span class="hljs-keyword">while</span>(queue[i] == <span class="hljs-number">0</span>) &#123;<br>            ret=<span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">// 恢复生产者信号量以防止死锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 小睡一会儿以防止忙等</span><br>            ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num); <span class="hljs-comment">// 重新等待</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),queue[i]);<br>        queue[i]=<span class="hljs-number">0</span>;<br>        ret=<span class="hljs-built_in">sem_post</span>(&amp;blank_num);  <span class="hljs-comment">//消费了产品，则产品信号量--</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> producer_tid;<br>    <span class="hljs-type">pthread_t</span> consumer_tids[NUM_CONSUMERS];<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br>    ret=<span class="hljs-built_in">sem_init</span>(&amp;blank_num,<span class="hljs-number">0</span>,NUM);  <span class="hljs-comment">//初始化空余信号量为5，线程间共享</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init blank_num error&quot;</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;prod_num,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//初始化产品信号量为0</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init prod_num error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;producer_tid,<span class="hljs-literal">NULL</span>,producer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create producer error&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; ++i) &#123;<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;consumer_tids[i],<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(producer_tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join producer error&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; ++i) &#123;<br>        ret=<span class="hljs-built_in">pthread_join</span>(consumer_tids[i],<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后台开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>后台开发</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arch安装与配置</title>
    <link href="/2024/05/19/arch%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/05/19/arch%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Arch安装与配置"><a href="#Arch安装与配置" class="headerlink" title="Arch安装与配置"></a>Arch安装与配置</h1><h2 id="Arch安装"><a href="#Arch安装" class="headerlink" title="Arch安装"></a>Arch安装</h2><h3 id="连接wifi"><a href="#连接wifi" class="headerlink" title="连接wifi"></a>连接wifi</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">iwctl<br><span class="hljs-meta prompt_">   #</span><span class="language-bash">进入到<span class="hljs-comment">#[iwctl]后</span></span><br>   station wlan0 scan   #默认网卡驱动都是wlan0<br>   station wlan0 get-networks    #获取可连接wifi列表<br>   station wlan0 connect 你要连接的wifi名<br><span class="hljs-meta prompt_">   #</span><span class="language-bash">输入密码</span><br>   quit   #退出<br>   <br><span class="hljs-meta prompt_">   #</span><span class="language-bash">测试网络连接</span><br>   ping baidu.com<br></code></pre></td></tr></table></figure><h3 id="时间同步服务启动"><a href="#时间同步服务启动" class="headerlink" title="时间同步服务启动"></a>时间同步服务启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">timedatectl set-ntp true<br>timedatectl status   #查看服务是否运行<br></code></pre></td></tr></table></figure><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">fdisk -l   #查看电脑所有分区<br>fdisk /dev/nevm0n1     #进入为arch压缩卷的磁盘，看空间大小判断<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进行创建分区</span><br>p   #查看磁盘布局<br>n   #创建分区<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入要创建分区的编号，我们这边先创建default数字的后一位，比方说default为8，就先输入9</span><br>9     #该编号分区用于swap分区<br>回车<br>+10G       #根据自己分配给arch的空间大小决定，如果只有20G左右分配4G就够了，我这边是分配了80G<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">继续创建分区</span><br>n<br>直接回车，按默认编号处理<br>回车<br>回车<br><br>w    #保存分区布局<br><br>fdisk -l   #看看是否创建成功<br></code></pre></td></tr></table></figure><h3 id="进行分区配置"><a href="#进行分区配置" class="headerlink" title="进行分区配置"></a>进行分区配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.btrfs /dev/nvme0n1p8       #选择刚刚为arch分区分配大的分区，小的也就是10G的是用于swap分区的<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建swap分区</span><br>mkswap /dev/nvme0n1p9          #选择刚刚分配的10G，也就是刚刚创建的两个分区的小的那个<br>swapon /dev/nvme0n1p9<br><br>mount /dev/nvme0n1p8 /mnt         #根据你自己的编号改，这个盘是mkfs.btrfs /dev/nevm0n1p8这一步一样的盘<br>mkdir /mnt/boot<br><br>fdisk -l     #查看efi分区的编号,我这里是/dev/nevm0n1p1<br>mount /dev/nvme0n1p1 /mnt/boot/<br></code></pre></td></tr></table></figure><p>   最终布局：</p><table><thead><tr><th>&#x2F;dev&#x2F;nvme0n1p1</th><th>Size</th><th>Type</th><th>mount</th></tr></thead><tbody><tr><td>p1</td><td>300M</td><td>EFI System</td><td>&#x2F;mnt&#x2F;boot</td></tr><tr><td>p8</td><td>70G</td><td>btrfs</td><td>&#x2F;mnt</td></tr><tr><td>p9</td><td>10G</td><td>swap</td><td>swap</td></tr></tbody></table><h3 id="手动添加国内镜像"><a href="#手动添加国内镜像" class="headerlink" title="手动添加国内镜像"></a>手动添加国内镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/pacman.d/mirrorlist<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在第一个Server镜像上添加</span><br>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch<br>Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">crtl+x保存，输入y，回车</span><br></code></pre></td></tr></table></figure><h3 id="下载基本环境"><a href="#下载基本环境" class="headerlink" title="下载基本环境"></a>下载基本环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Sy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载环境,根据cpu选择intel和amd</span><br>pacstrap -K /mnt base base-devel linux linux-firmware sudo nano vim networkmanager intel-ucode/amd-ucode<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果安装报错，则需要更新keyring</span><br>pacman -Sy archlinux-keyring<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新安装</span><br></code></pre></td></tr></table></figure><p>###生成静态配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">检查是否正确写入硬盘</span><br>cat /mnt/etc/fstab<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入mnt</span><br>arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>1.更改时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">更改时区</span><br>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置生效</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><p>2.配置语言环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">配置语言环境</span><br>nano /etc/locale.gen<br><span class="hljs-meta prompt_">#</span><span class="language-bash">crtl+w搜索 en_US.UTF-8和zh_CN.UTF-8将这两个前面的‘<span class="hljs-comment">#&#x27;去掉</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">按crtl+x保存，输入y,回车</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">语言环境下载</span><br>locale-gen<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置系统语言，现在先设置en_US.UTF-8,中文配置后面再说</span><br>nano /etc/locale.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加以下内容</span><br>LANG=en_US.UTF-8<br><span class="hljs-meta prompt_">#</span><span class="language-bash">按crtl+x保存，输入y,回车</span><br></code></pre></td></tr></table></figure><p>3.配置用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">配置hostname请求用户名</span><br>nano /etc/hostname<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入</span><br>archlinux<br><span class="hljs-meta prompt_">#</span><span class="language-bash">按crtl+x保存，输入y,回车</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开启网络管理服务开机自启动</span><br>systemctl enable NetworkManager<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置root密码</span><br>passwd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入你的密码</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加自定义用户</span><br>useradd -m -G wheel -s /bin/bash 用户名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置自定义用户密码</span><br>passwd 用户名<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入密码</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置自定义用户权限</span><br>visudo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">找到<span class="hljs-comment"># %wheel ALL=(ALL:ALL) ALL,然后将前面的&#x27;#&#x27;去掉</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">按i进入编辑模式，删掉<span class="hljs-comment">#后，按esc,输入:wq保存</span></span><br></code></pre></td></tr></table></figure><p>4.下载启动程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S grub efibootmgr os-prober<br></code></pre></td></tr></table></figure><p>5.编辑启动项文件设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/default/grub<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启用检测启动项设置</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">找到GRUB_DISABLE_OS_PROBER=<span class="hljs-literal">false</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将前面的<span class="hljs-string">&#x27;#&#x27;</span>去掉</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">按crtl+x保存，输入y,回车</span><br></code></pre></td></tr></table></figure><p>6.启动项生成与系统下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB<br><br>grub-mkconfig -o /boot/grub/grub.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看windows系统的启动项<span class="hljs-built_in">id</span>，blkid的是efi的分区才是windows启动项位置</span><br>blkid /dev/nvme0n1p1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">记住信息中的UUID,我这里是A3E3-C1FA</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置grub启动时检测出windows启动项配置</span><br>nano /boot/grub/grub.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">crtl+w查找os-prober,在BEGIN和END中添加</span><br>menuentry &#x27;Microsoft Window 11&#x27; &#123;<br>insmod part<br>insmod fat<br>insmod chain<br>search --fs-uuid --no-floppy --set=root A3E3-C1FA      #root后面填的是刚刚记录的uuid<br>chainloader ($&#123;root&#125;)/EFI/Microsoft/Boot/bootmgfw.efi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">按crtl+x保存，输入y,回车</span><br><br>exit   #退出mnt配置<br></code></pre></td></tr></table></figure><p>7.挂载硬盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount -R /mnt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启</span><br>reboot<br></code></pre></td></tr></table></figure><ul><li>重启后就可以自由选择要去的系统，你可以先检查是否能够正常启动windows，然后可以把u盘拔出</li></ul><h2 id="Arch桌面配置"><a href="#Arch桌面配置" class="headerlink" title="Arch桌面配置"></a>Arch桌面配置</h2><p><strong>注</strong>：我这里为了方便使用了别人的dotfiles的自动化下载脚本，你也可以可以跟着网上的教学下载其他桌面环境和配置。</p><p><strong>配置信息</strong>：hyprland+alacritty+rofi的一系列配置，是一个平铺桌面，具体效果如下图，当然这个壁纸是我自己设定的，如何设定动态壁纸可以看后面</p><p><strong>效果展示</strong>：<br><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191524053.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191524055.png" alt="image"></p><ul><li>更多的细节我就不展示了，直接上教程</li></ul><p>1.先登陆</p><p>2.配置网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">配置网络</span><br>nmcli device wifi connect wifi名 password 密码<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试网络</span><br>ping baidu.com<br></code></pre></td></tr></table></figure><p>3.下载基本环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载git</span><br>sudo pacman -S git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载yay包</span><br>git clone https://aur.archlinux.org/yay-git.git<br>cd yay-git<br>makepkg -si<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果下载失败并且go下载成功，则需要设置go的国内代理</span><br>go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br>echo &quot;export GO111MODULE=on&quot; &gt;&gt; ~/.profile<br>echo &quot;export GOPROXY=https://goproxy.cn&quot; &gt;&gt; ~/.profile<br>source ~/.profile<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新输入</span> <br>makepkg -si<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">回到主目录</span><br>cd ~<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建下载dotfiles目录</span><br>mkdir Downloads<br>cd Downloads<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">clone</span>下dotfiles</span><br>git clone https://gitlab.com/stephan-raabe/dotfiles.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开始下载脚本</span><br>cd dotfiles<br>./install.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">然后开始配置下载，等待下载完成即可</span><br><br></code></pre></td></tr></table></figure><h2 id="软件工具配置"><a href="#软件工具配置" class="headerlink" title="软件工具配置"></a>软件工具配置</h2><h3 id="安装声卡驱动-必需"><a href="#安装声卡驱动-必需" class="headerlink" title="安装声卡驱动(必需)"></a>安装声卡驱动(必需)</h3><ul><li>如果你没有声卡驱动，系统将会没有声音</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S pulseaudio alsa-utils<br></code></pre></td></tr></table></figure><ul><li>重启生效</li></ul><h3 id="设置快速开关机-建议-："><a href="#设置快速开关机-建议-：" class="headerlink" title="设置快速开关机(建议)："></a>设置快速开关机(建议)：</h3><ul><li>如果不设置，开关机很慢，有时候可能得等个几分钟</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑系统文件</span><br>sudo nvim /etc/systemd/system.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">找到DefaultTimeoutStartSec和DefaultTimeoutStopSec</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将前面<span class="hljs-string">&#x27;#&#x27;</span>去掉，然后在等于号后写上你想要的时间</span><br>DefaultTimeoutStartSec=5s<br>DefaultTimeoutStopSec=5s<br><span class="hljs-meta prompt_">#</span><span class="language-bash">这边我设置5s</span><br></code></pre></td></tr></table></figure><h3 id="配置汉化和中文输入法-建议"><a href="#配置汉化和中文输入法-建议" class="headerlink" title="配置汉化和中文输入法(建议)"></a>配置汉化和中文输入法(建议)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载中文字体</span><br>sudo pacman -S adobe-source-han-serif-cn-fonts<br>sudo pacman -S noto-fonts-cjk<br>sudo pacman -S noto-fonts-emoji<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置系统语言</span><br>nvim /etc/locale.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将LANG的那一行内容替换为</span><br>LANG=zh_CN.UTF-8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载中文输入法框架</span><br>sudo pacman -S fcitx5-im<br>sudo pacman -S fcitx5-chinese-addons fcitx5-rime<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置环境文件</span><br>nvim /etc/environment<br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加以下内容</span><br>GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>SDL_IM_MODULE=fcitx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开机自启动</span><br>sudo nvim ~/.config/hypr/hyprland.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在末尾添加</span><br>exec-once = fcitx5  # 输入法<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入法环境变量</span><br>env = XIM,fcitx<br>env = XIM_PROGRAM,fcitx<br>env = INPUT_METHOD,fcitx<br>env = GTK_IM_MODULE,fcitx<br>env = QT_IM_MODULE,fcitx<br>env = XMODIFIERS,@im=fcitx<br></code></pre></td></tr></table></figure><ul><li>重启生效</li></ul><h3 id="配置tlp电源管理器-建议"><a href="#配置tlp电源管理器-建议" class="headerlink" title="配置tlp电源管理器(建议)"></a>配置tlp电源管理器(建议)</h3><ul><li>如果没有电源管理器，arch会默认最高功率运行，耗电巨快</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S tlp tlp-rdw<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开机自启动</span><br>sudo systemctl start tlp<br>sudo systemctl enable tlp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看运行情况</span><br>tlp-stat -s<br><br></code></pre></td></tr></table></figure><h3 id="安装cpupowper-建议"><a href="#安装cpupowper-建议" class="headerlink" title="安装cpupowper(建议)"></a>安装cpupowper(建议)</h3><ul><li>archlinux默认cpu可能会睿频，我们需要调节</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S cpupower<br><br>sudo cpupower frequency-set -g powersave<br>sudo systemctl start cpupower<br>sudo systemctl enable cpupower<br></code></pre></td></tr></table></figure><h3 id="配置开机自动清理垃圾-建议"><a href="#配置开机自动清理垃圾-建议" class="headerlink" title="配置开机自动清理垃圾(建议)"></a>配置开机自动清理垃圾(建议)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>sudo nvim clean_arch.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">复制以下内容</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br> <br>echo &quot;正在清理旧的包文件...&quot;<br>pacman -Rns $(pacman -Qtdq)<br> <br>echo &quot;正在清理缓存文件...&quot;<br>rm -rf /var/cache/pacman/pkg/<br> <br>echo &quot;正在清理旧的包文件列表...&quot;<br>rm -f /var/lib/pacman/sync/tarbackups/*<br> <br>echo &quot;正在清理log文件...&quot;<br>rm -f /var/log/pacman.log<br> <br>echo &quot;清理完成&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">esc,输入:wq保存，一定要包含<span class="hljs-comment">#!/bin/bash</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">赋予权限</span><br>chmod +x ~/clean_arch.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果需要清理垃圾</span><br>cd ~<br>sudo bash clean_arch.sh<br></code></pre></td></tr></table></figure><h3 id="配置合盖休眠-建议"><a href="#配置合盖休眠-建议" class="headerlink" title="配置合盖休眠(建议):"></a>配置合盖休眠(建议):</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看swap分区位置</span><br>swapon --show<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看swap分区的uuid(我这里是/dev/nvme0n1p6)</span><br>sudo blkid /dev/nvme0n1p6<br><br>sudo nvim /etc/default/grub<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查找GRUB_CMDLINE_LINUX_DEFAULT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在GRUB_CMDLINE_LINUX_DEFAULT的双引号里面的内容的后面添加</span><br>resume=UUID=刚刚查找到的uuid<br><span class="hljs-meta prompt_">#</span><span class="language-bash">esc,输入:wq保存</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">更新grub</span><br>sudo grub-mkconfig -o /boot/grub/grub.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加resume钩子</span><br>sudo nvim /etc/mkinitcpio.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在hooks行添加resume</span><br>我的情况：<br>原本是: HOOKS=(base udev autodetect modconf block filesystems keyboard fsck)<br>添加后: HOOKS=(base udev resume autodetect modconf block filesystems keyboard fsck)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新生产mkinitcpio</span><br>sudo mkinitcpio -p linux<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑合盖休眠</span><br>sudo nvim /etc/systemd/logind.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">找到HandlePowerKey</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将前面注释去掉</span><br>HandlePowerKey=hibernate<br><span class="hljs-meta prompt_">#</span><span class="language-bash">esc,输入:wq保存</span><br></code></pre></td></tr></table></figure><ul><li>重启生效</li></ul><h3 id="配置timeshift快照-建议"><a href="#配置timeshift快照-建议" class="headerlink" title="配置timeshift快照(建议)"></a>配置timeshift快照(建议)</h3><ul><li>arch是一个很容易滚挂的系统，如果不想数据丢失，备份和快照就很需要</li><li>timeshift可以用gui或者命令进行创建和管理快照，也可以选定时间点进行还原</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S timeshift<br></code></pre></td></tr></table></figure><ul><li><p>操作：</p><ul><li>进入到timeshift的ui界面，如果打开运行发现没有反应，可以试试在终端输入以下命令打开</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -E timeshift-gtk<br></code></pre></td></tr></table></figure><ul><li>点击向导，选择rsync类型备份，点击下一步</li><li>选择要备份的分区位置，注意一定得是linux文件系统类型的分区才行，点击下一步</li><li>按需选择是否定时备份</li><li>这样即可创建备份，需要还原就选择时间点恢复</li><li>如果进入不了系统的，或者进入不了桌面的，也可以用命令恢复，可以百度一下，别盲目重装！</li></ul></li></ul><h3 id="配置动态壁纸"><a href="#配置动态壁纸" class="headerlink" title="配置动态壁纸"></a>配置动态壁纸</h3><ul><li>因为使用的是swww或者hyprpaper引擎(可选)，但是这些都是只能设置静态壁纸，现在就来配置动态壁纸</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装配置动态壁纸插件mpvpaper</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">注需要提前安装好cmake环境</span><br>git clone --single-branch https://github.com/GhostNaN/mpvpaper<br>cd mpvpaper<br>meson setup build --prefix=/usr/local<br>ninja -C build<br>ninja -C build install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">先截取一帧你的动态壁纸作为静态壁纸，用于更改终端配色和Apps栏的背景</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">crtl+super+s打开system设置wallpaper engine的引擎选择disabled,然后退出登陆重进生效</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">你会发现桌面是黑色的</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">开始设置动态壁纸</span><br>sudo nvim ~/.config/hypr/hyprland.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在末尾添加</span><br>exec-once = mpvpaper &#x27;*&#x27; 你的mp4地址 -o --loop -f --no-audio<br><span class="hljs-meta prompt_">#</span><span class="language-bash">esc,输入:wq保存</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">退出登陆生效</span><br></code></pre></td></tr></table></figure><ul><li><strong>注</strong>：开启动态壁纸的实质就是在后台重复播放视频，这样会导致耗电速度加快，可以看个人需求自己调节(也就是充电时可以开启，不充电用静态)</li></ul><h3 id="配置登陆界面"><a href="#配置登陆界面" class="headerlink" title="配置登陆界面"></a>配置登陆界面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">先将自己喜欢的壁纸复制在/usr/share/sddm/themes/sugar-candy/Backgrounds/</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这是我自己壁纸的地方</span><br>sudo cp ~/wallpaper/t7ie6nxd.png /usr/share/sddm/themes/sugar-candy/Backgrounds/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改主题</span><br>sudo nvim /usr/share/sddm/themes/sugar-candy/theme.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将Backgrounds中的图片名改成你刚刚复制的图片名和后缀</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">里面还有其他设置，你可以自己修改</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改好后esc,输入:wq保存</span><br></code></pre></td></tr></table></figure><ul><li>退出登陆生效</li></ul><h3 id="配置clion"><a href="#配置clion" class="headerlink" title="配置clion"></a>配置clion</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">先配置clion所需的运行环境和语言环境</span><br><br>yay -S jdk-openjdk  #clion是用java写的，所以需要java环境<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置cmake</span><br>yay -S cmake<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置gdb</span><br>yay -S gdb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装clion</span><br>yay -S clion<br></code></pre></td></tr></table></figure><ul><li>注：因为aur的下载的cmake和gdb都是最新的，而clion并不兼容这么新的，所以你得手动编辑配置，<strong>手动选择cmake和gdb位置，一般都在&#x2F;usr&#x2F;bin中</strong></li><li>插件配置：<br><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191524056.png" alt="image"><ul><li>C&#x2F;C++ Single File Execution 一个可以让clion单独运行一个cpp文件的插件</li><li>chinese插件进行汉化</li><li>IdeaVim 看个人习惯，这个是可以像vim一样操作的插件</li></ul></li></ul><h3 id="配置mysql和dbeaver"><a href="#配置mysql和dbeaver" class="headerlink" title="配置mysql和dbeaver"></a>配置mysql和dbeaver</h3><ul><li>mysql</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">以root身份进入mysql</span><br>sudo mysql -u root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加用户</span><br>create user your_user_name identified by &quot;your_password&quot;;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">赋予权限</span><br>GRANT ALL PRIVILEGES ON *.* TO &#x27;your_user_name&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">保存权限</span><br>FLUSH PRIVILEGES;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">退出</span><br>exit<br></code></pre></td></tr></table></figure><ul><li>dbeaver是一个mysql的可视化操作软件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S dbeaver<br></code></pre></td></tr></table></figure><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">安装redis</span><br>sudo pacman -S redis<br><span class="hljs-meta prompt_">#</span><span class="language-bash">开机自启动</span><br>sudo systemctl start redis<br>sudo systemctl enable redis<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入redis服务</span><br>redis-server<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入redis客户端服务</span><br>redis-cli<br></code></pre></td></tr></table></figure><h3 id="安装edge"><a href="#安装edge" class="headerlink" title="安装edge"></a>安装edge</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S microsoft-edge-stable-bin<br></code></pre></td></tr></table></figure><h3 id="安装微信"><a href="#安装微信" class="headerlink" title="安装微信"></a>安装微信</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wechat-uos<br></code></pre></td></tr></table></figure><h3 id="安装wps-office"><a href="#安装wps-office" class="headerlink" title="安装wps-office"></a>安装wps-office</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wps-office<br></code></pre></td></tr></table></figure><h3 id="安装typora"><a href="#安装typora" class="headerlink" title="安装typora"></a>安装typora</h3><ul><li><p>根据个人所需下载</p><ul><li><a href="https://wwi.lanzoup.com/iD8V90qzblhg">下载地址1(外部)</a></li><li><a href="/home/moon/Downloads/media_files/typora_1.5.10-1_amd64.deb">下载地址2(本网站提供)</a></li></ul></li><li><p>这是我设定的typora主题(puple-classic.css)，有需要的下载下面两个文件后，打开typora的偏好设置，打开外观，进入到主题文件夹，然后将这个两个文件拖进去，重启，按主题选择文件名相等的主题即可<br><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191524057.png" alt="image"></p></li><li><p><a href="https://pan.baidu.com/s/1V9GpbLkVgKS9fTkx-YPKEg?pwd=97b8">purple.css|purple-classic.css</a></p></li><li><p>提取码：97b8</p></li></ul><h3 id="配置neovim"><a href="#配置neovim" class="headerlink" title="配置neovim"></a>配置neovim</h3><ul><li>得先安装neovim</li><li>然后下载我给的配置文件</li><li><a href="/home/moon/Downloads/media_files/nvim_c.rar">下载配置文件</a></li><li>下载好后，解压将nvim文件夹里的内容替换掉~&#x2F;.config&#x2F;nvim中的内容(也就是nvim配置文件的地方)</li><li>替换好后，重新打开nvim就成功了，keymap.lua文件记录着快捷键</li><li>效果图<br><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191524058.png" alt="image"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Arch Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch Linux</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理</title>
    <link href="/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>什么是操作系统？</p></blockquote><p>操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p><blockquote><p>操作系统在系统中的位置</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537279.png" alt="image"></p><blockquote><p>操作系统的功能和目标</p></blockquote><ol><li>系统资源的管理者</li></ol><ul><li>文件管理</li><li>内存管理</li><li>处理机（CPU）管理</li><li>设备（计算机硬件，例如摄像头）管理</li></ul><ol start="2"><li>用户和计算机硬件之间的接口</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537280.png" alt="image"></p><ol start="3"><li>对硬件机器的拓展</li></ol><blockquote><p>操作系统的四个特征</p></blockquote><ol><li>并发</li></ol><p>并发是指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，在微观上是交替发生的。</p><p>易混淆的概念——并行：两个或多个事件在同一时刻同时发生</p><ol start="2"><li>共享</li></ol><p>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537281.png" alt="image"></p><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)</p><p>生活实例:</p><ul><li>互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li><li>同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li></ul><ol start="3"><li>虚拟</li></ol><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537282.png" alt="image"></p><ol start="4"><li>异步</li></ol><p>异步是指，在多道程序环境下，允许多个程序并发执行，但<strong>由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</strong></p><ul><li>只有系统拥有并发性，才有可能导致异步性。</li></ul><h3 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h3><ul><li>指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537283.png" alt="image"></p><ul><li>CPU</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537284.png" alt="image"></p><ul><li>程序</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537285.png" alt="image"></p><ul><li>操作系统的内核</li></ul><p>由于内核划分功能的不同，内核分为大内核和微内核。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537286.png" alt="image"></p><ul><li>大内核和微内核的优缺点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537287.png" alt="image"></p><p>类比:</p><ul><li><p>操作系统的体系结构问题与企业的管理问题很相似。</p></li><li><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</p></li><li><p>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</p></li><li><p>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</p></li></ul><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><h4 id="概念和作用"><a href="#概念和作用" class="headerlink" title="概念和作用"></a>概念和作用</h4><p><strong>中断</strong>是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li><li>对于不同的中断信号，会进行不同的处理。</li><li>有了中断，才能实现多道程序并发执行。</li><li>“用户态→核心态”是通过中断实现的，<strong>并且中断是唯一途径</strong>。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>中断信号的来源来自CPU内部称为内中断，外部称为外中断。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537288.png" alt="image"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537289.png" alt="image"></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><strong>应用程序通过系统调用请求操作系统的服务</strong>。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;o操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。<strong>这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</strong></p><h4 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h4><p>编程语言（c,java）中里边有很多库函数，其实它们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>系统调用发生在用户态，对系统调用的处理发生在核心态。</li><li>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进入核心态。</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程的定义，组成，组织方式，特征"><a href="#进程的定义，组成，组织方式，特征" class="headerlink" title="进程的定义，组成，组织方式，特征"></a>进程的定义，组成，组织方式，特征</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>程序： 就是指令序列</p><p>引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。</p><p><strong>PCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）</strong>。一般情况下，我们把进程实体简称为进程。</p><p>例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.</p><p><strong>PCB是进程存在的唯一标识。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537290.png" alt="image"></p><h4 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h4><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p><p>相当于java中的链表和数组。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537291.png" alt="image"></p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537292.png" alt="image"></p><h3 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537293.png" alt="image"></p><p>除此之外，进程还有两种状态。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537294.png" alt="image"></p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537295.png" alt="image"></p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><blockquote><p>含义</p></blockquote><p><strong>进程控制就是要实现进程状态转换。</strong></p><blockquote><p>实现</p></blockquote><p><strong>进程控制由原语实现。</strong>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</p><p>原语采用 “关中断指令” 和 “开中断指令” 来实现。 注意： 原语运行在核心态。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537296.png" alt="image"></p><p>那么原语是如何实现进程状态的转换呢？</p><ol><li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)<br>a.所有的进程控制原语一定都会修改进程状态标志<br>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c.某进程开始运行前必然要恢复期运行环境</li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><p>具体实现如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537297.png" alt="image"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><blockquote><p>含义</p></blockquote><p>进程通信就是进程之间的信息交换。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>操作系统提供了三种方法：共享存储，消息传递，管道通信。</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537298.png" alt="image"></p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p>1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。<br>2.各进程要互斥地访问管道。<br>3.数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。<br>4.<strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong><br>5．数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个，否则可能会有读错数据的情况。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537299.png" alt="image"></p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。</p><p>类似于Http协议。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537300.png" alt="image"></p><h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能<strong>串行</strong>执行一系列程序。因此，引入“线程”，来增加并发度。</p><ul><li><p>可以把线程理解为轻量级的进程。</p></li><li><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p></li><li><p>引入线程后，进程作为除CPU之外的系统资源的分配单元。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537301.png" alt="image"></p><h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><ol><li>用户级线程</li></ol><ul><li>用户级线程由应用程序通过线程库实现。<strong>所有的线程管理工作都由应用程序负责（包括线程切换)</strong></li><li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预。</strong></li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li><li>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li></ul><ol start="2"><li>内核级线程</li></ol><ul><li>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li></ul><p>&#x3D;&#x3D;操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。&#x3D;&#x3D;</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><blockquote><p>多对一模型</p></blockquote><ul><li>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</li><li>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong></li><li>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537302.png" alt="image"></p><blockquote><p>一对一模型</p></blockquote><ul><li>一对一模型:一个用户级线程映射到一个内核级线程。</li><li>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li><li>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537303.png" alt="image"></p><blockquote><p>多对多模型</p></blockquote><ul><li>多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。</li><li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537304.png" alt="image"></p><h3 id="处理机调度的概念和层次"><a href="#处理机调度的概念和层次" class="headerlink" title="处理机调度的概念和层次"></a>处理机调度的概念和层次</h3><blockquote><p>含义</p></blockquote><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。</p><p>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><p>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</li><li><strong>高级调度是辅存（外存）与内存之间的调度</strong>。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。<strong>高级调度主要是指调入的问题</strong>，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537306.png" alt="image"></p><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><ul><li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量</strong>。</li><li>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</li><li><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></li><li>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537307.png" alt="image"></p><h4 id="补充知识：进程的七状态模型"><a href="#补充知识：进程的七状态模型" class="headerlink" title="补充知识：进程的七状态模型"></a>补充知识：进程的七状态模型</h4><ul><li><p>暂时被调到外存等待的进程状态称为挂起状态。</p></li><li><p>挂起状态又可以进一步细分为就绪挂起，堵塞挂起两种状态。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537308.png" alt="image"></p><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><ul><li>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li><li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的频率很高，一般几十毫秒一次。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537309.png" alt="image"></p><h4 id="三种调度的联系和对比"><a href="#三种调度的联系和对比" class="headerlink" title="三种调度的联系和对比"></a>三种调度的联系和对比</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537310.png" alt="image"></p><h3 id="进程调度的时机，切换过程和方式"><a href="#进程调度的时机，切换过程和方式" class="headerlink" title="进程调度的时机，切换过程和方式"></a>进程调度的时机，切换过程和方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537311.png" alt="image"></p><p>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><ul><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li></ul><blockquote><p>优点</p></blockquote><ul><li>实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><ul><li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li></ul><blockquote><p>优点</p></blockquote><ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><p>“狭义的进程调度”与“进程切换”的区别:</p><ul><li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p></li><li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p></li></ul><p><strong>广义的进程调度包含了选择一个进程和进程切换两个步骤。</strong></p><p>进程切换的过程主要完成了:</p><ul><li><p>1.对原来运行进程各种数据的保存</p></li><li><p>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</p></li></ul><p>注意 : <strong>进程切换是有代价的</strong>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><ul><li>CPU利用率： CPU”忙碌”的时间占总时间的比例。</li><li>系统吞吐量：单位时间内完成作业的数量。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537312.png" alt="image"></p><ul><li>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。</li></ul><p>（作业）周转时间&#x3D;作业完成时的时间-作业提交时间</p><p>平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</p><p>由于在周转时间相同的情况下，运行时间不同的作业，给用户的感觉是不一样的，所以提出了带权周转时间的概念。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537313.png" alt="image"></p><ul><li>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li></ul><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。<br>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><ul><li>响应时间：指从用户提交请求到首次产生响应所用的时间。</li></ul><h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法(1)"></a>调度算法(1)</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537314.png" alt="image"></p><h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537315.png" alt="image"></p><h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a>高响应比优先(HRRN)</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537316.png" alt="image"></p><h4 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537317.png" alt="image"></p><p>注:这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。<strong>因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于交互式系统的调度算法将在下个小节介绍…</p><h3 id="调度算法-2"><a href="#调度算法-2" class="headerlink" title="调度算法(2)"></a>调度算法(2)</h3><h4 id="时间片轮转调度-RR"><a href="#时间片轮转调度-RR" class="headerlink" title="时间片轮转调度(RR)"></a>时间片轮转调度(RR)</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537318.png" alt="image"></p><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</li><li>一般来说，设计时间片要让切换进程的开销占比不超过1%。</li></ul><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537319.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537320.png" alt="image"></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537321.png" alt="image"></p><ul><li>通过下边的例子来加深理解</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537322.png" alt="image"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统。</strong>(比如UNIX使用的就是多级反馈队列调度算法)</p><h3 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ul><li>通过进程通信——管道通信的例子来了解什么是进程同步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537323.png" alt="image"></p><p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></p><blockquote><p>含义</p></blockquote><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><ul><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li><li>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li><li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537324.png" alt="image"></p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537325.png" alt="image"></p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p><blockquote><p>代码实现</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537326.png" alt="image"></p><blockquote><p>解释</p></blockquote><p>turn的初值为0，即刚开始只允许0号进程进入临界区。<br>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换 P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在 P0访问临界区期间即时切换回P1，P1依然会卡在⑤。只有P0在退出区将turn改为1后，P1才能进入临界区。<br>因此，<strong>该算法可以实现“同一时刻最多只允许一个进程访问临界区”</strong></p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。</p><p>也就是说，对于临界区的访问，一定是按P0→P1→P0→P1→……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。<br>因此，<strong>单标志法存在的主要问题是:违背“空闲让进”原则。</strong></p><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D;ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537327.png" alt="image"></p><p>若按照①⑤②⑥③⑦….的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong><br>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537328.png" alt="image"></p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537329.png" alt="image"></p><ul><li>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li><li>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li></ul><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537330.png" alt="image"></p><h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537331.png" alt="image"></p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537332.png" alt="image"></p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h4><ul><li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li><li><strong>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，</strong>可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li><li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。</li><li>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li><li>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li></ul><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><p>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p><p>下面以打印机为例：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537333.png" alt="image"></p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537334.png" alt="image"></p><h3 id="用信号量实现进程互斥，同步，前驱关系"><a href="#用信号量实现进程互斥，同步，前驱关系" class="headerlink" title="用信号量实现进程互斥，同步，前驱关系"></a>用信号量实现进程互斥，同步，前驱关系</h3><h4 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537335.png" alt="image"></p><p>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p><p><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p><h4 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h4><p>进程同步：要让各并发进程按要求有序的进行。</p><p>那么如何实现呢？</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li><li>设置同步信号量s,初始为0</li><li>在“前操作”之后执行v(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>下面通过一个例子来解释，要求：进程2的代码4必须在进程1的代码2之后执行。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537336.png" alt="image"></p><h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，<br>1．要为每一对前驱关系各设置一个同步变量</p><p>2．在“前操作”之后对相应的同步变量执行V操作</p><p>3.在“后操作”之前对相应的同步变量执行Р操作</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537337.png" alt="image"></p><h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p><ul><li>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须互斥地访问。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537338.png" alt="image"></p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537339.png" alt="image"></p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537340.png" alt="image"></p><h4 id="能够改变相邻P，V的顺序"><a href="#能够改变相邻P，V的顺序" class="headerlink" title="能够改变相邻P，V的顺序"></a>能够改变相邻P，V的顺序</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537341.png" alt="image"></p><h3 id="多生产者——多消费者"><a href="#多生产者——多消费者" class="headerlink" title="多生产者——多消费者"></a>多生产者——多消费者</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537342.png" alt="image"></p><h4 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537343.png" alt="image"></p><p>问题：可不可以不使用问题信号量？</p><p>结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p><p>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p><p>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</li><li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</li></ol><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537344.png" alt="image"></p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537345.png" alt="image"></p><h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p><p>①允许多个读者可以同时对文件执行读操作;</p><p>②只允许一个写者往文件中写信息;</p><p>③任一写者在完成写操作之前不允许其他读者或写者工作;</p><p>④写者执行写操作前，应让已有的读者和写者全部退出。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537346.png" alt="image"></p><h4 id="如何实现-2"><a href="#如何实现-2" class="headerlink" title="如何实现"></a>如何实现</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537347.png" alt="image"></p><ul><li>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537348.png" alt="image"></p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。<br>其核心思想在于<strong>设置了一个计数器count用来记录当前正在访问共享文件的读进程数</strong>。我们可以用count的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。<br>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，<strong>如果需要实现“一气呵成”，自然应该想到用互斥信号量。</strong><br>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537349.png" alt="image"></p><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p><p>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。<br>3.信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p><h4 id="如何实现-3"><a href="#如何实现-3" class="headerlink" title="如何实现"></a>如何实现</h4><ul><li>如果使用下图所示的方法，则会导致死锁问题。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537350.png" alt="image"></p><ul><li>那么如何解决呢？</li></ul><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p><p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p><p>下面用代码实现第三种方式。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537351.png" alt="image"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><h4 id="为什么引入管程？"><a href="#为什么引入管程？" class="headerlink" title="为什么引入管程？"></a>为什么引入管程？</h4><p>信号量机制存在的问题 : 编写程序困难、易出错。 因此人们想设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。1973年，Brinch Hansen首次在程序设计语言(Pascal)中引入了“管程”成分――一种高级同步机制。</p><h4 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h4><p><strong>管程相当于对临界区资源进行抽象而编写的一个类。</strong></p><p>管程是一种特殊的软件模块，有这些部分组成:</p><ol><li><p>局部于管程的共享数据结构说明;     （一个类）</p></li><li><p>对该数据结构进行操作的一组过程;    （类中的方法）</p></li><li><p>对局部于管程的共享数据设置初始值的语句;   （类中的变量）</p></li><li><p>管程有一个名字。 （类名）</p></li></ol><p>管程的基本特征:</p><ol><li><p>局部于管程的数据只能被局部于管程的过程所访问;      （类中变量有自己的作用范围）</p></li><li><p>**一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** <strong>这种互斥特性是由编译器来实现的。</strong></p></li><li><p><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></p></li></ol><h4 id="java中类似于管程的机制（单例模式）"><a href="#java中类似于管程的机制（单例模式）" class="headerlink" title="java中类似于管程的机制（单例模式）"></a>java中类似于管程的机制（单例模式）</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537352.png" alt="image"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>​在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p><p>发生死锁后若无外力干涉,这些进程都将无法向前推进。</p><h4 id="死锁，饥饿，死循环的区别"><a href="#死锁，饥饿，死循环的区别" class="headerlink" title="死锁，饥饿，死循环的区别"></a>死锁，饥饿，死循环的区别</h4><ul><li>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li><li>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537353.png" alt="image"></p><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><p><strong>互斥条件</strong>:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</p></li><li><p><strong>不剥夺条件</strong>:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p></li><li><p><strong>请求 和 保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p></li><li><p><strong>循环等待条件</strong>:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p></li></ul><p>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（<strong>循环等待是死锁的必要不充分条件</strong>)</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol><li><p><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</p></li><li><p><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p></li><li><p><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</p></li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537354.png" alt="image"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537355.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537356.png" alt="image"></p><ul><li>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li><li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，则可能会发生死锁。（不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</strong></li><li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><strong>数据结构:</strong></p><ul><li>长度为m的一维数组 Available表示还有多少可用资源</li><li>n*m矩阵Max表示各进程对资源的最大需求数</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源</li><li>Max - Allocation &#x3D; Need矩阵表示各进程最多还需要多少资源</li><li>用长度为m的一位数组Request表示进程此次申请的各种资源数</li></ul><p><strong>银行家算法步骤:</strong></p><ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ol><p><strong>安全性算法步骤:</strong><br>    检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。<br>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须:</p><p>①用某种数据结构来保存资源的请求和分配信息;<br>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537357.png" alt="image"></p><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程.<br><strong>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列)。</strong><br>如果最终不能消除所有边，那么此时就是发生了死锁。</p><p><strong>死锁定理:如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</strong></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。<br>补充:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程<br>解除死锁的主要方法有 :</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>如何选择对哪些进程动手？</p><ol><li>进程优先级   (优先级低的)</li><li>已执行多长时间 （执行时间短的）</li><li>还要多久能完成   （时间长的进行处理）</li><li>进程己经使用了多少资源    （资源多的）</li><li>进程是交互式的还是批处理式的   （进行批处理的）</li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537358.png" alt="image"></p><blockquote><p>相对地址和绝对地址</p></blockquote><p><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong><br>Eg: 编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p><strong>相对地址又称逻辑地址，绝对地址又称物理地址。</strong></p><blockquote><p>写程序到程序运行</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537359.png" alt="image"></p><h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><p>操作系统对内存进行管理，那么要管理哪些内容呢？</p><ol><li>内存空间的分配和回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537360.png" alt="image"></p><ol start="4"><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ol><p>内存保护可采取两种方法:</p><p>方法一:在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537361.png" alt="image"></p><p>方法二:采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537362.png" alt="image"></p><h3 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537363.png" alt="image"></p><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>覆盖技术的思想 : <strong>将程序分为多个段（多个模块）</strong>。常用的段常驻内存，不常用的段在需要时调入内存。<br>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束)不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537364.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537364.png" alt="image"></p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。<strong>缺点:对用户不透明，增加了用户编程负担。</strong>覆盖技术只用于早期的操作系统中，现在已成为历史。</p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换（对换）技术的设计思想: <strong>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</strong>。之前讲的中级调度（内存调度）就是为这个服务的。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537365.png" alt="image"></p><p>1.应该在外存（磁盘）的什么位置保存被换出的进程?</p><blockquote><p>具有对换功能的操作系统中，通常把<strong>磁盘空间分为文件区和对换区</strong>两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配方式</strong>;对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配</strong>方式（学过文件管理章节后即可理解）。总之，对换区的I&#x2F;O速度比文件区的更快。</p></blockquote><p>2.什么时候应该交换?</p><blockquote><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p></blockquote><p>3.应该换出哪些进程?</p><blockquote><p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p><p><strong>(注意:PCB会常驻内存，不会被换出外存)</strong></p></blockquote><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><p><code>连续分配</code>：指为用户进程分配的必须是一个连续的内存空间。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537366.png" alt="image"></p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul><li>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</li><li>内存中只能有一道用户程序，用户程序独占整个用户区空间。</li><li>优点: 实现简单 ;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护（eg:早期的 PC操作系统MS-DOS)。</li><li>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537367.png" alt="image"></p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537368.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537369.png" alt="image"></p><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区分配又称为可变分区分配。<strong>这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的大小和数目是可变的。</p><ul><li>使用这种方式的话，我们需要考虑以下三个问题。</li></ul><ol><li>系统要用什么样的数据结构记录内存的使用情况?</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537370.png" alt="image"></p><ol start="2"><li><p>当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</p><pre><code class="hljs">使用动态分区算法，这个将在下一小节进行详细介绍。</code></pre></li><li><p>如何进行分区的分配与回收操作?</p></li></ol><ul><li>如何分配  ———–&gt; 使用动态分区算法之后，修改数据结构即可。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537371.png" alt="image"></p><ul><li>如何回收——————————-&gt; 牢记一点即可，会把相邻的空闲区域合并为一个。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537372.png" alt="image"></p><h4 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h4><ul><li>动态分区分配没有内部碎片，但是有外部碎片。</li><li><strong>内部碎片</strong>，分配给某进程的内存区域中，如果有些部分没有用上。</li><li><strong>外部碎片</strong>，是指内存中的某些空闲分区由于太小而难以利用。</li><li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些<br>进程“碎片”不能满足进程的需求。可以通过<strong>紧凑</strong>（(拼凑，Compaction)技术来解决外部碎片。</li></ul><h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><p>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想: 每次都从低地址开始查找，<strong>找到第一个能满足大小的空闲分区</strong>。<br>如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537373.png" alt="image"></p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。<br>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537374.png" alt="image"></p><h4 id="最大适应算法"><a href="#最大适应算法" class="headerlink" title="最大适应算法"></a>最大适应算法</h4><p>又称最坏适应算法(Largest Fit)<br>算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在<strong>每次分配时优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。<br>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537375.png" alt="image"></p><h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><p>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。<strong>如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</strong><br>如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537376.png" alt="image"></p><h4 id="四种算法对比"><a href="#四种算法对比" class="headerlink" title="四种算法对比"></a>四种算法对比</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537377.png" alt="image"></p><h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><p>连续分配:为用户进程分配的必须是一个连续的内存空间。</p><p>非连续分配:为用户进程分配的可以是一些分散的内存空间。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537378.png" alt="image"></p><p><strong>基本分页存储管理的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分。</strong></p><p>将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。<br>(注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片)</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p><strong>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</strong></p><p>思考： 将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换?</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在页面内的“偏移量”</li><li>物理地址 &#x3D; 页面始址＋页内偏移量</li></ol><p>如何计算:</p><ol><li>页号&#x3D;逻辑地址&#x2F;页面长度(取除法的整数部分)</li><li>页内偏移量 &#x3D; 逻辑地址%页面长度（取除法的余数部分)</li><li>页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。</li></ol><p>举例:</p><p>   页号&#x3D;80 &#x2F; 50&#x3D; 1<br>   页内偏移量&#x3D;80 % 50 &#x3D; 30<br>   1号页在内存中存放的起始位置450</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537379.png" alt="image"></p><p>思考: 如何知道该页号对应页面在内存中的起始地址?</p><p>操作系统为每一个进程创建一个页表?</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537380.png" alt="image"></p><ul><li>如何理解每个页表项的长度是相同的，页号是“隐含的”？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537382.png" alt="image"></p><h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><p>基本地址变换机构可以<strong>借助进程的页表将逻辑地址转换为物理地址</strong>。<br>通常会在系统中设置一个页表寄存器(PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><ul><li>执行流程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537383.png" alt="image"></p><ul><li>页表项长度，页表长度，页面大小</li></ul><p>页表长度是指这个页表中总共有几个页表项，即总共有多少页。页面大小是指一个页面占多大的存储空间。页表项长度是指每个页表项占多大的存储空间。</p><p>通过下面这个例子来理解页表项长度。</p><p>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，内存总共会被分为2^32&#x2F; 2^12&#x3D;2^20个内存块，因此内存块号的范围应该是0~2^20 - 1。因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)。每个块号用三个字节来表示。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537384.png" alt="image"></p><h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<br><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</p><p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>快表，又称联想寄存器（TLB），是一种<strong>访问速度比内存快很多的高速缓冲存储器</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><ul><li>执行流程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537385.png" alt="image"></p><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>两级页表的出现主要是为了解决单级页表的问题。那么单级页表有什么问题呢？</p><p>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<br>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><h4 id="1-解决问题一"><a href="#1-解决问题一" class="headerlink" title="1.解决问题一"></a>1.解决问题一</h4><p>我们可以回想以下当初是如何解决进程必须连续的问题 ？ </p><p>我们可以把页表放在不同的页框中，再用一个表来记录各个各个子页表所在位置，我们把这个表叫做页目录表（外层页表，顶级页表）。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537386.png" alt="image"></p><h4 id="2-解决问题二"><a href="#2-解决问题二" class="headerlink" title="2.解决问题二"></a>2.解决问题二</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537387.png" alt="image"></p><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><ol><li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面</p></li><li><p>两级页表的访存次数分析（假设没有快表机构）</p></li></ol><ul><li>第一次访存:访问内存中的页目录表</li><li>第二次访存:访问内存中的二级页表</li><li>第三次访存:访问目标内存单元</li></ul><p>&#x3D;&#x3D;N级页表访问一个逻辑地址需要N+1次访问内存。&#x3D;&#x3D;</p><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>​进程的地址空间:<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址。<br>内存分配规则 : 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537388.png" alt="image"></p><ul><li>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537389.png" alt="image"></p><p><strong>段号的位数决定了每个进程最多可以分几个段。</strong></p><p><strong>段内地址位数决定了每个段的最大长度是多少。</strong></p><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537390.png" alt="image"></p><h4 id="段内寻址"><a href="#段内寻址" class="headerlink" title="段内寻址"></a>段内寻址</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537391.png" alt="image"></p><h4 id="分段，分页对比"><a href="#分段，分页对比" class="headerlink" title="分段，分页对比"></a>分段，分页对比</h4><ul><li>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li><li>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li><li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</li><li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li><li><strong>分段比分页更容易实现信息的共享和保护。</strong></li></ul><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><h4 id="分页，分段的优缺点"><a href="#分页，分段的优缺点" class="headerlink" title="分页，分段的优缺点"></a>分页，分段的优缺点</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537392.png" alt="image"></p><p>既然两者都有优缺点，那么可不可以把他们结合起来呢？答案当然是可以的。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537393.png" alt="image"></p><h4 id="段页式管理的逻辑结构"><a href="#段页式管理的逻辑结构" class="headerlink" title="段页式管理的逻辑结构"></a>段页式管理的逻辑结构</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537394.png" alt="image"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小、内存块大小是多少</p><h4 id="段内寻址-1"><a href="#段内寻址-1" class="headerlink" title="段内寻址"></a>段内寻址</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537395.png" alt="image"></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="传统存储管理方式的特征和缺点"><a href="#传统存储管理方式的特征和缺点" class="headerlink" title="传统存储管理方式的特征和缺点"></a>传统存储管理方式的特征和缺点</h4><ul><li>一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:①作业很大时，不能全部装入内存，导致大作业无法运行;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li><li>驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537396.png" alt="image"></p><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><ul><li>基于局部性原理（忘记的话，可以到第8节查看），在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</li><li>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul><p>易混知识点:</p><p><strong>虚拟内存的最大容量是由计算机的地址结构（ CPU寻址范围）确定的</strong></p><p><strong>虚拟内存的实际容量&#x3D; min(内存和外存容量之和，CPU寻址范围)</strong></p><p>如:  某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.</p><p>则虚拟内存的最大容量为2^32B&#x3D; 4GB  。 虚拟内存的实际容量&#x3D;min (2^32B,512MB+2GB)&#x3D; 2GB+512MB</p><p>虚拟内存有一下三个主要特征:</p><ul><li>多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><p><strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537397.png" alt="image"></p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，</p><ol><li>操作系统需要知道每个页面是否已经调入内存;</li><li>如果还没调入，那么也需要知道该页面在外存中存放的位置。</li><li>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;</li><li>有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</li></ol><p>因此页表会增加四个字段来上面的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537398.png" alt="image"></p><h4 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a>缺页中断机制</h4><p>假设此时要访问逻辑地址 &#x3D; (页号，页内偏移量）&#x3D; (0，1024)</p><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p><p>一条指令在执行期间，可能产生多次缺页中断。(如: copy AtoB，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537399.png" alt="image"></p><h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537400.png" alt="image"></p><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><p>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p><p>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p><p>③需要用某种“页面置换算法”来决定一个换出页面（下节内容)</p><p>④换入&#x2F;换出页面都需要启动慢速的I&#x2F;o操作，可见，如果换入&#x2F;换出太频繁，会有很大的开销。</p><p>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h4><p><code>最佳置换算法(OPT)</code>:<strong>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537401.png" alt="image"></p><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h4><p><code>先进先出置换算法(FIFO)</code>:<strong>每次选择淘汰的页面是最早进入内存的页面</strong></p><p>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady异常―一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p><strong>只有FIFO算法会产生Belady异常</strong>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537402.png" alt="image"></p><h4 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h4><p><code>最近最久未使用置换算法(LRU)</code>:<strong>每次淘汰的页面是最近最久未使用的页面</strong>。</p><p>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537403.png" alt="image"></p><h4 id="时钟置换算法-NRU"><a href="#时钟置换算法-NRU" class="headerlink" title="时钟置换算法(NRU)"></a>时钟置换算法(NRU)</h4><p>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或<code>最近未用算法(NRU，NotRecently Used)</code></p><p>简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，<strong>因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537404.png" alt="image"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;o操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;o操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。<br>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1)表示一个页面近期被访问过，且被修改过。</p><p>算法规则: 将所有可能被置换的页面排成一个循环队列<br>第一轮:从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0，0）的帧用于替换。本轮扫描不修改任何标志位<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此<strong>改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537405.png" alt="image"></p><h4 id="五种算法对比"><a href="#五种算法对比" class="headerlink" title="五种算法对比"></a>五种算法对比</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537406.png" alt="image"></p><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="页面分配，置换策略"><a href="#页面分配，置换策略" class="headerlink" title="页面分配，置换策略"></a>页面分配，置换策略</h4><ul><li><p><strong>驻留集:指请求分页存储管理中给进程分配的物理块的集合。</strong></p></li><li><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><blockquote><ol><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际上用于进程推进的时间很少。</li><li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</li></ol></blockquote></li><li><p>固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间大小不变。即，<strong>驻留集大小不变。</strong></p></li><li><p>可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，<strong>驻留集大小可变</strong></p></li><li><p><code>局部置换</code>:<strong>发生缺页时只能选进程自己的物理块进行置换</strong>。</p></li><li><p><code>全局置换</code>:可以<strong>将操作系统保留的空闲物理块分配给缺页进程</strong>，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537407.png" alt="image"></p><p>下面来分别介绍这几种方式。</p><ul><li><p><code>固定分配局部置换</code>:<strong>系统为每个进程分配一定数量的物理块</strong>，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</p></li><li><p><code>可变分配全局置换:</code><strong>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列</strong>。当某进程<strong>发生缺页时</strong>，从<strong>空闲物理块中取出一块分配给该进程</strong>;若已<strong>无空闲物理块</strong>，则<strong>可选择一个未锁定的页面换出外存</strong>，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是进程中任意一个进程的页，因此被选中的这个进程物理块会减少，缺页率会增加。</p></li><li><p><code>可变分配局部置换</code>： 刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，<strong>只允许从该进程自己的物理块中选出一个换出外存</strong>。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当，反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p></li><li><p><code>可变分配全局置换</code>:<strong>只要缺页就给分配新物理块</strong></p></li><li><p><code>可变分配局部置换:</code>要<strong>根据发生缺页的频率来动态地增加或减少进程的物理块</strong></p></li></ul><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ol><li><p><code>预调页策略</code>:根据局部性原理（主要是空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。<strong>它是运行前调入</strong>。</p></li><li><p><code>请求调页策略</code>:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘l&#x2F;o操作，因此I&#x2F;o开销较大。<strong>它是运行时调入</strong>。</p></li></ol><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><ol><li>系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537408.png" alt="image"></p><ol start="2"><li>系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537409.png" alt="image"></p><ol start="3"><li>UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537410.png" alt="image"></p><h4 id="抖动现象，工作集"><a href="#抖动现象，工作集" class="headerlink" title="抖动现象，工作集"></a>抖动现象，工作集</h4><ul><li><code>抖动</code>:刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。</li><li><strong>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数</strong>（分配给进程的物理块不够)。</li><li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li><li>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</li><li>驻留集:指请求分页存储管理中给进程分配的内存块的集合。</li><li><code>工作集</code>:<strong>指在某段时间间隔里，进程实际访问页面的集合。</strong></li></ul><p>一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537411.png" alt="image"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li><p>文件――就是一组有意义的信息&#x2F;数据集合。</p></li><li><p>一个文件有哪些属性？</p><ol><li>文件名:由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</li><li>标识符:一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li>类型:指明文件的类型</li><li>位置:文件存放的路径（让用户使用)、在外存中的地址(操作系统使用，对用户不可见)</li><li>大小:指明文件大小创建时间、上次修改时间文件所有者信息</li><li>保护信息:对文件进行保护的访问控制信息</li></ol></li><li><p>文件分为有结构文件和无结构文件。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537412.png" alt="image"></p><ul><li>操作系统向上（用户和应用程序）提供的功能</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537413.png" alt="image"></p><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537414.png" alt="image"></p><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><p>无结构文件:文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如:Windows操作系统中的.txt文件。</p><p>有结构文件:由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID)</p><p>我们主要研究有结构文件。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537415.png" alt="image"></p><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>顺序文件:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储（相当于数组）或链式存储（相当于链表）。</p><p>顺序存储又可以分为串结构和顺序结构。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537416.png" alt="image"></p><p>那么这几种存储方式可以快速找到第i个记录对应的地址呢？</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537417.png" alt="image"></p><p>结论:定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录)</p><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>思考：对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录,但是很多应用场景中又必须使用可变长记录。如何解决这个问题?</p><p>这时我们可以建立一张索引表来快速找到第i个记录。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537418.png" alt="image"></p><p><strong>索引表本身是定长记录的顺序文件。</strong>因此可以快速找到第i个记录对应的索引项。</p><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p><p>另外，可以用不同的数据项建立多个索引表。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。(Eg: SQL就支持根据某个数据项建立索引的功能)</p><h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>思考索引文件的缺点:每个记录对应一个索引表项，因此索引表可能会很大。比如:文件的每个记录平均只占8字节，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p><p>那么如何解决呢？</p><p>我们可以建立一个索引顺序文件。</p><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:<strong>并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</strong></p><p>在本例中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537419.png" alt="image"></p><h4 id="多级索引顺序文件"><a href="#多级索引顺序文件" class="headerlink" title="多级索引顺序文件"></a>多级索引顺序文件</h4><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><p>例如，对于一个含10^6个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项(即10000个定长记录)，再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537420.png" alt="image"></p><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537421.png" alt="image"></p><ul><li>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537422.png" alt="image"></p><h4 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h4><ul><li>目录文件中的一条记录就是一个“文件控制块（FCB)</li></ul><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。</p><p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等)，使用信息（如文件的建立时间、修改时间等）。</p><p>最重要，最基本的还是文件名、文件存放的物理地址。</p><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537423.png" alt="image"></p><h4 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537424.png" alt="image"></p><h4 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537425.png" alt="image"></p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><h4 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537426.png" alt="image"></p><p>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容）。</p><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。</p><p>只有共享计数器减为0时，才删除结点。</p><p>注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p><h4 id="索引结点（对FCB的改进）"><a href="#索引结点（对FCB的改进）" class="headerlink" title="索引结点（对FCB的改进）"></a>索引结点（对FCB的改进）</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537427.png" alt="image"></p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="文件分配方式（文件物理结构）"><a href="#文件分配方式（文件物理结构）" class="headerlink" title="文件分配方式（文件物理结构）"></a>文件分配方式（文件物理结构）</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537428.png" alt="image"></p><p>在介绍这些分配方式之前，先介绍一下什么是文件块，磁盘块。</p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面。</p><p>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p><strong>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537429.png" alt="image"></p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块。</strong>如图所示</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB) </p><p><strong>物理块号&#x3D;起始块号＋逻辑块号</strong></p><p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号≥长度就不合法)、</p><p>优点:支持顺序访问和直接访问（即随机访问)；连续分配的文件在顺序访问时速度最快</p><p>缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537430.png" alt="image"></p><h4 id="链接分配——隐式链接"><a href="#链接分配——隐式链接" class="headerlink" title="链接分配——隐式链接"></a>链接分配——隐式链接</h4><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘l&#x2F;O。</p><p>结论:采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537431.png" alt="image"></p><h4 id="链接分配——显式链接"><a href="#链接分配——显式链接" class="headerlink" title="链接分配——显式链接"></a>链接分配——显式链接</h4><p>把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)。如图所示</p><p>注意:一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。</p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项( FCB) </p><p>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。</p><p>结论:采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的 0~i-1号逻辑块)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537432.png" alt="image"></p><h4 id="两种链接分配方式总结"><a href="#两种链接分配方式总结" class="headerlink" title="两种链接分配方式总结"></a>两种链接分配方式总结</h4><p>隐式链接――除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul><p>显式链接――把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT，FileAllocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><ul><li>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点:文件分配表的需要占用一定的存储空间。</li></ul><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配允许文件离散地分配在各个磁盘块中，<strong>系统会为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系)。<strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</strong></p><ul><li>从逻辑块号到物理块号的转变</li></ul><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB)</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)</p><p>但是索引表需要占用一定的存储空间</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537433.png" alt="image"></p><ul><li>如果一个文件的索引表太大，一个磁盘块放不下，那么如何解决呢？</li></ul><p>可以用以下三种方式解决。</p><p>①链接方案:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537434.png" alt="image"></p><p>②多层索引:建立多层索引（原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537435.png" alt="image"></p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537436.png" alt="image"></p><blockquote><p>总结</p></blockquote><p>①链接方案 : 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点:若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘I&#x2F;O次数过多，查找效率低下。</p><p>②多层索引:建立多层索引(原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。缺点:即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p><p>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引(指向两层索引表)。优点:对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p><h4 id="三种分配方式总结"><a href="#三种分配方式总结" class="headerlink" title="三种分配方式总结"></a>三种分配方式总结</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537437.png" alt="image"></p><h3 id="对空闲磁盘块的管理（文件存储空间管理）"><a href="#对空闲磁盘块的管理（文件存储空间管理）" class="headerlink" title="对空闲磁盘块的管理（文件存储空间管理）"></a>对空闲磁盘块的管理（文件存储空间管理）</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537438.png" alt="image"></p><h4 id="文件卷"><a href="#文件卷" class="headerlink" title="文件卷"></a>文件卷</h4><p>存储空间的划分:将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)。所谓的文件卷就相当于电脑上的C盘，D盘等。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537439.png" alt="image"></p><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p>为一个磁盘创建一个表，来存储空闲磁盘块的位置。</p><p>如何分配磁盘块 : 与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p>如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况―—①回收区的前后都没有相邻空闲区;②回收区的前后都是空闲区;③回收区前面是空闲区;④回收区后面是空闲区。总之，回收时需要注意表项的合并问题。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537440.png" alt="image"></p><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p>空闲链表发分为空闲盘块链和空闲盘区链。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537441.png" alt="image"></p><h5 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h5><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li><li>如何回收:回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li><li>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537442.png" alt="image"></p><h5 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h5><ul><li>操作系统保存着链头、链尾指针。</li><li>如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li><li>如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li><li>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537443.png" alt="image"></p><h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用(字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号)</p><p>(字号,位号)&#x3D;(i j)  的二进制位对应的盘块号 b&#x3D; ni + j</p><p>b号盘块对应的字号i &#x3D; b&#x2F;n，位号j &#x3D; b%n。</p><p>如何分配:若文件需要K个块，</p><p>①顺序扫描位示图，找到K个相邻或不相邻的“0”;</p><p>②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;</p><p>③将相应位设置为“1”。</p><p>如何回收:</p><p>①根据回收的盘块号计算出对应的字号、位号;</p><p>②将相应二进制位设为“0”。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537444.png" alt="image"></p><h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h4><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。<br>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537445.png" alt="image"></p><ul><li>超级块中存储的内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537446.png" alt="image"></p><ul><li><p>如何分配?<br>Eg :需要100个空闲块<br>①检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</p><p>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</p><p>Eg :需要1个空闲块<br>①检查第一个分组的块数是否足够。1&lt;100，因此是足够的。</p><p>②分配第一个分组中的1个空闲块，并修改相应数据</p></li><li><p>如何回收?<br>Eg :假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。</p><p>Eg : 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p></li></ul><h3 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>进行Create系统调用时，需要提供的几个主要参数:</p><ol><li><p>所需的外存空间大小（如:一个盘块，即1KB)</p></li><li><p>文件存放路径（“D:&#x2F;Demo”)</p></li><li><p>文件名（这个地方默认为“新建文本文档.txt”)</p><p>操作系统在处理Create系统调用时，主要做了两件事:</p></li></ol><p>1.在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)<br>2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:&#x2F;Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>进行Delete系统调用时，需要提供的几个主要参数:</p><p>1.文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（“test.txt”)</p><p>操作系统在处理Delete系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p><p>2．根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</p><p>3.从目录表中删除文件对应的目录项。</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:<br>1．文件存放路径（“D:&#x2F;Demo”)</p><p>2.文件名（ “test.txt”)</p><p>3．要对文件的操作类型（如:r只读;rw读写等)</p><p>操作系统在处理open系统调用时，主要做了几件事:</p><p>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p><p>2．将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537447.png" alt="image"></p><ul><li>需要注意的是，有两张打开文件表，一个是进程自带的，另一个是系统的（只有一张）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537448.png" alt="image"></p><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>进程使用完文件后，要“关闭文件”。<br>操作系统在处理Close系统调用时，主要做了几件事:</p><p>1.将进程的打开文件表相应表项删除</p><p>2.回收分配给该文件的内存空间等资源</p><p>3.系统打开文件表的打开计数器count 减1，若count &#x3D;0，则删除对应表项。</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>进程使用read系统调用完成写操作。</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，</p><p>还需要指明要读入多少数据（如:读入1KB）、</p><p>指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>进程使用write系统调用完成写操作，</p><p>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），</p><p>还需要指明要写出多少数据（如:写出1KB)、</p><p>写回外存的数据放在内存中的什么位置</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><h4 id="基于索引节点的共享方式（硬链接）"><a href="#基于索引节点的共享方式（硬链接）" class="headerlink" title="基于索引节点的共享方式（硬链接）"></a>基于索引节点的共享方式（硬链接）</h4><p>知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537449.png" alt="image"></p><p><strong>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</strong><br>若count &#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。<br>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当count &#x3D;0时系统负责删除文件。</p><h4 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h4><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。类似于快捷方式。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537450.png" alt="image"></p><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><h4 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h4><p>为文件设置一个“口令”(如: abc112233），用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p><p>优点:保存口令的空间开销不多，验证口令的时间开销也很小。</p><p>缺点:正确的“口令”存放在系统内部，不够安全。</p><h4 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h4><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。<br>Eg:一个最简单的加密算法――异或加密。<br>假设用于加密&#x2F;解密的“密码”为“01001”。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537451.png" alt="image"></p><p>优点:保密性强，不需要在系统中存储“密码”。</p><p>缺点:编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表(Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537452.png" alt="image"></p><p>精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537453.png" alt="image"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537454.png" alt="image"></p><h3 id="文件的层次结构"><a href="#文件的层次结构" class="headerlink" title="文件的层次结构"></a>文件的层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537455.png" alt="image"></p><p>用一个例子来辅助记忆文件系统的层次结构:</p><p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx”的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求一用户接口。</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―一存取控制模块（存取控制验证层)</li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。</li></ol><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li><li>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</li><li>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB)。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537456.png" alt="image"></p><ul><li>所有盘面中相对位置相同的磁道组成柱面。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537457.png" alt="image"></p><ul><li><p><strong>可用(柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。</strong></p></li><li><p>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面;<br>②激活指定盘面对应的磁头;<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p></li><li><p>磁盘分类</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537458.png" alt="image"></p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537459.png" alt="image"></p><ul><li><p><strong>寻找时间</strong>(寻道时间)Ts:在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。<br>①启动磁头臂是需要时间的。假设耗时为s;<br>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:<br>寻道时间Ts &#x3D; s + m*n </p></li><li><p><strong>延迟时间</strong>T:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位:转&#x2F;秒，或转&#x2F;分），则平均所需的延迟时间T&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D; 1&#x2F;2r。</p><p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2</p></li><li><p><strong>传输时间</strong>Tt:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则:<br>传输时间Tt &#x3D; (1&#x2F;r)*(b&#x2F;N) &#x3D; b&#x2F;(rN)</p><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需的时间刚好又是转一圈所需要的时间1&#x2F;r。</p></li><li><p>总的平均存取时间    T&#x3D;Ts+ 1&#x2F;2r + b&#x2F;(rN)</p></li></ul><p>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。但是操作系统的磁盘调度算法会直接影响寻道时间。</p><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><ul><li>根据进程请求访问磁盘的先后顺序进行调度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537461.png" alt="image"></p><h4 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h4><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537462.png" alt="image"></p><h4 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h4><p>SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537463.png" alt="image"></p><h4 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h4><p>扫描算法（SCAN)中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK)。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537464.png" alt="image"></p><h4 id="循环扫描算法（C—SCAN）"><a href="#循环扫描算法（C—SCAN）" class="headerlink" title="循环扫描算法（C—SCAN）"></a>循环扫描算法（C—SCAN）</h4><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537465.png" alt="image"></p><h4 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h4><p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537466.png" alt="image"></p><h3 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537467.png" alt="image"></p><p>假设要连续读取橙色区域的2、3、4扇区:<br>磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转<br>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区<br>必须等盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入。</p><p>结论:磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537468.png" alt="image"></p><h4 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h4><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537469.png" alt="image"></p><h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><p>思考:为什么磁盘的物理地址是（柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)？</p><p>答:读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p><p>注：不是很理解</p><h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537470.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537471.png" alt="image"></p><h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><p>磁盘初始化:<br>Step 1:进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p><p>Step 2:将磁盘分区，每个分区由若干柱面（磁道）组成（即分为我们熟悉的C盘、D盘、E盘)</p><p>step 3:进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537472.png" alt="image"></p><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><ul><li><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p></li><li><p>初始化程序可以放在ROM(只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改 。</p></li></ul><p>初始化程序程序（自举程序）放在ROM中存在什么问题?万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p><ul><li><p>ROM中只存放很小的“自举装入程序”。开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</p></li><li><p>完整的自举程序放在磁盘的启动块(即引导块&#x2F;启动分区)上，启动块位于磁盘的固定位置。</p></li><li><p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（c:盘)</p></li></ul><h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><ul><li>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。 </li><li>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，坏块对操作系统不透明)</li><li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。<br>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</li></ul><h2 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I&#x2F;O管理"></a>I&#x2F;O管理</h2><h3 id="I-O设备的概念"><a href="#I-O设备的概念" class="headerlink" title="I&#x2F;O设备的概念"></a>I&#x2F;O设备的概念</h3><ul><li>“I&#x2F;O” 就是“输入&#x2F;输出”(Input&#x2F;Output)</li><li>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</li></ul><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><ul><li>CPU无法直接控制l&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</li><li>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;o控制器，又由I&#x2F;O控制器来控制设备的机械部件。</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537473.png" alt="image"></p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537474.png" alt="image"></p><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><ul><li>完成一次读&#x2F;写操作的流程图(以读操作为例)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537475.png" alt="image"></p><ul><li>流程图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537476.png" alt="image"></p><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><ul><li>由于程序直接控制方式CPU利用率低，忙等，所以提出了中断驱动方式。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537477.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537478.png" alt="image"></p><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><ul><li>虽然中断驱动方式解决了程序直接控制方式的问题，但是每一次只能读&#x2F;写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537479.png" alt="image"></p><ul><li>DMA控制器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537480.png" alt="image"></p><p>- </p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537481.png" alt="image"></p><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><ul><li>通道控制方式是为了解决DMA方式连续存储的问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537482.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537483.png" alt="image"></p><h4 id="四种方式总结"><a href="#四种方式总结" class="headerlink" title="四种方式总结"></a>四种方式总结</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537484.png" alt="image"></p><h3 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h3><h4 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537485.png" alt="image"></p><h4 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h4><ul><li>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;o操作相关的库函数对设备进行操作。</li><li>用户层软件将用户请求翻译成格式化的I&#x2F;o请求，并通过“系统调用”请求操作系统内核的服务。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537486.png" alt="image"></p><h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要功能：</p><ol><li>向上层提供统一的调用接口（如read&#x2F;write系统调用)</li><li>设备的保护。（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。）</li><li>差错处理（设备独立性软件需要对一些设备的错误进行处理）</li><li>设备的分配与回收</li><li>数据缓冲区管理（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li>建立逻辑设备名到物理设备名的映射关系;根据设备类型选择调用相应的驱动程序</li></ol><p>用户或用户层软件发出I&#x2F;o操作相关系统调用的系统调用时，需要指明此次要操作的I&#x2F;o设备的逻辑设备名（eg:去学校打印店打印时，需要选择打印机1&#x2F;打印机2&#x2F;打印机3，其实这些都是逻辑设备名)<br>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537487.png" alt="image"></p><p>操作系统系统可以采用两种方式管理逻辑设备表(LUT) :<br>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p><p>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p><h4 id="驱动设备"><a href="#驱动设备" class="headerlink" title="驱动设备"></a>驱动设备</h4><p>思考:为何不同的设备需要不同的设备驱动程序?</p><p>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537488.png" alt="image"></p><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>当I&#x2F;o任务完成时，I&#x2F;o控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下:</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537489.png" alt="image"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537490.png" alt="image"></p><h3 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h3><h4 id="知识总览-1"><a href="#知识总览-1" class="headerlink" title="知识总览"></a>知识总览</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537491.png" alt="image"></p><ul><li>这些功能在哪些层次上实现呢？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537492.png" alt="image"></p><h4 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I&#x2F;O调度"></a>I&#x2F;O调度</h4><p><strong>I&#x2F;O调度:用某种算法确定一个好的顺序来处理各个I&#x2F;o请求。</strong><br>如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。</p><p>当多个磁盘I&#x2F;o请求到来时，用某种调度算法确定满足I&#x2F;o请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定IV&#x2F;o调度顺序。</p><h4 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h4><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。<br>在UNIx系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)</p><h3 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h3><h4 id="脱机技术"><a href="#脱机技术" class="headerlink" title="脱机技术"></a>脱机技术</h4><ul><li>手工操作阶段:主机直接从l&#x2F;o设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。因此在批处理阶段引入了脱机输入&#x2F;输出技术（用磁带完成).</li></ul><p>Tips:为什么称为“脱机”？一脱离主机的控制进行的输入&#x2F;输出操作。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537493.png" alt="image"></p><h4 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h4><p>“假脱机技术”，又称“SPOOLing 技术”，用软件的方式模拟脱机技术。SPOQLing系统的组成如下:</p><ul><li>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;o设备输入的数据</li><li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据 </li><li>“输入进程”模拟脱机输入时的外围控制机</li><li>“输出进程”模拟脱机输出时的外围控制机</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537494.png" alt="image"></p><p>要实现SPOOLing 技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”。</p><h3 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h3><h4 id="知识总览-2"><a href="#知识总览-2" class="headerlink" title="知识总览"></a>知识总览</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537495.png" alt="image"></p><h4 id="设备分配时考虑的因素"><a href="#设备分配时考虑的因素" class="headerlink" title="设备分配时考虑的因素"></a>设备分配时考虑的因素</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537496.png" alt="image"></p><h5 id="固有属性"><a href="#固有属性" class="headerlink" title="固有属性"></a>固有属性</h5><p>设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。</p><ul><li>独占设备—— 一个时段只能分配给一个进程（如打印机)</li><li>共享设备――可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li>虚拟设备――采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</li></ul><h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><p>先来先服务，优先级高者优先，短任务优先…….</p><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>从进程运行的安全性上考虑，设备分配有两种方式:</p><p><strong>安全分配方式</strong>:为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒。(eg:考虑进程请求打印机打印输出的例子)</p><ul><li>一个时段内每个进程只能使用一个设备</li><li>优点:破坏了“请求和保持”条件，不会死锁</li><li>缺点:对于一个进程来说，CPU和I&#x2F;o设备只能串行工作</li></ul><p><strong>不安全分配方式</strong>:进程发出I&#x2F;o请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;o请求。只有某个l&#x2F;o请求得不到满足时才将进程阻塞。</p><ul><li>一个进程可以同时使用多个设备</li><li>优点:进程的计算任务和I&#x2F;o任务可以并行处理，使进程迅速推进</li><li>缺点:有可能发生死锁(死锁避免、死锁的检测和解除)</li></ul><h4 id="静态分配和动态分配"><a href="#静态分配和动态分配" class="headerlink" title="静态分配和动态分配"></a>静态分配和动态分配</h4><ul><li>静态分配:进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁</li><li>动态分配:进程运行过程中动态申请设备资源</li></ul><h4 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h4><p>“设备、控制器、通道”之间的关系:</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537497.png" alt="image"></p><ul><li>**设备控制表（DCT):**系统为每个设备配置一张DCT，用于记录设备情况</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537498.png" alt="image"></p><ul><li>**控制器控制表(COCT):**每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537499.png" alt="image"></p><ul><li>**通道控制表（CHCT):**每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537500.png" alt="image"></p><ul><li><strong>系统设备表(SDT)</strong>:记录了系统中全部设备的情况，每个设备对应一个表目。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537501.png" alt="image"></p><h4 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h4><p>①根据进程请求的物理设备名查找SDT（注:物理设备名是进程请求分配设备时提供的参数)</p><p>②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p><p>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p>注∶只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动&#x2F;O设备进行数据传送。</p><p>缺点:<br>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</p><p>②若换了一个物理设备，则程序无法运行</p><p>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p><p>改进方法:建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537502.png" alt="image"></p><h4 id="设备分配步骤的改进"><a href="#设备分配步骤的改进" class="headerlink" title="设备分配步骤的改进"></a>设备分配步骤的改进</h4><p>①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)</p><p>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT)中新增一个表项。</p><p>③根据DCT找到cOCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p><p>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537503.png" alt="image"></p><ul><li>逻辑设备表</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537504.png" alt="image"></p><h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h3><h4 id="知识总览-3"><a href="#知识总览-3" class="headerlink" title="知识总览"></a>知识总览</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537505.png" alt="image"></p><h4 id="含义和作用"><a href="#含义和作用" class="headerlink" title="含义和作用"></a>含义和作用</h4><blockquote><p>含义</p></blockquote><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p><blockquote><p>作用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537506.png" alt="image"></p><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。如图所示<br><strong>注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537507.png" alt="image"></p><ul><li>处理一块数据的平均时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537508.png" alt="image"></p><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)。</p><ul><li>假设T&gt;C+M</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537509.png" alt="image"></p><ul><li>假设T&lt;C+M</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537510.png" alt="image"></p><p>**结论:采用双缓冲策略，处理一个数据块的平均耗时为Max (T,C+M)**。</p><h4 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h4><p>将多个大小相等的缓冲区链接成一个循环队列。<br>注:以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537511.png" alt="image"></p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。</p><p>这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列(输入队列)、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区(sout)。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191537512.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>八股文</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="模型各层协议"><a href="#模型各层协议" class="headerlink" title="模型各层协议"></a>模型各层协议</h2><p><strong>网络层</strong>：</p><ol><li><p>IP协议</p><blockquote><p>路由选择协议：</p><ol><li>RIP，内部网关</li><li>OSPF，内部网关</li><li>BGP，外部网关</li></ol></blockquote></li><li><p>ICMP协议</p></li><li><p>IGMP协议</p></li><li><p>ARP协议</p></li></ol><p><strong>传输层</strong>：</p><ol><li>TCP协议，可靠传输</li><li>UDP协议，不可靠传输</li></ol><p><strong>应用层</strong>：</p><ol><li>http协议，https协议</li><li>ftp协议</li><li>DNS协议</li><li>SMTP协议，发邮件</li><li>POP3协议，收邮件</li><li>RDP协议，远程桌面</li></ol><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p><strong>计算机网络的重要功能</strong>：</p><ul><li>连通性  –彼此连通，交换信息</li><li>共享  –信息共享、软硬件共享</li></ul><h3 id="Internet概述"><a href="#Internet概述" class="headerlink" title="Internet概述"></a>Internet概述</h3><p><strong>网络</strong>：由<strong>多个计算机</strong>连接<strong>同一个交换机</strong>所形成的<strong>局域网</strong>称为网络</p><p><strong>互联网(internet)<strong>：由</strong>许多网络</strong>连接<strong>同一个路由器</strong>所形成的网称为互联网</p><p><strong>因特网(Internet)<strong>：</strong>全球最大的一个互联网</strong>，<code>使用TCP/IP协议</code></p><p><strong>ISP</strong>：互联网运营商</p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><strong>因特网边缘部分</strong>：</p><p>​<code>主机之间的通信方式</code>:</p><ol><li>客户端服务器方式(Client&#x2F;Server方式 –C&#x2F;S)</li><li>对等(Peer-to-Peer方式 –P2P)方式</li></ol><p><strong>因特网的核心</strong>：</p><p><code>数据交换方式</code>：</p><ol><li><p>电路交换(Circuit Switching)</p></li><li><p>报文交换(Message Switching)</p><ul><li><p>将内容全部发送</p></li><li><p><em>缺点</em>：时延最长，报文内容长</p></li></ul></li><li><p>分组交换(Packet Switching)</p><ul><li><p>将发送内容分组发送，然后能够并发发送，就是A设备发送第二个包时，B设备就能向C设备发送第一个包。</p></li><li><p><em>优点</em>：高效、灵活、迅速、可靠</p></li><li><p><em>缺点</em>：时延较长、开销大</p></li></ul></li></ol><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><p><strong>计算机网络最简单的定义</strong>：一些互相连接的、自治的计算机的集合</p><p>根据<strong>作用范围分类</strong>：</p><ol><li>广域网(WAN)</li><li>城域网(MAN)</li><li>局域网(LAN)</li><li>个人区域网(PAN)</li></ol><p>注：不单单从网络覆盖范围区分局域网和广域网，如果使用局域网技术就称为局域网，使用了广域网技术就称为广域网。</p><p>根据<strong>使用者分类</strong>：</p><ol><li>公用网(Public Network)</li><li>专用网(Private Network)</li></ol><p>根据<strong>拓扑排序分类</strong>：</p><ol><li>总线型</li><li>环型</li><li>星型</li><li>树型</li><li>网型</li></ol><p>根据<strong>交换类型分类</strong>：</p><ol><li>电路交换网</li><li>报文交换网</li><li>分组交换网</li></ol><p>根据<strong>工作方式分类</strong>：</p><ol><li>资源子网</li><li>通信子网</li><li>接入网</li></ol><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><p><strong>计算机网络性能指标</strong>：</p><p>注：数据的发送速率不是比特在链路上的传播速率</p><ol><li><p><code>速率</code>：连接在计算机网络上的<strong>主机</strong>在数字信道上传送<strong>数据位数</strong>的速率，单位是b&#x2F;s,kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s。数据量&#x2F;信息量的单位</p></li><li><p><code>带宽</code>：①频域称谓，赫兹Hz，信号具有的频带宽度；②时域称谓，比特每秒（b&#x2F;s），通信线路的<strong>最高数据率</strong>；两者本质一样，宽度越大，传输速率自然越高；</p></li><li><p><code>吞吐量</code>：单位时间内通过某个网络（或信道、接口）的数据量。受网络的带宽或网络的额定速率的限制。单位b&#x2F;s,Mb&#x2F;s等</p></li><li><p><code>时延</code>：</p><blockquote><ol><li><strong>发送时延</strong>，发送时延&#x3D;数据块长度(比特)&#x2F;信道带宽(比特&#x2F;s)</li><li><strong>传播时延</strong>，传播时延&#x3D;信道长度(米)&#x2F;信号在信道上的传播速率(米&#x2F;秒)</li><li><strong>处理时延</strong>，网络节点存储转发处理时间(交换结点为存储转发而进行一些必要的处理所花费的时间)</li><li><strong>排队时延</strong>，结点缓存队列中分组排队所经历的时延。（取决于当时的通信量）；</li></ol></blockquote></li><li><p><code>时延带宽积</code>：时延带宽积（体积）&#x3D;传播时延（长)*带宽（截面积），以比特为单位的链路长度；</p></li><li><p><code>往返时间</code>：简单来说，就是两倍传播时延（实际上还包括处理时延，排队时延，转发时的发送时延）；</p></li><li><p><code>利用率</code>：</p><blockquote><ol><li><strong>信道利用率</strong>：有数据通过时间&#x2F;(有+无)数据通过时间</li><li><strong>网络利用率</strong>：信道利用率的加权平均值，D&#x3D;D<sub>0</sub>&#x2F;(1-U)，D<sub>0</sub>表示网络空闲时的时延，D表示网络当前的时延，U表示信道利用率。因此利用率不是越高越好。减少方法：增大线路的带宽。</li></ol></blockquote></li></ol><p><strong>计算机网络非性能指标</strong>：</p><ol><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性</li><li>可升级性</li><li>管理与维护</li></ol><h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><p><strong>基本概念</strong>：</p><ul><li><strong>ISO</strong>：国际化标准化组织</li><li><strong>OSI&#x2F;RM</strong>：互联网法律上的国际标准，开放系统互连参考模型，分7层</li><li><strong>TCP&#x2F;IP</strong>：因特网事实上的国际标准</li><li><strong>协议</strong>(Network Protocols)：数据交换遵守的规则、标准或约定。三要素：语法(结构和格式)、语义(动作)、同步(顺序)</li><li><strong>网络体系结构</strong>：计算机网络各层及其协议的集合</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544382.png" alt="image"></p><p><strong>分层好处</strong>：</p><ol><li>有利于标准化</li><li>各层之间是独立的，互不影响</li><li>灵活性好</li><li>结构上可分割开</li><li>易实现和维护</li></ol><p><strong>OSI七层模型</strong>：</p><ol><li><code>应用层</code>(Application)：应用层通过各种协议（FTP——文件传输协议；HTTP&#x2F;S——网上冲浪协议；SMTP——邮件传输协议；Telnet——与虚拟端之间的通信协议），<strong>为用户正在运行的程序提供服务</strong>。</li><li><code>表示层</code>(Presentation)：表示层会将从应用层接收的<strong>数据</strong>进行<strong>加密</strong>，<strong>压缩</strong>操作。</li><li><code>会话层</code>(Session)：会话层用于<strong>建立和管理连接、启用、发送和连接数据</strong>，来<strong>建立服务端和客户端会话</strong>。在Windows中可以在命令行输入netstat -nb可以查看电脑的会话信息</li><li><code>传输层</code>(Transport)：通过网络连接传输数据，涉及流量控制（Flow Control）、差错控制（Error Control）、面向连接（TCP，分段数据传输建立会话，可靠传输）和无连接（UDP，不建立会话传输，不可靠传输）的传输</li><li><code>网络层</code>(Network)：用于将接收到的数据段从一台计算机传输到不同网络中的另一台计算机，功能是<strong>进行逻辑寻址(也就是寻找ip，分配ip操作)、路由（Rout）和路径确定(最佳路径选择)，负责分组交换网上的不同主机提供通信服务（IP）</strong>。</li><li><code>数据链路层</code>(Data Link)：<strong>将网络层交下来的IP数据通过报组装成帧，在两个相邻节点（主机和路由器之间或路由器之间）间的链路上“透明”地传送帧中的数据。</strong>两种寻址方式：<strong>逻辑寻址和物理寻址</strong>。逻辑寻址在网络层已经完成，即在数据段（Segment）中添加了发送方和接收方的IP地址，以形成IP数据包。而物理寻址就是在数据链路层中完成的，其方法就是在IP数据包中<strong>添加发送方计算机和接收方计算机的物理地址：MAC，从而形成一个数据帧</strong>。</li><li><code>物理层</code>(Physical)：<strong>透明地传送比特流</strong>(双绞线、同轴电缆等不在物理层)。</li></ol><p><strong>OSI&#x2F;TCP五层网络模型</strong>：</p><ol><li><code>应用层</code>：<strong>为用户正在运行的程序提供服务</strong>；（HTTP,SMTP,FTP)；</li><li><code>传输层</code>：<strong>负责进程之间的通信提供服务</strong>(TCP报文段，UDP用户数据包)（复用和分用）；</li><li><code>网络层</code>：<strong>负责分组交换网上的不同主句提供通信服务</strong>（IP）；</li><li><code>数据链路层</code>：将网络层交下来的I<strong>P数据报组装成帧</strong>，在两个相邻节点（主机和路由器之间或路由器之间）间的链路上<strong>“透明”地传送帧中的数据</strong>；</li><li><code>物理层</code>：<strong>透明地传送比特流</strong>（双绞线、同轴电缆等不在物理层）。</li></ol><p><strong>网络排错</strong>：</p><p>从底层到高层逐一排查，先排查物理层，网线是否有插，接口是否接对，继而到网络层，查看ip地址是否正确，到应用层，浏览器是否被安装恶意插件，还不行就重装系统。</p><p><strong>实体、协议与服务之间的关系</strong></p><ul><li><code>实体</code>(entity)：交换信息的硬件或软件进程</li><li><code>协议</code>(protocol)：控制两个对等实体通信的规则</li><li><code>服务</code>(service)：下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能</li><li><code>服务访问点</code>(SAP)：相邻两层实体间交换信息的地方。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544383.png" alt="image"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h3><p>物理层<strong>解决如何在连接各种计算机的传输媒体上传输数据比特流</strong>而不是指具体的传输媒体</p><p><strong>主要任务</strong>：确定与传输媒体的接口的一些特性</p><p><strong>特性</strong>：</p><ul><li><code>机械特性</code>：例接口形状，大小，引线数目</li><li><code>电气特性</code>：例规定电压范围(-5V到+5V)</li><li><code>功能特性</code>：例规定-5V表示0，+5V表示1</li><li><code>过程特性</code>：也称规程特性，规定建立连接时各个相关部件的工作步骤</li></ul><h3 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h3><p><strong>数据通信系统</strong>分为：</p><ol><li><p><code>源系统</code>(或发送端、发送方)</p><blockquote><p>源系统分为：</p><ol><li>源点：源点设备产生要传输的数据。</li><li>发送器：通常源点产生的数字比特流要通过发送器编码后才能在传输系统中进行传输。</li></ol></blockquote></li><li><p><code>传输系统</code>(或传输网络)</p></li><li><p><code>目的系统</code>(或接收端、接收方)</p><blockquote><p>目的系统分为：</p><ol><li>接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li><li>终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出。</li></ol></blockquote></li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544384.png" alt="image"></p><p><strong>相关术语</strong>：</p><ul><li>通信的<strong>目的是传送信息</strong>。</li><li>数据(data)  —运送消息的实体。</li><li>信号(signal) —数据的电气的或电磁的表现。</li><li>“模拟信号” —代表信息的参数的取值是连续的。</li><li>“数字信号”  —代表信息的参数的取值是离散的。</li><li>码元(code) —在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元</li><li>在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带n(bit)的信息量</li></ul><p><strong>信道</strong>：</p><p>概念：一般<strong>表示向一个方向传送消息的媒体</strong>。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道。</p><ol><li><code>单向通信</code>(单工通信)：只能<strong>有一个方向的通信而没有反方向的交互</strong>。</li><li><code>双向交替通信</code>(半双工通信)：通信的<strong>双方都可以发送信息</strong>，但<strong>不能</strong>双方<strong>同时发送</strong>(也<strong>不能同时接收</strong>)</li><li><code>双向同时通信</code>(全双工通信)：通信的<strong>双方可以同时发送和接收信息</strong>。</li><li><code>基带信号</code>(基本频带信号)：<strong>来自信源的信号</strong>，对于传输距离较劲时，计算机网络采用基带传输方式。<strong>为使信道能够传输低频分量和直流分量，需要进行调制</strong></li><li><code>带通信号</code>：<strong>基带信号经过载波调制而成</strong>，把信号的<strong>频率范围搬移到较高的频段</strong>以便在信道中传输(即仅在一段频率范围内能够通过信道)</li></ol><p><strong>基本调制方法</strong></p><ul><li><code>调幅(AM)</code>：载波的<strong>振幅随基带数字信号而变化</strong></li><li><code>调频(FM)</code>：载波的<strong>频率随基带数字信号而变化</strong></li><li><code>调相(PM)</code>：载波的<strong>初始相位随基带数字信号而变化</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544385.png" alt="image"></p><p><strong>信道的极限容量</strong>：</p><p>因素：</p><ol><li><code>最高码元传输速率</code>：如果<strong>信道中的码元传输速率超过码元速率的上限值</strong>，则会出现<strong>码元串扰</strong>的问题，使接收端对码元的判决(识别)成为不可能。—可以<strong>通过加宽频带来解决</strong>。</li></ol><blockquote><ul><li><strong>奈式准则</strong>：理想低通信道的最高码元传输速率&#x3D;2WBaud(W是理想低通信道的带宽，单位为Hz，Baud是波特，是码元传输速率的单位)</li><li>如果一个码元含有3个Bit信息量，则1波特&#x3D;3Bit&#x2F;s</li></ul></blockquote><ol start="2"><li><p><code>信噪比</code>：<strong>信号的平均功率和噪声的平均功率之比</strong>，信道的带宽或信道中信噪比越大，则信息的极限传输速率就越高。</p><blockquote><p><strong>香农公式</strong>：</p><ul><li><p>极限信息传输速率C &#x3D; W log2(1+S&#x2F;N) b&#x2F;s ；</p></li><li><p>W为信道的带宽(以Hz为单位)，S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率</p></li><li><p><strong>低于C即可实现无差错传输</strong>，让每个码元携带更多比特的信息量；</p></li></ul></blockquote></li></ol><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><p><strong>导向传输媒体</strong>：</p><p>导向传输媒体中，<strong>电磁波沿着固体媒体传播</strong></p><ol><li><p><code>双绞线</code>：<strong>衰减随着频率的升高而增大</strong></p><blockquote><ul><li>屏蔽双绞线STP，加强抗电磁干扰能力</li><li>无屏蔽双绞线UTP</li></ul></blockquote></li><li><p><code>同轴电缆</code>：<strong>用于传输较高速率的数据</strong></p><blockquote><ul><li><strong>50Ω同轴电缆</strong>，用于<strong>数字传输</strong>，由于多用于基带传输，也叫基带同轴电缆</li><li><strong>75Ω同轴电缆</strong>，用于<strong>模拟传输</strong>，即宽带同轴电缆。</li></ul></blockquote></li><li><p><code>光缆</code>：多模光纤(可以传多个光的波长)，单模光纤(光纤直径下只有一个光的波长)</p></li></ol><p><strong>非导向传输媒体</strong>：</p><p>非导向传输媒体就是指<strong>自由空间</strong>，其中<strong>电磁波传输被称为无线传输</strong></p><ol><li><p><code>短波通信</code>：靠<strong>电离层的反射</strong>，<strong>通信质量较差</strong></p></li><li><p><code>微波通信</code>：主要为<strong>直线传播</strong></p><blockquote><ul><li>地面微波接力通信(中继站)</li><li>卫星通信，有较大的传播时延</li></ul></blockquote></li></ol><p><strong>集线器</strong>：</p><p>在网络中起到<strong>信号放大和重发作用</strong>，其目的<strong>扩大网络的传输范围</strong>，而<strong>不具备信号的定向传送能力</strong>，最大传输距离100米，集线器连的<strong>网络不安全</strong>，集线器的<strong>信道是半双工通信</strong>。</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544386.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544387.png" alt="image"></p><p><strong>频分复用FDM</strong>：</p><ul><li>用户在分配到一定的频带后，在通信过程中自始自终都占用这个频带。</li><li><strong>所有用户在同样的时间占用不同的带宽资源</strong></li><li>注意：这里的带宽是频带带宽而不是数据的发送速率</li></ul><p><strong>时分复用TDM</strong>：</p><ul><li>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。</li><li>每一个用户<strong>所占用的时隙是周期性地出现</strong>(其周期就是TDM帧的长度对应的时间)。TDM信号也称为等时信号。</li><li><strong>所有用户是在不同时间占用同样的频带宽度</strong>。–更有利于数字信号的传输</li><li><strong>时分复用可能会造成线路资源网的浪费</strong></li></ul><p><strong>统计时分复用STDM</strong>：</p><ul><li>在时分复用的基础上，<strong>将各信道传输的数据不再按照将TDM帧中平分各段给各信道</strong>。</li><li><strong>动态分配时隙</strong>。不再有序，而是哪个信道数据先到就先加入到传输的数据块中，并<strong>给该数据块加上标记</strong>，来告诉接收端这是哪个发送端的数据。</li><li>通过<strong>分析标记将个数据放到对应发送端编号的接收端</strong>。</li></ul><p><strong>码分复用CDM</strong>：</p><p>也叫码分多址(CDMA)</p><ul><li>各用户使用<strong>不同的码型</strong></li><li>每个比特时间划分为m个短的间隔，称为码片</li><li>每个站分配的<strong>码片序列</strong>不仅必须<strong>各不相同</strong>，并且还**必须互相正交(orthogonal)**（相乘为0，0为-1）。在实用的系统中是使用伪随机码序列。</li></ul><blockquote><ol><li>任何一个码片向量和该码片向量自己的<strong>规格化内积都是1</strong> ；</li><li>任何一个码片向量和该码片反码的向量自己的<strong>规格化内积都是-1</strong> ；</li><li>任何一个码片向量和其他码片向量的<strong>规格化内积都是0</strong>；</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544388.png" alt="image"></p><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><p><strong>ADSL(非对称数字用户线)技术</strong></p><ul><li>ADSL 技术<strong>把 0 ~ 4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</strong> </li><li><strong>上行和下行带宽不对称</strong>。(下载各种文档，而向互联网发送的信息量一般都不太大，因此 ADSL 的下行（从 ISP 到用户）带宽都远远大于上行（从用户到 ISP）带宽。)</li><li>ADSL 的<strong>传输距离取决于数据率和用户线的线径</strong>(<em>用户线越细，信号传输时的衰减就越大</em>）</li><li>ADSL在用户线两端各安装一个ADSL调制解调器，使用的是<strong>离散多音调DMT调制技术</strong>(该技术采用频分复用的方法)</li></ul><p><strong>光纤同轴混合网HFC</strong></p><ul><li><strong>基于有线电视网CATV网（树型拓扑结构，模拟技术的频分复用）改造</strong>的一种居民宽带接入网</li><li><strong>使用光纤模拟技术，采用光的振幅调制AM</strong>；</li><li><strong>节点体系结构</strong>——模拟光纤连接，构成星形网；提高网络的可靠性，简化了上行信道的设计；</li><li>比CATV网更宽的频谱，且<strong>具有双向传输功能</strong>；</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>数据链路层使用信道</strong>主要有两种：</p><ul><li><code>点对点信道</code>，一对一通信</li><li><code>广播信道</code>，一对多通信</li></ul><p><strong>链路</strong>：是一条点到点的<strong>物理线路</strong>段，<strong>中间没有任何</strong>其他<strong>节点</strong>。</p><p>一条链路只是一条通路的一个组成部分</p><p><strong>数据链路</strong>：除了<strong>物理链路</strong>外，还必须有<strong>通信协议</strong>来控制这些数据的传输。把<strong>实现这些协议的硬件和软件</strong>加到链路上，就构成了数据链路</p><blockquote><ul><li>现最常用的方法是使用适配器(网卡)来实现这些协议的硬件和软件</li><li>一般的适配器都包括了数据链路层和物理层这两层功能</li></ul></blockquote><p><strong>帧</strong>：协议数据单元，数据链路层之间传输的数据单位。</p><p><strong>三个基本问题</strong></p><ul><li><p><code>封装成帧</code>：<strong>加上首部和尾部进行帧定界</strong></p></li><li><p><code>透明传输</code>：<strong>字节填充，加上转义字符ESC(1B)</strong></p></li><li><p><code>差错控制</code>：<strong>循环冗余检验CRC</strong>。</p><blockquote><p>CRC操作：</p><ol><li>将数据段的二进制后填充若干个0(冗余码)</li><li>随机选择位数大于填充0数的二进制作为除数P</li><li>对填充后的数据当作被除数，对每位二进制做逻辑与运算</li><li>将第一段计算完后，继续将算出的结果加上数据剩余部分作为被除数，如果不够除，除数可以为若干个0作为除数。</li><li>将最后得出的余数作为冗余码(FCS帧检验序列)，替代之前填充的0，然后再除以除数P，结果得到的余数为0即为无差错</li></ol></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544389.png" alt="image"></p><p><strong>CRC</strong>只是一种<strong>无比特差错</strong>(如果数据比特差错，则会丢包)，而不是无传输差错(不丢包)的检测机制</p><p><strong>可靠传输</strong>：即<strong>发送什么就收到什么</strong>，就必须再<strong>加上帧编号、确认和重传机制</strong>。</p><h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议(PPP)"></a>点对点协议(PPP)</h3><p>目前使用得最广泛的数据链路层协议</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544390.png" alt="image"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><code>简单 </code> —首要要求</li><li><code>封装成帧</code>，必须规定特殊的字符作为帧定界符</li><li><code>透明性</code>，必须保证数据传输的透明性</li><li><code>多种网络层协议</code>(IP、IPX)</li><li><code>多种类型链路</code>(串并，同异，高低，电光，动静)</li><li><code>差错检测</code>(立即<strong>丢弃有差错的帧</strong>)</li><li><code>检测连接状态</code>(<strong>短时间自动检测</strong>)</li><li><code>最大传送单元</code>(数据部分的最大长度)</li><li><code>网络层地址协商</code>，必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址</li><li><code>数据压缩协商</code>，必须提供一种方法来协商使用数据压缩算法，不要求标准化。</li></ol><p><strong>不需要功能</strong>：</p><ol><li><strong>纠错</strong>(不可靠传输)</li><li><strong>流量控制</strong>(由TCP负责)</li><li><strong>序号</strong>(不是可靠传输，在无线时可用)</li><li><strong>多点线路</strong>(不支持一主对多从)</li><li><strong>半双工或单工链路</strong>(只支持全双工)</li></ol><p><strong>组成</strong></p><ol><li><strong>一个将IP数据报封装到串行链路的方法</strong></li><li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议LCP</strong>(Link Control Protocol)</li><li>一套<strong>网络控制协议NCP</strong>(Network Control Protocol)</li></ol><h4 id="PPP协议帧格式"><a href="#PPP协议帧格式" class="headerlink" title="PPP协议帧格式"></a><strong>PPP协议帧格式</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544391.png" alt="image"></p><ul><li>PPP帧的<strong>首部和尾部分别为4个字段和两个字段</strong></li><li><strong>标志字段F&#x3D;0x7E</strong>(符号’0x’表示后面的字符是用16进制表示，16进制的7E的二进制表示为01111110)</li><li><strong>地址字段A只置为0xFF</strong>。不起作用</li><li><strong>控制字段C通常置为0x03</strong></li><li>PPP是面向字节的，<strong>所有的PPP帧的长度都是整数字节</strong></li></ul><p><strong>协议字段解释信息部分的内容</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544392.png" alt="image"></p><p><strong>实现透明传输操作</strong>：</p><ol><li><p><code>传输字节信息</code>：</p><blockquote><p><strong>字节填充</strong>：</p><ul><li>0x7E字节为<strong>首字节和尾字节</strong></li><li>如果信息字段出现0x7E，就将<strong>每个信息字段中每个0x7E字节</strong>(也就是首字节和尾字节)<strong>转变成2字节序列(0x7D，0x5E)</strong></li><li>若信息字段中<strong>出现一个0x7D字节，则将其转变成为2字节序列(0x7D，0x5D)</strong></li><li>若信息字段中<strong>出现ASCII码的控制字符</strong>(即数值小于0x20的字符)，则<strong>在该字符前面要加入一个0x7D字节</strong>，同时将该字符的编码加以改变</li></ul></blockquote></li><li><p><code>传输比特流数据</code>(PPP协议用在SONET&#x2F;SDH链路时，使用同步传输连串的比特连续传送)：</p><blockquote><p><strong>零比特填充</strong>：</p><ul><li>在<strong>发送端</strong>，只要发现<strong>有5个连续的1</strong>，则立即在第五个1的后面<strong>插入一个0</strong>。</li><li>在<strong>接收端</strong>，对帧中的比特流进行扫描，每当<strong>发现5个连续的1</strong>时，就<strong>将第五个1的后面的一个0删除</strong></li></ul></blockquote></li></ol><h4 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h4><p><strong>链路建立过程</strong>：</p><p>物理链路→LCP链路→鉴别的LCP链路(PAP)→NCP链路(IP协议对应IPCP)</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544393.png" alt="image"></p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p><strong>特点</strong>：局域网为一个单位所拥有，且地理范围和站点数目均有限</p><p><strong>局域网的拓扑</strong>：星形网、环形网(令牌环形)、总线网(CSMA&#x2F;CD和令牌传递)、树形网(频分复用的宽带局域网)</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><code>具有广播功能</code>，从一个站点可很方便地访问全网。局域网上的主机可共享连接到局域网上的各种硬件和软件资源</li><li><code>便于系统的扩展</code>和逐渐地演变，各设备的位置可灵活调整和改变</li><li><code>提高了系统的可靠性、可用性和生存性</code></li></ul><p><strong>共享通信媒体</strong>：</p><ol><li><p><code>静态划分信道</code></p><blockquote><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul></blockquote></li><li><p><code>动态媒体接入控制(多点接入)</code></p><blockquote><ul><li>随机接入(主要被以太网采用)</li><li>受控接入，如多点线路探询，或轮询。(目前已不被采用)</li></ul></blockquote></li></ol><h4 id="载波监听多点接入-碰撞检测-CSMA-CD-协议"><a href="#载波监听多点接入-碰撞检测-CSMA-CD-协议" class="headerlink" title="载波监听多点接入&#x2F;碰撞检测(CSMA&#x2F;CD)协议"></a><strong>载波监听多点接入&#x2F;碰撞检测(CSMA&#x2F;CD)协议</strong></h4><p>以太网所使用的通信协议，是<strong>半双工通信</strong></p><p><code>多点接入</code>：表示许多计算机以多点接入的方式连接在一根总线上(<strong>总线型网络</strong>)</p><p><code>载波监听</code>：指每一个站在<strong>发送数据之前</strong>先要<strong>检测</strong>一下总线上<strong>是否有其他计算机在发送数据</strong>，<strong>如果有</strong>，则<strong>暂时不要发送数据</strong>，以免发生碰撞</p><p><code>碰撞检测</code>：</p><ul><li><p><strong>碰撞</strong>就是多个计算机发送数据，信道上的各信号电压相遇，导致信号电压叠加，造成干扰。</p></li><li><p><strong>碰撞检测</strong>就是计算机边发送数据边检测信道上的信号电压大小。</p><blockquote><ul><li>当<strong>几个站同时在总线上发送数据</strong>时，总线上的<strong>信号电压摆动值将会增大</strong>(互相叠加)</li><li>当一个站<strong>检测到的信号电压摆动值超过一定的门限值</strong>时，就<strong>认为总线上</strong>至少有两个站同时在发送数据，表明<strong>发生了碰撞</strong>。</li></ul></blockquote></li><li><p><strong>检测到碰撞后</strong></p><blockquote><ul><li>在<strong>发生碰撞时</strong>，总线上传输的<strong>信号产生了严重的失真</strong>，无法从中恢复除有用的信息来</li><li>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要<strong>立即停止发送</strong>，免得继续浪费网络资源，然后<strong>等待一段随机时间后再次发送</strong></li></ul></blockquote></li></ul><p>**争用期(碰撞窗口)**：</p><ul><li><strong>最先发送数据帧的站，在发送数据帧后至多经过2τ(tao)(两倍的端到端往返时延)</strong></li><li>以太网的争用期，通常<strong>取51.2μs为争用期的长度</strong></li><li>对于10Mb&#x2F;s以太网，在争用期内可发送512bit，也就是64字节。</li><li>以太网在发送数据时，<strong>若前64字节未发生冲突，则后续的数据就不会发生冲突</strong></li><li><code>使用截断二进制指数退避(动态退避)</code></li></ul><p><strong>最短有效帧长</strong>：</p><ul><li><strong>以太网规定了最短有效帧长为64字节</strong>，凡<strong>长度小于64字节的帧</strong>都是由于冲突而异常终止的<strong>无效帧</strong></li><li><strong>如果发生冲突，就一定是在发送的前64字节之内</strong></li></ul><p><strong>二进制指数类型退避算法</strong>：</p><p><code>概念</code>：<strong>发生碰撞</strong>的站在<strong>停止发送数据</strong>后，需要<strong>推迟(退避)一个随机时间才能再发送数据</strong></p><p><code>步骤</code>：</p><ul><li>确定<strong>基本退避时间</strong>，一般是<strong>取</strong>为<strong>争用期2τ</strong></li><li>定义参数k，<strong>k&#x3D;Min[重传次数，10]</strong></li><li>从<strong>整数集合[0,1,…,(2<sup>k</sup>-1)]<strong>中</strong>随机地抽取一个数</strong>，记为<strong>r</strong>，<strong>重传所需的时延就是r倍的基本退避时间</strong></li><li><strong>当重传达16次仍不能成功时即丢弃该帧</strong>，并向高层报告</li></ul><h4 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a><strong>以太网的信道利用率</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544394.png" alt="image"></p><ul><li><p>信道占用期：<strong>帧长为L(bit)<strong>，</strong>数据发送速率为C(b&#x2F;s)<strong>，</strong>帧的发送时间为T<sub>0</sub>(s)&#x3D;L&#x2F;C</strong></p></li><li><p>发送一帧所需时间为：一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间τ使得信道上无信号在传播)时为止。</p></li><li><p><code>参数a</code>：<strong>a&#x3D;τ&#x2F;T<sub>0</sub></strong></p><blockquote><ol><li>要<strong>提高以太网的信道利用率</strong>，就<strong>必须减小τ与T<sub>0</sub>之比</strong>。在以太网中定义了参数a，它是<strong>以太网单程端到端时延τ与帧的发送时间T<sub>0</sub>之比</strong></li><li><strong>a-&gt;0</strong>表示一发生碰撞就立即可以检测出来，并立即停止发送，因而<strong>信道利用率很高</strong></li><li><strong>a越大</strong>，表明<strong>争用期所占的比例增大</strong>，每发生一次碰撞就浪费许多信道资源，使得<strong>信道利用率明显降低</strong></li></ol></blockquote></li><li><p><code>参数要求</code>：1、当<strong>数据率一定</strong>时，以太网的<strong>连线的长度受到限制</strong>，否则τ的数值会太大。2、以太网的<strong>帧长不能太短</strong>，否则T<sub>0</sub>的值会太小，使a值太大</p></li><li><p><code>极限信道利用率</code>：也就是信道利用率的最大值，**S<sub>max</sub>&#x3D;1&#x2F;(1+a)**，极限信道率产生在理想化的情况下，要求以太网各站发送数据都不会发生碰撞</p></li></ul><h4 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h4><p><strong>概念</strong>：</p><ul><li>在局域网中，<strong>硬件地址又称为物理地址，或MAC地址</strong>，<strong>MAC地址是全球唯一的</strong>，由48位二进制组成，前24位为生产厂商编号，后24位为厂商自己编排。</li><li>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处；</li></ul><p><strong>适配器检测MAC地址</strong></p><p>适配器从网络上<strong>每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址</strong></p><ul><li>如果<strong>发往本站的帧就收下</strong>，然后再进行其他的处理</li><li><strong>否则就将此帧丢弃</strong>，不再进行其他处理</li></ul><p><strong>发往本站的帧包括以下三种帧</strong>：</p><ul><li><code>单播帧</code>(一对一)</li><li><code>广播帧</code>(一对全体)</li><li><code>多播帧</code>(一对多)</li></ul><p><strong>MAC帧</strong>：</p><ul><li>最常用的MAC帧是<strong>以太网V2的格式</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544395.png" alt="image"></p><ul><li>利用曼切斯特编码来确定以太网帧的结束位置</li><li>数据字段的长度不再46<del>1500字节之间，且MAC帧长度不在64</del>1518字节之间，帧的长度不是整数个字节，用收到的帧检验序列FCS查出有差错的都是<strong>无效MAC帧</strong></li><li>帧间最小间隔为9.6μs，相当于96bit的发送时间</li></ul><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><ol><li><p><strong>物理层扩展</strong>：<code>集线器扩展局域网</code></p><blockquote><p><strong>优点</strong>：</p><ul><li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信</li><li>扩大了局域网覆盖的地理范围</li></ul><p><strong>缺点</strong>：</p><ul><li>碰撞域增大了，但总的吞吐量并未提高</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它互连起来</li></ul></blockquote></li><li><p><strong>数据链路层扩展</strong>：</p><p><code>网桥扩展</code>：具有<strong>过滤帧</strong>的功能，它会<strong>根据MAC帧的目的地址对收到的帧进行转发</strong>(存储转发)</p><blockquote><p>当网桥收到一个帧时，并<strong>不是向所有的接口转发此帧</strong>，而是先检查次帧的目的MAC地址，然后再确定将该帧转发到哪个接口</p><p>网桥(使用<strong>自学习算法</strong>)<strong>开始也不能识别收到的MAC地址是哪个网段</strong>的，但是随着其他端口不断地向其他端口发送数据，<strong>网段就会记录哪些MAC地址在哪个接口那边</strong>，这样就实现了不是向所有的接口转发帧</p><p><strong>优点</strong>：</p><ul><li><code>过滤通信量</code>(隔离开碰撞域)</li><li><code>扩大了物理范围</code>(增大工作站的数目)</li><li><code>提高了可靠性</code>(出现故障只影响个别网段)</li><li><code>可互联不同物理层、不同MAC子层和不同速率的局域网</code>(如10Mb&#x2F;s和100Mb&#x2F;s以太网)</li></ul><p><strong>缺点</strong>：</p><ul><li><code>存储转发增加了时延</code></li><li><code>在MAC子层并没有流量控制功能</code></li><li><code>具有不同MAC子层的网段桥接在一起时时延更大</code></li><li>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会<code>因传播过多的广播信息而产生网络拥塞</code>。这就是所谓的广播风暴</li></ul></blockquote></li></ol><p><strong>透明网桥</strong>：</p><ul><li>目前使用最多的网桥</li><li>“<strong>透明”<strong>是指局域网上的站点</strong>并不知道所发送的帧将经过哪几个网桥</strong>，因为网桥对各站来说是看不见的。</li><li>透明网是一种<strong>即插即用设备</strong></li><li>使用<strong>生成树算法—任何两个站之间只有一个路径</strong></li></ul><p><strong>自学习算法</strong>：网桥通过该算法处理收到的帧和建立转发表</p><ul><li>若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送A。</li><li>网桥每收到一个帧，就<strong>记下其源地址和进入网桥的接口</strong>，作为转发表中的一个项目</li><li>在建立转发表时是<strong>把帧首部中的源地址写在”地址”这一栏的下面</strong>。</li><li>在转发帧时，则是<strong>根据收到的帧首部中的目的地址来转发</strong>的。这时就把在”地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li></ul><h4 id="以太网交换机-多接口网桥"><a href="#以太网交换机-多接口网桥" class="headerlink" title="以太网交换机(多接口网桥)"></a>以太网交换机(多接口网桥)</h4><p><strong>概念</strong>：以太网交换机是一个多端口的网桥，它工作在数据链路层，交换机能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽</p><p><strong>特点</strong>：</p><ul><li><code>全双工通信</code></li><li><code>独占通信媒体，无碰撞地传输数据</code></li><li>通信方式：有<code>存储转发</code>，也有<code>直通</code>(<strong>不检查差错，但提高速率减少时延</strong>)</li></ul><h4 id="虚拟局域网-VLAN"><a href="#虚拟局域网-VLAN" class="headerlink" title="虚拟局域网(VLAN)"></a>虚拟局域网(VLAN)</h4><p><strong>概念</strong>：虚拟局域网VLAN是由一些局域网网段构成的<strong>与物理位置无关</strong>的<strong>逻辑组</strong></p><ul><li><strong>同一VLAN的成员可以收到其他成员的广播信息</strong></li></ul><p><strong>好处</strong>：</p><ul><li>分段</li><li>灵活性</li><li>安全性</li></ul><p><strong>高速以太网</strong>：速率达到或超过100Mb&#x2F;s的以太网</p><p><strong>快速以太网</strong>：在双绞线上传送100Mb&#x2F;s基带信号的星型拓扑以太网，仍使用IEEE 802.3CSMA&#x2F;CD协议。<strong>100BASE-T以太网</strong>。</p><p>100BASE-T以太网的物理层：</p><ul><li>100BASE-TX：使用两对UTP 5类线或屏蔽双绞线STP</li><li>100BASE-FX：使用两对光纤</li><li>100BASE-T4：使用4对UTP 3类线或5类线</li></ul><p><strong>吉比特以太网</strong>：</p><ul><li>允许在<strong>1Gb&#x2F;s下全双工和半双工两种方式工作</strong>，<strong>使用802.3协议规定的帧格式</strong></li><li>在半双工方式下使用CSMA&#x2F;CD协议(全双工方式不需要使用)</li><li>与10BASE-T和100BASE-T技术向后兼容</li><li>当吉比特以太网工作在全双工方式时(即通信双方可同时进行发送和接收数据)，不使用载波延伸和分组突发</li></ul><p>吉比特以太网的物理层：</p><p>1000BASE-X  基于光纤通道的物理层：</p><ul><li><p>1000BASE-SX  SX表示短波长</p></li><li><p>1000BASE-LX  LX表示长波长</p></li><li><p>1000BASE-CX  CX表示铜线</p></li></ul><p>1000BASE-T：</p><ul><li>使用4对5类线UTP</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层现在拥有的协议：</p><ul><li><code>网际协议 IP</code></li><li><code>地址解析协议 ARP</code>(包括了逆地址解析协议 RARP)</li><li><code>网际控制报文协议 ICMP</code></li><li><code>网际组管理协议 IGMP</code></li></ul><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>在数据链路层并没有实现可靠传输，因此网络层需要解决这个问题。</p><p>争论点：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？应该是由<strong>端系统负责</strong></p><ol><li><p><code>虚电路服务</code>：</p><ul><li><strong>面向连接</strong>的通信方式</li><li>通信之前，需要<strong>先建立连接</strong>(需要在分组交换中是建立一条<strong>虚电路VC(逻辑上的连接)</strong>)</li><li>所有的通信就<strong>沿着已经建立的虚电路发送分组</strong></li><li><strong>分组首部</strong>不需要填写完整的目的主机地址，而<strong>只需要填写虚电路的编号</strong>。减少了分组的开销</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544396.png" alt="image"></p></li><li><p><code>数据报服务</code>：</p><ul><li><strong>无连接</strong>的通信方式</li><li><strong>网络层不提供服务质量的保障</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544397.png" alt="image"></p></li></ol><p><strong>虚电路服务与数据报服务的对比</strong></p><table><thead><tr><th align="left">对比的方面</th><th align="left">虚电路服务</th><th align="left">数据报服务</th></tr></thead><tbody><tr><td align="left">思路</td><td align="left">可靠通信应当由<strong>网络来保证</strong></td><td align="left">可靠通信应当由<strong>用户主机来保证</strong>(端系统)</td></tr><tr><td align="left">连接的建立</td><td align="left">必须有(<strong>面向连接</strong>)</td><td align="left">不需要(<strong>无连接</strong>)</td></tr><tr><td align="left">终点地址</td><td align="left"><strong>仅在连接阶段使用</strong>，每个分组<strong>使用短的虚电路号</strong></td><td align="left"><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td align="left">分组的转发</td><td align="left">属于<strong>同一条虚电路</strong>的分组均<strong>按照同一路由进行转发</strong></td><td align="left">每个分组独立查找转发表(<strong>选择路由</strong>)进行<strong>转发</strong></td></tr><tr><td align="left">当节点出故障时</td><td align="left"><strong>所有通过出故障的节点的虚电路均不能工作</strong></td><td align="left"><strong>出故障的节点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td align="left">分组的顺序</td><td align="left">总是<strong>按发送顺序</strong>到达终点</td><td align="left">到达终点时<strong>不一定按发送顺序</strong></td></tr><tr><td align="left">端到端的差错处理和流量控制</td><td align="left">可以<strong>由网络负责</strong>，<strong>也可以由用户主机负责</strong></td><td align="left">由<strong>用户主机负责</strong></td></tr></tbody></table><h3 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h3><h4 id="虚拟互联网-IP网"><a href="#虚拟互联网-IP网" class="headerlink" title="虚拟互联网(IP网)"></a>虚拟互联网(IP网)</h4><p><strong>概念</strong>：逻辑互联网络，使用路由器解决各种异构的物理网络连接在一起的问题。使用IP协议的虚拟互连网络简称为IP网</p><p><strong>网络互联的设备</strong>：</p><p><strong>中间设备</strong>又称为中间系统或中继系统</p><ul><li>物理层中继系统：转发器(repeater)</li><li>数据链路层中继系统：网桥或交换机(bridge)</li><li>网络层中继系统：路由器(router)</li><li>网络层以上的中继系统：网关(gateway)  –<strong>现在说的网关是路由器的接口</strong></li></ul><p><strong>网络互联的问题</strong>：</p><ul><li>不同的寻址方案</li><li>不同的最大分组长度</li><li>不同的网络接入机制</li><li>不同的超时控制</li><li>不同的差错恢复方法</li><li>不同的状态报告方法</li><li>不同的路由选择技术</li><li>不同的用户接入控制</li><li>不同的服务(面向连接服务和无连接服务)</li><li>不同的管理与控制方式</li></ul><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p><strong>IP层次结构</strong>：</p><p>​以IPv4为例，层次化的IP地址将<strong>32位</strong>二进制的<strong>IP地址分为网络ID和主机ID</strong>，每个网络区段都有它对应的ID，将这个ID与主机ID拼接成32位二进制地址则就是IP地址</p><p><strong>分类的IP地址</strong>：</p><p>IP地址由ICANN进行分配(中国向APINC)</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544398.png" alt="image"></p><p><code>A类地址</code>：</p><ul><li>最大网络数：126(2<sup>7</sup>-2)</li><li>可用网络号范围：<strong>1 - 126</strong></li><li>每个网络中最大主机数：16777214</li><li><strong>网络号全0表示本机，全1表示环回测试(127.0.0.1在同一台计算机进行网络传输)</strong></li><li><strong>主机号全0表示本主机的网络地址，全1表示所有主机</strong></li><li>例子：10.81.21.1，10表示网络号，剩下为主机位，子网掩码为255.0.0.0</li></ul><p><code>B类地址</code>：</p><ul><li>最大网络数：16383(2<sup>14</sup>-1)</li><li>可用网络号范围：<strong>128.1 - 191.255</strong></li><li>每个网络中最大的主机数：65534</li><li>例子：128.73.21.1，128.73表示网络号，剩下为主机号，子网掩码为255.255.0.0</li></ul><p><code>C类地址</code>：</p><ul><li>最大网络数：2097151(2<sup>21</sup>-1)</li><li>可用网络号范围：<strong>192.0.1 - 223.255.255</strong></li><li>每个网络中最大的主机数：254</li><li>例子：196.168.17.1，196.168.17表示网络号，剩下为主机号，子网掩码为255.255.255.0</li></ul><p><strong>特殊的几个地址</strong>：</p><ul><li><p>127.0.0.1 <strong>本地环回地址</strong></p></li><li><p>127.0.0.0：<strong>环回自检地址</strong>，表示任意主机本身</p></li><li><p>0.0.0.0：<strong>表示本网络上的本主机</strong></p></li><li><p>**保留的私网地址(企业、学校)**：</p><blockquote><ol><li>A类地址：10.0.0.0 - 10.255.255.255，1个网段</li><li>B类地址：172.16.0.0 - 172.31.255.255，16个网段</li><li>C类地址：192.168.0.0 - 192.168.255.255，256个网段</li></ol></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544399.png" alt="image"></p><p><strong>无分类编制(CIDR)</strong></p><p><strong>IP地址</strong>&#x3D;{网络前缀，主机号}；</p><p>IP地址的”&#x2F;“后表示网络前缀的位数</p><p>最小地址(全0)，最大地址(全1)；</p><p>路由聚合 —构造超网</p><h4 id="IP地址与MAC硬件地址"><a href="#IP地址与MAC硬件地址" class="headerlink" title="IP地址与MAC硬件地址"></a>IP地址与MAC硬件地址</h4><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544400.png" alt="image"></p><ul><li>使用IP地址是为了隐蔽各种底层网络的复杂性而便于分析和研究问题；</li><li><strong>数据链路层看不到数据包的IP地址</strong>；</li><li><code>路由器只根据目的IP地址的网络号进行路由选择</code>；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544401.png" alt="image"></p><ol><li><code>交换机</code>基于<strong>数据帧的MAC地址</strong>转发数据帧，<code>路由器</code>基于<strong>数据包的IP地址</strong>转发数据包</li><li><strong>数据包在传输过程不变，过网络设备数据帧要用新的物理层地址重新封装</strong></li><li><code>MAC地址</code>决定了<strong>数据帧下一跳哪个设备接收</strong>，而<code>IP地址</code>决定了<strong>数据包的起点和终点</strong></li></ol><h4 id="ARP和RARP协议"><a href="#ARP和RARP协议" class="headerlink" title="ARP和RARP协议"></a>ARP和RARP协议</h4><p><strong>ARP协议</strong>(地址解析协议)：</p><p><code>ARP</code>：<strong>IP地址</strong>通过ARP协议<strong>解析为MAC地址</strong></p><p><code>ARP cache</code>：有所在局域网的各主机和路由表的IP地址到MAC地址的映射表</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544402.png" alt="image"></p><ul><li>ARP协议的<strong>请求是广播形式</strong>，响应是单播形式，<strong>一次请求响应</strong>，两边同时<strong>把双方的信息写进ARP cache</strong></li><li>不同局域网的主机，要通过路由器进行ARP查询</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544403.png" alt="image"></p><p><strong>RARP协议</strong>：</p><p><code>RARP</code>：<strong>MAC地址</strong>通过RARP协议<strong>转为IP地址</strong></p><h4 id="IP数据报-包"><a href="#IP数据报-包" class="headerlink" title="IP数据报(包)"></a>IP数据报(包)</h4><p>一个<strong>IP数据包由首部和数据两部分</strong>组成</p><ul><li><strong>首部的前一部分是固定长度</strong>，共<strong>20字节</strong>，是所有IP数据包<strong>必须具备</strong>的</li><li>在首部的固定部分的<strong>后面是一些可选字段</strong>，其长度可变。</li></ul><p><strong>IP数据包具体组成</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544404.png" alt="image"></p><ul><li><p><code>版本</code>：占4位，指<strong>IP协议的版本</strong>，目前的IP协议版本号位4(即IPv4)</p></li><li><p><code>首部长度</code>：占4位，可表示的最大数值是15个单位(一个单位为4字节)，因此IP的<strong>首部的长度最大值是60字节</strong></p></li><li><p><code>区分服务</code>：占8位，用来获得更好的服务，<strong>区分这个包着不着急传输</strong></p></li><li><p><code>总长度</code>：占16位，指<strong>首部和数据之和的长度</strong>，单位为字节，因此数据包的<strong>最大长度为65535字节</strong>，总长度<strong>必须不超过最大传递单元MTU</strong></p></li><li><p><code>标识</code>：占16位，它是一个计数器，用来<strong>产生数据报的标识</strong>，不是序号，每产生一个数据包，就增加1</p></li><li><p><code>标志(flag)</code>：占3位，标志字段的<strong>最低位为MF</strong>。<strong>MF&#x3D;1表示后面”还有分片”<strong>。</strong>MF&#x3D;0表示最后一个分片</strong>。标志字段<strong>中间的一位是DF</strong>，只有<strong>当DF&#x3D;0时才允许分片</strong>。</p></li><li><p><code>片偏移</code>：占13位，指出<strong>较长的分组在分片后，某片在原分组中的相对位置</strong>，片偏移<strong>以8个字节为偏移单位</strong></p></li><li><p><code>生存时间(TTL)</code>：占8位，<strong>数据包在网络中可通过的路由器数的最大值</strong>，过一个路由器，TTL减1。</p></li><li><p><code>协议</code>：占8位，<strong>指出数据包携带的数据使用何种协议</strong>以便目的主机的IP层将数据部分上交给哪个处理过程</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544405.png" alt="image"></p></li><li><p><code>首部检验和</code>：占16位，只<strong>检验数据包的首部</strong>，不检验数据部分，这里不采用CRC检验码而采用简单的计算方法</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544406.png" alt="image"></p></li><li><p><code>源地址和目标地址</code>：各占4位，就是IP地址</p></li></ul><p><strong>IP数据包首部的可变部分</strong>：</p><ul><li>是一个选项字段</li><li>用来<strong>支持排错、测量以及安全</strong>等措施</li><li>长度可变，<strong>1~40个字节不等</strong>，取决于所选择的项目</li><li>增加首部的可变部分是为了增加IP数据包的功能，也增加了每个路由器的处理开销。</li><li><strong>实际上很少被使用</strong></li></ul><h4 id="IP转发分组流程"><a href="#IP转发分组流程" class="headerlink" title="IP转发分组流程"></a>IP转发分组流程</h4><p><strong>数据路由</strong>：路由器在<strong>不同网段</strong>转发数据包</p><p><strong>网络畅通的条件</strong>：</p><ul><li><strong>能去能回</strong></li><li>沿途的路由器必须知道到目标网络下一跳给哪个接口</li><li>沿途的路由器必须知道到源网络下一跳给哪个接口</li></ul><p><strong>分组转发算法</strong>：</p><p><strong>直接交付→特定主机路由→下一跳路由器→默认路由</strong></p><ol><li>从数据包的首部提取目的主机的IP地址D，得出目的网络地址为N</li><li>若网络N与此路由直接相连，则把数据包直接交付目的主机D；否则是间接交付，执行3</li><li>若路由表中有目的地址为D的特定主机路由，则把数据包传送给路由表中所指明的下一跳路由器；&#x3D;否则，执行4</li><li>若路由表中有到达网络N的路由，则把数据包传送给路由表指明的下一跳路由器；否则，执行5</li><li>若路由表中有一个默认路由，则把数据包传送给路由表中所指明的默认路由器；否则，执行6</li><li>报告转发分组出错</li></ol><p><strong>特定主机路由</strong>：对特定的目的主机指明一个路由，方便控制网络和测试网络</p><p>**默认路由(0.0.0.0)**：下一跳路由器的地址不在IP数据包里，而在MAC帧里(转为MAC地址)</p><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a><strong>子网划分</strong></h4><p><strong>子网掩码</strong>：</p><ul><li>它是一种用来指明一个IP地址的那些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码</li><li><strong>用来区分计算机ip地址哪些是网络号，哪些是主机号</strong></li><li>将计算机<strong>IP地址和子网掩码转换成二进制</strong>，进行<strong>与计算</strong>，再转换成10进制则就**得到了这个计算机所处的网段(网络号)**。例如：一台计算机IP为172.16.122.2，子网掩码为255.255.0.0，做完与计算，得到的网段为172.16.0.0</li></ul><p><code>概念</code>：计算机的IP地址并不是固定每个段只有8位二进制，为了提高IP地址的利用率，我们可以<strong>向主机位取出部分位作为子网位</strong>，将<strong>标准的IP网络划分为几个子网</strong>，从而将“网络ID+主机ID”二层结构变成<strong>“网络ID+子网ID+主机ID”</strong>的三层结构。</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544407.png" alt="image"></p><ul><li><p><strong>要分多少个子网，就向主机位借(子网数&#x2F;2)个位，也就是每个子网是原来的多少个1&#x2F;2，每乘个1&#x2F;2，子网掩码往后移动一位。</strong>，<code>如果主机位二进制全为0和1的IP不能使用</code>。</p></li><li><p>划分后网络号不变</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544408.png" alt="image"></p></li></ul><p>以上图为例，网段192.168.0.0已经分成了两个网段，192.168.0.1 - 192.168.0.126为一个网段，192.168.0.128 - 192.168.0.254为另外一个网段，可以理解为主机号1-126在192.168.0网段，主机号128-254在192.168.1网段。<strong>如果出现192.168.201.167&#x2F;29,反斜杠后的数字代表子网掩码的二进制位数</strong></p><p><strong>点到点网络的子网划分(以C类地址为例)<strong>：点到点就只有两个IP地址，因此在划分子网时，为了避免浪费，得划分到4，也就是</strong>乘了6个1&#x2F;2</strong>，也就是<strong>划分了64个子网</strong>，则这个时候的最后一位子网掩码就为11111100(也就是10几进制的252)，因此<strong>子网掩码为255.255.255.252</strong></p><h4 id="构造超网"><a href="#构造超网" class="headerlink" title="构造超网"></a><strong>构造超网</strong></h4><p><code>概念</code>：当一个网段的主机数超过了当前网段能连接的最大主机数，需要多个网段进行连接使用，但是这个单位想要自己通信自己单位的主机，极有可能需要跨网段通信，为了避免路由转发这种效率低效的通信方法，我们<strong>使用了合并网段的操作，并将合并网段得出的子网掩码作为这几个网段的子网掩码</strong>，则可以实现通信。而<strong>合并网段的操作就是超网</strong>。</p><p><code>操作</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544409.png" alt="image"></p><ul><li><p><code>先判断合并的IP地址中的网络位的网络号是否能够合并</code></p><blockquote><p><strong>操作</strong>：需要<strong>将网络位最后一段的数字除以4得出的余数就是网络号</strong>，或者<strong>就是左移完多出的几位的主机位就是网络号</strong>。继而判断是否能够合并，也可以**判断最小的网络位最后一段是否为偶数(网络位是逐一递增的)**，如果为偶数则能够合并。</p></blockquote></li><li><p><code>合并n个网络，则子网掩码左移n/2位</code></p><blockquote><p><strong>操作</strong>：例如C类地址192.168.0.0网络跟192.168.1.0合并，子网掩码为255.255.255.0，子网掩码左移一位，得出合并后的子网掩码为255.255.254.0</p></blockquote></li></ul><h3 id="网络控制报文协议-ICMP"><a href="#网络控制报文协议-ICMP" class="headerlink" title="网络控制报文协议(ICMP)"></a>网络控制报文协议(ICMP)</h3><p><strong>概念</strong>：</p><ul><li>为了提高IP数据包交付成功的机会，在网际层使用了网际控制报文协议ICMP</li><li>ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</li><li>ICMP不是高层协议，而是IP层协议</li><li>ICMP报文作为IP层数据包的数据，加上数据报的首部，组成IP数据包发送出去</li></ul><p><strong>ICMP报文格式</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544410.png" alt="image"></p><p><strong>ICMP报文类型</strong>:</p><p>ICMP报文的前4个字节是统一的格式，共有三个字段：即<strong>类型、代码和检验和</strong>，接着的4个字节的内容与ICMP的类型有关</p><ol><li><p><code>ICMP差错报告报文</code></p><p>差错报告报文的数据字段的内容</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544411.png" alt="image"></p><blockquote><p>差错报告报文有五种：</p><ul><li><strong>终点不可达</strong>，type&#x3D;3</li><li><strong>源点抑制</strong>，放慢发送速率，type&#x3D;4</li><li><strong>时间超过</strong>，TTL&#x3D;0，type&#x3D;11</li><li><strong>参数问题</strong>，首部参数有问题，type&#x3D;12</li><li>**改变路由(重定向)**，type&#x3D;5</li></ul></blockquote></li><li><p><code>ICMP询问报告报文</code></p><blockquote><p>询问报告有两种：</p><ul><li><strong>回送请求和回答报文</strong>，测试目的站是否可达，type&#x3D;8或0</li><li><strong>时间戳请求和回答报文</strong>，时钟同步和测量时间，type&#x3D;13或i14</li></ul></blockquote></li></ol><p><strong>以下情况不发送差错报文</strong>：</p><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的<strong>所有后续数据报片</strong>都不发送ICMP差错报告报文</li><li>对<strong>具有多播地址的数据报</strong>都不发送ICMP差错报告报文</li><li>对<strong>具有特殊地址(如127.0.0.0或0.0.0.0)的数据报</strong>不发送ICMP差错报告报文</li></ol><p><strong>应用</strong>：</p><ul><li>ping —回送请求和回答报文，没有经过TCP和UDP</li><li>tracert —时间差错报文和终点不可达报文</li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p><strong>诞生原因</strong>：32位的IPv4地址空间已分配殆尽，CIDR、NAT技术也只是治标不治本，只能延缓IPv4地址消耗殆尽时间，<strong>128位的IPv6地址</strong>从根本上解决地址耗尽的问题</p><p><strong>诞生意义</strong>：</p><ol><li>解决了IPv4地址耗尽问题</li><li><strong>改进了首部格式</strong></li><li>实现了<strong>快速处理&#x2F;转发数据报</strong></li><li><strong>支持Qos</strong>(服务质量，Qos指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术)</li></ol><p><strong>IPv6地址表示形式</strong>：</p><ul><li><code>一般形式</code>：<strong>冒号十六进制记法</strong>：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</li><li><code>压缩形式</code>：<strong>将一组零压缩成一个0，将每组前三位包含0的省略</strong>，例如：4BF5:0000:0000:0000:BA5F:039A:000A:2176压缩成4BF5:0:0:0:BAF5:39A:A:2176</li><li><code>双冒号表示法(零压缩)</code>：<strong>一连串连续的0可以被一对冒号取代</strong>，但是双冒号表示法在一个地址中<strong>仅可出现一次</strong>，出现超过一次的地址是错误的。例如：FF05:0:0:0:0:0:0:B3  ——&gt;压缩成 FF05::B3</li></ul><p><strong>IPv6基本地址类型</strong>：</p><ol><li><code>单播</code>地址：<strong>一对一通信</strong>，可<strong>做源地址和目的地址</strong></li><li><code>多播</code>地址：<strong>一对多通信</strong>，可<strong>做目的地址</strong></li><li><code>任播</code>地址：<strong>一对多的一个通信</strong>，可<strong>做目的地址</strong></li></ol><p><strong>IPv6数据报格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544412.png" alt="image"></p><ul><li><strong>基本首部固定40B</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544413.png" alt="image"></p><ul><li><strong>版本</strong>：指明了协议版本，IPv6的协议版本总是6</li><li><strong>优先级</strong>：区分数据报的类别以及优先级</li><li><strong>流标签</strong>：**”流”是互联网络上从特定源点到特定终点的一系列数据报**。所有属于同一个流的数据报都具有同样的流标签</li><li><strong>有效载荷长度</strong>：也就是说明有效载荷部分的长度</li><li><strong>下一个首部</strong>：标识下一个扩展首部或上层协议首部</li><li><strong>跳数限制</strong>：相当于IPv4的TTL</li></ul><p><strong>IPv6向IPv4过渡策略</strong>：</p><ol><li><code>双栈协议</code>：双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备技能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能</li><li><code>隧道技术</code>：通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议<strong>将其它协议的数据帧或包重新封装然后通过隧道发送</strong></li></ol><p><strong>IPv6和IPv4区别</strong>：</p><ol><li>IPv6将地址从32位(4B)扩大到**128位(16B)**，更大的地址空间</li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以<strong>减少每跳的处理时间</strong></li><li>IPv6将IPv4的<strong>可选字段移出首部</strong>，<strong>变成了扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大<strong>提高了路由器的处理效率</strong></li><li>IPv6支持<strong>即插即用</strong>(即自动配置)，<strong>不需要DHCP协议</strong></li><li>IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍</li><li><strong>IPv6只能在主机处分片</strong>，IPv4可以在路由器和主机处分片</li><li>ICMPv6：附加报文类型”分组过大”</li><li>IPv6<strong>支持资源的预分配</strong>，支持实时视像等要求，<strong>保证一定的带宽和时延的应用</strong></li><li>IPv6取消了协议字段，改成下一个首部字段</li><li>IPv6取消了总长度字段，改用有效载荷长度字段</li><li>IPv6取消了服务类型字段</li></ol><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><h4 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h4><p>一个AS(自治系统)内使用 RIP、OSPF协议(都是<strong>动态路由协议</strong>)</p><h5 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a><strong>RIP协议</strong></h5><p><strong>概念</strong>：</p><ul><li>RIP是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是因特网的协议标准，<strong>最大优点是简单</strong></li><li>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong>(即一组数据)</li><li><code>距离</code>：<strong>通常为”跳数”<strong>，即</strong>从源端口到目的端口所经过的路由器个数</strong>，<strong>经过一个路由器跳数+1.<strong>从一</strong>路由器到直接连接的网络距离为1</strong>。RIP允许一条路由最多只能包含15个路由器，因此距离为16<strong>表示网络不可达</strong></li><li><code>RIP协议只适用于小互联网</code></li><li>每个路由器的路由表都由<code>周期性(30s)广播进行交流</code>，来<strong>交换路由表信息</strong>，更新每个路由器到其他路由器的最佳距离记录</li></ul><p><strong>交换操作</strong>：</p><ol><li>仅和<strong>相邻路由器</strong>交换信息</li><li>路由器交换的信息是自己的路由表</li><li>每<strong>30s交换一次路由信息</strong>，然后路由器根据新信息更新路由表。若<strong>超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表</strong></li><li>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即**”收敛”**</li></ol><p><strong>距离向量算法</strong>：</p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544414.png" alt="image"></p><ol><li><p>修改相邻路由器发来的RIP报文中所有表项</p><blockquote><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：<strong>把”下一跳”字段中的地址改为X</strong>，<strong>并把所有的”距离”+1</strong></p></blockquote></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤：</p><blockquote><ol><li>R1路由表中<strong>若没有</strong>Net3，<strong>则</strong>把该项目<strong>填入</strong>R1路由表</li><li>R1路由表中<strong>若有</strong>Net3，则<strong>查看下一跳路由器地址</strong>；若<strong>下一跳是X</strong>，则<strong>用收到的项目替换源路由表中的项目</strong>；若<strong>下一跳不是X</strong>，<strong>原来距离比从X走的距离远则更新</strong>，否则不作处理；</li><li><strong>若180s还没收到</strong>相邻路由器X的更新路由表，则<strong>把X记为不可达的路由器</strong>，即把距离设置为16</li><li>返回</li></ol></blockquote></li></ol><h5 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a><strong>OSPF协议</strong></h5><p><strong>概念</strong>：</p><ul><li>OSPF(开放最短路径优先)协议是<strong>基于最短路径优先</strong>的路由选择协议，<strong>使用了Dijkstra算法求最短路径</strong></li><li>不受某一家厂商控制</li><li><strong>使用了分布式的链路状态协议</strong></li><li>该协议也是需要通过交换路由表来进行更新路径</li><li>该协议是<strong>触发式更新</strong>，只有当路由器中的链路状态发生变化才会开始交换路由表信息。</li></ul><p><strong>交换操作</strong>：</p><ol><li><strong>使用洪泛法向自治系统内所有路由器发送信息</strong>，即路由器通过输出端口<strong>向所有相邻的路由器发送信息</strong>，而每一个**相邻路由器又再次将此消息发往其所有的相邻路由器(广播)**。最终整个区域内的路由器都得到该路由器的信息。</li><li><strong>发送</strong>的信息就是与本路由<strong>相邻的所有路由器的链路状态</strong>(<strong>本路由器和哪些路由器相邻</strong>，以及该链路的度量&#x2F;代价  –<strong>费用、距离、时延、带宽等</strong>)</li><li>只有<strong>当链路状态发生变化</strong>时，路由器才向所有路由器<strong>洪泛发送此消息</strong></li><li>最后所有路由器都能<strong>建立一个链路状态数据库</strong>，即全网拓扑图</li></ol><p><strong>链路状态路由算法</strong>：</p><ol><li>每个路由器<strong>发现它的邻居结点</strong>【HELLO问候分组】，并了解邻居节点的网络地址</li><li><strong>设置</strong>到它的每个邻居的<strong>成本度量metric</strong></li><li><strong>构造【DD数据库描述分组】</strong>，向邻站<strong>给出自己的</strong>链路状态数据库中的所<strong>有链路状态项目的摘要信息</strong></li><li>如果DD分组中的摘要自己<strong>都有</strong>，则邻站<strong>不作处理</strong>；如果有<strong>没有的或者是需要更新的</strong>，则<strong>发送【LSR链路状态请求分组】</strong>请求自己没有的和比自己更新的消息</li><li><strong>收到</strong>邻站的LSR分组<strong>后</strong>，<strong>发送【LSU链路状态更新分组】进行更新</strong></li><li><strong>更新完毕</strong>后，邻站<strong>返回一个【LSAck链路状态确认分组】进行确认</strong></li></ol><p>只要一个路由器的链路状态发生变化：</p><ol start="5"><li><strong>泛洪发送【LSU链路状态更新分组】进行更新</strong></li><li><strong>更新完毕</strong>后，其他站<strong>返回一个【LSAck链路状态确认分组】进行确认</strong></li><li><strong>使用Dijkstra算法根据自己的链路状态数据库构造到其他节点间的最短路径</strong></li></ol><p><strong>OSPF的区域</strong>：</p><ul><li>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域</li><li>每一个区域都有一个32位的区域标识符(用点分十进制表示)</li><li>区域也不能太大，在一个区域内的路由器最好不超过200个</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544415.png" alt="image"></p><p><strong>特点</strong>：</p><ul><li><code>支持多区域</code></li><li><code>触发式更新</code></li><li>路由表中有三个表(<strong>链路状态数据库</strong>)：<strong>1.邻居表(通过发送hello包来获取)，2.链路状态表，3.计算路由表</strong></li><li><code>每隔30min，要刷新一次数据库中的链路状态</code></li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。<strong>因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多</strong></li><li>OSPF不存在坏消息传得慢的问题，它的<code>收敛速度很快</code></li><li>OSPF不用UDP而是直接<code>用IP数据报传送</code></li><li>OSPF对不同的链路<strong>可根据IP分组的不同服务类型而设置成不同的代价</strong></li><li>如果到同一个目的网络有多条相同代价的路径，那么可以<strong>将通信量分配给这几条路径</strong>，这叫做<strong>多路径间的负载均衡</strong></li><li>所有在<strong>OSPF路由器之间交换的分组都具有鉴别功能</strong></li><li><code>支持可变长度的子网划分和无分类地址CIDR</code></li><li><strong>每一个链路状态都带上一个32位的序号</strong>，序号越大状态越新</li></ul><h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p><strong>概念</strong>：</p><ul><li>BGP协议<strong>是不同自治系统的路由器之间交换路由信息的协议</strong>，BGP较新版本是BGP-4</li><li>边界网关协议BGP只能<strong>力求寻找一条能够到达目的网络且比较好的路由</strong>(不能兜圈子)，而<strong>并非</strong>要寻找一条<strong>最佳路由</strong></li><li>每一个自治系统的管理员要选择<strong>至少一个路由器作为该自治系统的”BGP发言人”</strong></li><li>与其他AS的邻站BGP发言人交换信息，<strong>交换网络可达性的信息(路径向量)，即要到达某个网络所要经过的一系列AS</strong>，发生变化时更新有变化的部分</li><li>BGP是<strong>应用层协议</strong>，借助TCP传送</li></ul><p><strong>特点</strong>：</p><ul><li>BGP协议交换路由信息数量不是很多</li><li>BGP发言人数目不多，路由选择相对简单</li><li><code>BGP协议支持CIDR</code></li><li><strong>BGP刚建立时，交换整个路由表，以后只交换变化部分</strong></li></ul><p><strong>BGP协议报文格式</strong>：</p><p>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要<strong>先建立TCP连接</strong>，即通过TCP传送，然后<strong>再次连接上交换BGP报文以建立BGP会话</strong>。利用BGP会话交换路由信息</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544416.png" alt="image"></p><p><strong>BGP-4的四种报文</strong>：</p><ol><li><code>OPEN(打开)报文</code>：用来与相邻的另一个BGP发言人<strong>建立联系</strong>，并<strong>认证</strong>发送方</li><li><code>UPDATE(更新)报文</code>：<strong>通告新路径或撤销原路径</strong></li><li><code>KEEPALIVE(保活)报文</code>：在无UPDATE时，<strong>周期性证实邻站的连通性</strong>；也<strong>作为OPEN的确认</strong></li><li><code>NOTIFICATION(通知)报文</code>：<strong>报告</strong>先前报文的<strong>差错</strong>，也被<strong>用于关闭连接</strong></li></ol><h4 id="三种协议比较"><a href="#三种协议比较" class="headerlink" title="三种协议比较"></a>三种协议比较</h4><p><strong>RIP</strong>是一种分布式的基于距离向量的内部网关路由选择协议，通过<strong>广播UDP报文来交换路由信息</strong></p><p><strong>OSPF</strong>是一个内部网关协议，要<strong>交换的信息量较大</strong>，应使报文的长度尽量短，所以<strong>不适用传输层协议(如UDP或TCP)<strong>，而是</strong>直接采用IP</strong></p><p><strong>BGP</strong>是一个外部网关协议，在不同的自治系统之间交换路由信息，由于<strong>网络环境复杂</strong>，需要保证可靠传输，所以<strong>采用TCP</strong></p><p><strong>比较</strong>：</p><table><thead><tr><th align="center">协议</th><th align="center">RIP</th><th align="center">OSPF</th><th align="center">BGP</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">内部</td><td align="center">内部</td><td align="center">外部</td></tr><tr><td align="center">路由算法</td><td align="center">距离-向量</td><td align="center">链路状态</td><td align="center">路径-向量</td></tr><tr><td align="center">传递协议</td><td align="center">UDP</td><td align="center">IP</td><td align="center">TCP</td></tr><tr><td align="center">路径选择</td><td align="center">跳数最少</td><td align="center">代价最低</td><td align="center">较好，非最佳</td></tr><tr><td align="center">交换结点</td><td align="center">和本结点相邻的路由器</td><td align="center">网络中的所有路由器</td><td align="center">和本结点相邻的路由器</td></tr><tr><td align="center">交换内容</td><td align="center">当前本路由器知道的全部信息，即自己的路由表</td><td align="center">与本路由器相邻的所有路由器的链路状态</td><td align="center">首次，交换整个路由表；非首次，只交换有变化的部分</td></tr></tbody></table><h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>当网络中的某些用户需要特定数据时，多播数据发送者仅发送一次数据，借助多播路由协议为多播数据包建立多播分发树，被<strong>传递的数据到达距离用户端尽可能近的节点才开始复制和分发</strong>，是一种<strong>点对多点的传输方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544417.png" alt="image"></p><p><strong>优点</strong>：</p><ul><li>提高了数据传送效率</li><li>减少了主干网出现拥塞的可能性</li><li>多播组的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有<code>多播路由器</code>(运行多播协议的路由器)的支持)</li></ul><h4 id="IP多播地址"><a href="#IP多播地址" class="headerlink" title="IP多播地址"></a><strong>IP多播地址</strong></h4><ul><li>IP多播地址让源设备能够将分组发送给一组设备。<strong>属于多播组的设备将被分配一个多播组IP地址</strong>(一群共同需求主机的相同标识)</li><li><strong>多播地址范围为</strong>224.0.0.0~239.255.255.255(<strong>D类地址</strong>)，一个D类地址表示一个多播组。<strong>只能用作分组的目标地址，源地址总是为单播地址</strong></li><li>多播数据报也是”尽最大努力交付”，不提供可靠交付，<strong>应用于UDP</strong></li><li>对多播数据包不产生ICMP差错报文</li><li>并非所有D类地址都可以作为多播地址</li></ul><h4 id="硬件多播"><a href="#硬件多播" class="headerlink" title="硬件多播"></a><strong>硬件多播</strong></h4><ul><li>同单播地址一样，多播IP地址也<strong>需要相应的多播MAC地址</strong>在本网络中实际传送帧。<strong>多播MAC地址以十六进制值01-00-5E打头</strong>，<strong>余下的6个十六进制位是IP多播组地址的最后23位转换得到的</strong></li><li>TCP&#x2F;IP协议使用的以太网多播地址的范围是：01-00-5E-00-00-00~01-00-5E-7F-FF-FF</li><li>收到多播数据包的主机，还要<strong>在IP层利用软件进行过滤，把不是本机要接收的数据报丢弃</strong></li></ul><h4 id="IGMP协议与多播路由选择协议"><a href="#IGMP协议与多播路由选择协议" class="headerlink" title="IGMP协议与多播路由选择协议"></a>IGMP协议与多播路由选择协议</h4><h5 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a><strong>网际组管理协议IGMP</strong></h5><p><strong>概念</strong>：</p><p>​让路由器<strong>知道本局域网上是否有主机(的进程)参加或者退出了某个多播组</strong></p><p><strong>工作的两个阶段</strong>：</p><ol><li><blockquote><ul><li>某主机<strong>要加入多播组时</strong>，该主机向多播组的多播地址<strong>发送一个IGMP报文</strong>，声明自己要称为改组的成员。</li><li>本地多播路由器收到IGMP报文后，要利用多播路由选择协议把这组成员关系发给因特网上的其他多播路由器</li></ul></blockquote></li><li><blockquote><ul><li><strong>本地多播路由器周期性探询本地局域网上的主机</strong>，以便知道这些主机是否还是多播组的成员</li><li>只要<strong>一个主机对某个组响应</strong>，那么多播路由器就<strong>认为这个组时活跃的</strong>；如果经过几次探询后<strong>没有一个主机响应</strong>，多播路由器就认为本网络上的<strong>没有此组多播组的主机</strong>，因此就不再把这组的成员关系发给其他的组播路由器</li></ul></blockquote></li><li><p>注意：<strong>多播路由器知道的成员关系只是所连接的局域网中有无多播组的成员</strong></p></li></ol><h5 id="多播路由选择协议"><a href="#多播路由选择协议" class="headerlink" title="多播路由选择协议"></a><strong>多播路由选择协议</strong></h5><p><strong>概念</strong>：</p><p>多播路由协议目的是<strong>找出以源主机为根节点的多播转发树</strong></p><p><strong>特点</strong>：</p><ul><li>构造树可以<strong>避免在路由器之间兜圈子</strong></li><li>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</li></ul><p><strong>常用算法</strong>：</p><ul><li><code>基于链路状态的路由选择</code></li><li><code>基于距离-向量的路由选择</code></li><li><code>协议无关的多播(稀疏/密集)</code></li></ul><h3 id="虚拟专用网络VPN"><a href="#虚拟专用网络VPN" class="headerlink" title="虚拟专用网络VPN"></a>虚拟专用网络VPN</h3><p><strong>概念</strong>：</p><ul><li>功能：在<a href="https://baike.baidu.com/item/%E5%85%AC%E7%94%A8%E7%BD%91%E7%BB%9C/12752077?fromModule=lemma_inlink">公用网络</a>上建立<a href="https://baike.baidu.com/item/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/795899?fromModule=lemma_inlink">专用网络</a>，进行加密通讯。</li><li>VPN网关通过对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85/489739?fromModule=lemma_inlink">数据包</a>的加密和数据包目标地址的转换实现<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/3326708?fromModule=lemma_inlink">远程访问</a>。</li><li>VPN可通过<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571?fromModule=lemma_inlink">服务器</a>、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6/479446?fromModule=lemma_inlink">硬件</a>、软件等多种方式实现</li><li>VPN属于<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/3326708?fromModule=lemma_inlink">远程访问</a>技术，简单地说就是利用<a href="https://baike.baidu.com/item/%E5%85%AC%E7%94%A8%E7%BD%91%E7%BB%9C/12752077?fromModule=lemma_inlink">公用网络</a>架设<a href="https://baike.baidu.com/item/%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/795899?fromModule=lemma_inlink">专用网络</a>。例如某公司员工出差到外地，他想访问企业<a href="https://baike.baidu.com/item/%E5%86%85%E7%BD%91/427841?fromModule=lemma_inlink">内网</a>的服务器资源，这种访问就属于远程访问。</li></ul><p><strong>实质</strong>：就是<strong>在原来发送的数据包再加一个vpn网关地址的数据包头进行重新封装</strong>，这样就可以通过公网到达vpn网关，再进行<strong>去掉新的数据包头</strong>，<strong>拿取原来的数据包</strong>，进而传输到内网指定地址</p><p><strong>VPN工作过程</strong>：</p><ol><li>要保护主机发送明文信息到其他VPN设备</li><li>VPN设备根据网络管理员设置的规则，确定是<strong>对数据进行加密还是直接传输</strong></li><li>对需要机密的数据，VPN设备将其整个数据报(包括要传输的数据、源IP地址和目的IP地址)<strong>进行加密并附上数据签名</strong>，<strong>加上新的数据报头</strong>(包括目的地VPN设备需要的安全信息和一些初始化参数)<strong>重新封装</strong></li><li>将封装后的数据包通过隧道再公网上传输</li><li>数据包到达目的VPN设备后，将其<strong>解封</strong>，核对签名无误后，<strong>对数据包解密</strong></li></ol><h3 id="网络地址转换技术NAT"><a href="#网络地址转换技术NAT" class="headerlink" title="网络地址转换技术NAT"></a>网络地址转换技术NAT</h3><p><strong>概念</strong>：</p><ul><li>NAT是用于在<strong>本地网络中使用私有地址</strong>，在<strong>连接互联网时转而使用全局 IP 地址</strong>的技术。NAT实际上是为<strong>解决IPv4地址短缺而开发的技术。</strong></li><li>NAT旨在<strong>通过将一个外部 IP 地址和端口映射到更大的内部 IP 地址集来转换 IP 地址</strong></li></ul><p><strong>功能</strong>：</p><ul><li><strong>解决IP地址不足的问题</strong></li><li><strong>宽带分享</strong></li><li><strong>安全保护</strong>，有效避免网络外部的攻击，隐藏并保护网络内部的计算机</li></ul><p><strong>实现方式</strong>：</p><ol><li><code>静态转换</code>：指<strong>内部本地地址一对一转换成内部全局地址</strong>，相当内部本地的每一台PC都绑定了一个全局地址。一般用于在内网中对外提供服务的服务器。</li><li><code>动态转换</code>：指将<strong>内部网络的私有IP地址转换为公用IP地址时，IP地址是不确定的，是随机的</strong>，所有被授权访问上Internet的<strong>私有IP地址可随机转换为任何指定的合法IP地址。</strong></li><li><code>端口多路复用(PAT)</code>：指<strong>改变外出数据包的源端口并进行端口转换</strong>，即端口地址转换。<strong>内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源</strong>。网络中应用最多的就是端口多路复用方式</li></ol><p>**NAPT(网络地址端口转换PAT)**：</p><ul><li>可将<strong>多个内部地址映射为一个合法公网地址，但以不同的协议端口号与不同的内部地址相对应</strong>，也就是与之间的转换。<strong>NAPT也被称为“多对一”的NAT</strong></li><li>NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个单独的IP地址上，同时在该地址上加上一个由NAT设备选定的TCP端口号。NAPT算得上是一种较流行的NAT变体，通过转换TCP或UDP协议端口号以及地址来提供并发性。除了<strong>一对源和目的IP地址</strong>以外，这个<strong>表还包括一对源和目的协议端口号</strong>，以及<strong>NAT盒使用的一个协议端口号</strong>。</li></ul><p><strong>工作原理</strong>：</p><ol><li>借助于NAT，<strong>私有地址的内部网络通过路由器发送数据包时，私有地址会被转换成合法的IP地址</strong></li><li>NAT<strong>将自动修改IP报文的源IP地址和目的IP地址</strong>(通过NAT转换表)。</li></ol><p><strong>工作过程</strong>：</p><ol><li><strong>内网的主机向外网的主机发送数据包</strong>，数据包封装了源地址(内网主机地址)和目的地址</li><li>当数据包经过NAT路由器时，NAT路由器会根据NAT转换表将源IP地址和源端口号<strong>进行修改为NAT路由器的公网地址和端口号</strong></li><li>然后到达目的地址就能得到数据包，反之原理一样。</li></ol><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>概念</strong>：</p><ul><li><strong>只有主机(端系统)才有的层次</strong></li><li>为应用层提供通信服务，使用网络层的服务</li><li><strong>提供应用进程间的逻辑通信</strong></li></ul><p><strong>功能</strong>：</p><ol><li><p>传输层<strong>提供进程与进程之间的逻辑通信</strong>(网络层提供主机之间的逻辑通信)</p></li><li><p><strong>复用和分用</strong></p><blockquote><p><code>复用</code>：指在发送方<strong>不同的应用进程都可以使用同一个传输层协议传输数据</strong>(需要加上适当的首部)。例子：分别用微信和qq发送信息，这两条信息的报文段都可以通过同一个协议进行传输。</p><p><code>分用</code>：指接收方的<strong>传输层在剥去报文的首部后能够把这些数据正确交付目的应用进程</strong>。例子：收到报文后，进行解包，通过各报文段的首部，进行分发到对应的应用进程(也就是微信和qq)</p></blockquote></li><li><p>传输层<strong>对收到的报文进行差错检测</strong></p></li></ol><p><strong>传输层的两个协议</strong>：</p><ol><li><p><code>TCP协议</code>：<strong>面向连接的传输控制协议</strong>，提供<strong>可靠传输、流量控制、拥塞控制</strong>功能</p><blockquote><p>概述：传送数据之前<strong>必须建立连接</strong>，数据传送结束后<strong>要释放连接</strong>，<strong>不提供广播或多播服务</strong>。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：<strong>确认、流量控制、计时器及连接管理</strong>等</p><p>特点：</p><ol><li>可靠</li><li>面向连接</li><li><strong>时延大，适用于大文件</strong></li><li>开销大</li></ol></blockquote></li><li><p><code>UDP协议</code>：<strong>无连接的用户数据报协议</strong>，<strong>不可靠传输，不建立连接</strong></p><blockquote><p>概述：传送数据之前<strong>不需要建立连接</strong>，收到UDP报文后也<strong>不需要给出任何确认</strong></p><p>特点：</p><ol><li>不可靠</li><li>无连接</li><li><strong>时延小，适用于小文件</strong></li><li>开销小</li></ol></blockquote></li></ol><p><strong>端口</strong>：</p><ul><li>逻辑端口&#x2F;软件端口，是传输层的SAP(服务访问网点)，<strong>标识主机中的应用进程</strong></li><li>端口号<strong>只有本地意义</strong>，在因特网中不同计算机的相同端口是没有联系的</li><li>端口号长度为16bit，<strong>能表示65536个不同的端口号</strong></li></ul><p><strong>端口号</strong>(按范围分)：</p><ol><li><code>服务端</code>使用的端口号<ul><li>**熟知端口号(0~1023)**：给TCP&#x2F;IP最重要的一些应用程序，让所有用户都知道</li><li>**登记端口号(1024~49151)**：为没有熟知端口号的应用程序使用</li></ul></li><li><code>客户端</code>(主机)使用的端口号**(49152~65535)<strong>：仅在客户进程运行时才</strong>动态选择**</li></ol><p><strong>一些熟知端口号</strong>：</p><table><thead><tr><th align="center">应用程序</th><th align="center">FTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">TFTP</th><th align="center">HTTP</th><th align="center">SNMP</th></tr></thead><tbody><tr><td align="center"><strong>熟知端口号</strong></td><td align="center">21</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">69</td><td align="center">80</td><td align="center">161</td></tr></tbody></table><p><strong>套接字</strong>：</p><ul><li>在网络中采用发送方和接收方的套接字组合来<strong>识别端点</strong></li><li>套接字<strong>唯一标识了网络中的一个主机和它上面的一个进程</strong></li><li>套接字<code>Socket=(主机IP地址:端口号)</code></li></ul><p><strong>应用层与传输层关系</strong>：</p><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">传输层协议</th></tr></thead><tbody><tr><td align="center">名字转换</td><td align="center">DNS(域名系统)</td><td align="center">UDP</td></tr><tr><td align="center">文件传送</td><td align="center">TFTP(简单文件传送协议)</td><td align="center">UDP</td></tr><tr><td align="center">路由选择协议</td><td align="center">RIP(路由信息协议)</td><td align="center">UDP</td></tr><tr><td align="center">IP地址配置</td><td align="center">DHCP(动态主机配置协议)</td><td align="center">UDP</td></tr><tr><td align="center">网络管理</td><td align="center">SNMP(简单网络管理协议)</td><td align="center">UDP</td></tr><tr><td align="center">远程文件服务器</td><td align="center">NFS(网络文件系统)</td><td align="center">UDP</td></tr><tr><td align="center">IP电话</td><td align="center">专用协议</td><td align="center">UDP</td></tr><tr><td align="center">流式多媒体通信</td><td align="center">专用协议</td><td align="center">UDP</td></tr><tr><td align="center">多播</td><td align="center">IGMP(网际组管理协议)</td><td align="center">UDP</td></tr><tr><td align="center">电子邮件</td><td align="center">SMTP(简单邮件传送协议)</td><td align="center">TCP</td></tr><tr><td align="center">远程终端接入</td><td align="center">TELNET(远程终端协议)</td><td align="center">TCP</td></tr><tr><td align="center">万维网</td><td align="center">HTTP(超文本传送协议)</td><td align="center">TCP</td></tr><tr><td align="center">文件传送</td><td align="center">FTP(文件传送协议)</td><td align="center">TCP</td></tr></tbody></table><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p><strong>概述</strong>：UDP只在IP数据报服务之上增加了很少功能，即<strong>复用分用和差错检测功能</strong></p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h5><ol><li>UDP是<code>无连接</code>的，减少开销和发送数据之前的时延</li><li>UDP使用最大努力交付，即<code>不保证可靠交付</code></li><li>UDP<code>是面向报文</code>的，即保留这些报文的边界。<strong>一次发一个完整报文</strong>，也就是应用层给UDP多长的报文，UDP就照样发送，因此<strong>应用程序必须选择合适大小的报文</strong>。适合一次性传输少量数据的网络应用</li><li>UDP<code>无拥塞控制</code>，适合很多实时应用</li><li>UDP<code>支持一对一、一对多、多对一和多对多的交互通信</code></li><li>UDP<code>首部开销小</code>，占8B，而TCP首部占20B</li></ol><h5 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a><strong>UDP首部格式</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544418.png" alt="image"></p><ol><li><p>源端口：源端口号。在<strong>需要对方回信时选用，不需要时可用全0</strong></p></li><li><p>目的端口：目的端口号。这在终点交付报文时必须使用</p></li><li><p>长度：UDP用户数据报的长度，<strong>最小值是8(仅有首部)</strong></p></li><li><p>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃</p><blockquote><p>还有一种出错情况：</p><p>​分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP”端口不可达”差错报告报文</p></blockquote></li></ol><h5 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a><strong>UDP校验</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544419.png" alt="image"></p><ul><li><strong>伪首部只有在计算校验和时才出现，不向下传送也不向上递交</strong></li><li>17：封<strong>装UDP报文的IP数据报首部协议字段</strong>是17</li><li>UDP长度：<strong>UDP首部8B+数据部分长度(不包括伪首部)</strong></li></ul><p><strong>过程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544420.png" alt="image"></p><ul><li>在<code>发送端</code>：<ol><li>填上伪首部</li><li>全0填充校验和字段</li><li>全0填充数据部分(UDP数据报要看成许多4B的字串接起来)</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入校验和字段</li><li>去掉伪首部，发送</li></ol></li><li>在<code>接收端</code>：<ol><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报&#x2F;交给应用层附上出差错的警告</li></ol></li></ul><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ol><li><p>TCP是**面向连接(虚连接)**的传输层协议</p></li><li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是<strong>点对点的</strong></p></li><li><p>TCP提供<strong>可靠</strong>交付的服务，<strong>无差错、不丢失、不重复、按序到达</strong>。可靠有序，不丢不重</p></li><li><p>TCP提供<strong>全双工通信</strong></p><blockquote><ul><li><strong>发送缓存</strong>：准备发送的数据&amp;已发送但尚未收到确认的数据</li><li><strong>接收缓存</strong>：按序到达但尚未接受应用程序读取的数据&amp;不按序到达的数据</li></ul></blockquote></li><li><p>TCP<strong>面向字节流</strong></p><blockquote><ul><li>TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流</li><li>流：流入到进程或从进程流出的字节序列</li></ul></blockquote></li></ol><h5 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a><strong>TCP首部格式</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544421.png" alt="image"></p><ul><li><p><code>序号</code>：在一个TCP连接中传送的字节流中的<strong>每个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号</strong></p></li><li><p><code>确认号</code>：<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到</p></li><li><p><code>数据偏移(首部长度)</code>：TCP报文段的数据起始处距离TCP报文段的起始处有多远，<strong>以4B为单位</strong>，即1个数值是4B</p></li><li><p><code>6个控制位</code>：</p><blockquote><ol><li><strong>紧急位URG</strong>：<strong>URG&#x3D;1时，标明此报文段中有紧急数据</strong>，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用</li><li><strong>确认位ACK</strong>：<strong>ACK&#x3D;1时确认号有效</strong>，在<strong>连接建立后</strong>所有传送的报文段都<strong>必须把ACK置为1</strong></li><li><strong>推送位PSH</strong>：<strong>PSH&#x3D;1时，接收方尽快交付接收应用进程</strong>，不再等到缓存填满再向上交付</li><li><strong>复位RST</strong>：<strong>RST&#x3D;1时，表明TCP连接中出现严重差错</strong>，必须释放连接，然后再重新建立传输连接</li><li><strong>同步位SYN</strong>：<strong>SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文</strong></li><li><strong>终止位FIN</strong>：<strong>FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接</strong></li></ol></blockquote></li><li><p><code>窗口</code>：指的是发送本报文段的一方的接收窗口，即<strong>现在允许对方发送的数据量</strong></p></li><li><p><code>检验和</code>：检验首部+数据，检验时要加上12B伪首部，第四个字段为6</p></li><li><p><code>紧急指针</code>：<strong>URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数</strong></p></li><li><p><code>选项</code>：最大报文段长度MSS、窗口扩大、时间戳、选择确认…</p></li><li><p><code>填充</code>：如果选项字段并<strong>不是4B的整数倍，因此填充就是进行用0补充</strong>，直到选项字段变为4B的整数倍</p></li></ul><h5 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h5><p><strong>TCP连接传输三个阶段</strong>：1. 连接建立，2. 数据传送，3. 连接释放</p><p>TCP连接的建立采用<code>客户服务器方式</code>，<strong>主动发起连接建立的应用进程叫做客户</strong>，而<strong>被动等待连接建立的应用进程叫服务器</strong></p><h6 id="TCP的连接建立-三次握手"><a href="#TCP的连接建立-三次握手" class="headerlink" title="TCP的连接建立(三次握手)"></a><strong>TCP的连接建立(三次握手)</strong></h6><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544422.png" alt="image"></p><ol><li><p><strong>客户端发送连接请求</strong>报文段，<strong>无应用层数据</strong></p><p><code>SYN=1，seq(序号)=x(随机)</code></p></li><li><p><strong>服务器端</strong>为该TCP连接<strong>分配缓存和变量</strong>，并<strong>向客户端返回确认报文段</strong>，允许连接，<strong>无应用层数据</strong></p><p><code>SYN=1，ACK=1，seq=y(随机)，ack(确认号)=x+1</code></p></li><li><p><strong>客户端</strong>为该TCP连接<strong>分配缓存和变量</strong>，并<strong>向服务器端返回确认的确认</strong>，<strong>可以携带数据</strong></p><p><code>SYN=0，ACK=1，seq=x+1，ack=y+1</code></p></li></ol><p><strong>SYN洪泛攻击</strong>：</p><ul><li>该攻击<strong>利用了TCP建立连接的三次握手</strong>来对服务器端进行的攻击，可以利用<strong>设置SYN cookie来防止被SYN洪泛攻击</strong></li><li>先对服务端<strong>发送连接请求报文</strong></li><li><strong>当服务器返回ACK时，就不再对其进行确认</strong>，让该TCP连接处于挂起状态(半连接)</li><li><strong>服务器收不到确认，则会重复发送ACK报文给攻击者</strong>，因为第二次握手服务端需要分配缓存和变量，这就<strong>造成了服务器的资源浪费</strong>。</li><li>攻击者对服务器<strong>发送非常大量的这种TCP连接，服务器则可能死机。</strong></li></ul><p>​</p><h6 id="TCP连接释放-四次挥手"><a href="#TCP连接释放-四次挥手" class="headerlink" title="TCP连接释放(四次挥手)"></a><strong>TCP连接释放(四次挥手)</strong></h6><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的”资源”(缓存和变量)将被释放</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544423.png" alt="image"></p><ol><li><p><strong>客户端发送连接释放报文段</strong>，停止发送数据，主动关闭TCP连接</p><p><code>FIN=1，seq=u</code></p></li><li><p><strong>服务器端回送一个确认报文段</strong>，<strong>客户到服务器这个方向的连接就释放了</strong> –半关闭状态</p><p><code>ACK=1，seq=v，ack=u+1</code></p></li><li><p><strong>服务器端</strong>发完数据，就<strong>发出连接释放报文段</strong>，主动关闭TCP连接</p><p><code>FIN=1，ACK=1，seq=w，ack=u+1</code></p></li><li><p><strong>客户端回送一个确认报文段</strong>，再<strong>等到时间为等待计时器设置的2MSL</strong>(最长报文段寿命)后，<strong>连接彻底关闭</strong></p><p><code>ACK=1，seq=u+1，ack=w+1</code></p></li></ol><p><strong>第四次需要等待2MSL时间的原因</strong>：</p><p>因为如果<strong>客户端发送的确认报文丢失了</strong>，<strong>服务器端就会重传</strong>第三次连接释放报文，而不<strong>等待时间，客户端直接关闭的话</strong>，则<strong>服务器端将会一直收不到</strong>来自客户端的确认报文段，这样<strong>服务器端无法进入正常的关闭状态</strong>。</p><ul><li>1个MSL保证四次挥手中主动关闭方最后的ACK报文最终到达对端</li><li>1个MSL保证对端没有收到ACK那么进行重传的FIN报文能够到达</li></ul><p><strong>半关闭状态客户端能发送回应报文原因</strong>：</p><ul><li>因为我们的<strong>网络通信使用的socket套接字进行连接</strong>的，而<strong>socket套接字的内核是有两个缓冲区(一个读一个写)</strong></li><li>半关闭状态关闭的不是客户端到服务端方向的连接，而<strong>只是关闭了套接字中的write的缓冲区</strong>，因此使客户端无法发送数据</li><li>而<strong>客户端与服务端的连接还在</strong>，因此<strong>客户端依然可以接收服务端的请求，并且回应确认报文。</strong></li></ul><h5 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h5><h6 id="实现可靠传输的机制"><a href="#实现可靠传输的机制" class="headerlink" title="实现可靠传输的机制"></a><strong>实现可靠传输的机制</strong></h6><ol><li><code>校验</code>：<strong>与UDP校验一样</strong>，增加伪首部</li><li><code>序号</code>：<strong>给发送的每一个包进行编号，接收方对数据包进行排序</strong>，把有序数据传送给应用层</li><li><code>确认</code>：保证接收方是否能够正确的完整的接收报文段，<strong>TCP默认使用累计确认</strong></li><li><code>重传</code>：当报文丢失或者迟到时，并且<strong>在规定时间发送方没有收到确认就需要重传已发送的报文段</strong>。</li><li><code>流量控制</code>：利用滑动窗口算法实现，控制发送方发送速率，保证接收方能够及时接收</li><li><code>拥塞控制</code>：</li></ol><h6 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h6><p><strong>概念</strong>：</p><ul><li>自动重传请求(ARQ)是数据链路层和传输层的错误纠正协议之一</li><li>通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输</li><li>如果<strong>发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送</strong></li><li>ARQ<strong>包括停止等待ARQ协议和连续ARQ协议</strong></li></ul><p><strong>停止等待ARQ协议</strong></p><p><strong>概述</strong>：</p><ul><li><p>基本原理就是<strong>每发完一个分组就停止发送，等待对方确认(回复ACK)，如果过了(比RTT(往返时间)多一点的时间，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组</strong></p></li><li><p>在停止等待协议中，<strong>若接收方收到重复分组，就丢弃该分组，但同时还要发送确认</strong></p></li><li><p>特点：</p><blockquote><ol><li>简单</li><li><strong>信道利用率低，等待时间长</strong></li></ol></blockquote></li></ul><p><strong>无差错情况</strong>：发送方发送分组，接受方在规定时间内收到，并且回复确认。发送方再次发送</p><p>**出现差错情况(超时重传)**：</p><ul><li>停止等待协议中超时重传是指<strong>只要超过一段时间仍然没有收到确认，就重传前面发送过的分组(认为刚才发送过的分组丢失了)</strong></li><li>因此每发送完一个分组<strong>需要设置一个超时计时器</strong>，其<strong>重传时间应比数据在分组传输的平均往返时间更长一些</strong>，这种自动重传方式常<strong>称为自动重传请求ARQ</strong></li><li><strong>若收到重复分组</strong>，就<strong>丢弃该分组</strong>，但同时还要<strong>发送确认</strong></li></ul><p><strong>确认丢失和确认迟到</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544424.png" alt="image"></p><ul><li><p><code>确认丢失</code>：确认消息在传输过程丢失。例子：A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息。</p><blockquote><p>解决措施：</p><ol><li><strong>丢弃重复的消息，并不向上层交付</strong></li><li><strong>向发送方发送确认信息</strong>(不会认为已经发送过了，就不再发送。发送防能重传，就证明接收方的确认消息丢失了)</li></ol></blockquote></li><li><p><code>确认迟到</code>：确认消息在传输过程中迟到。例子：A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息(B收到了2份M1)。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息(A也收到了2份确认消息)</p><blockquote><p>解决措施：</p><ol><li><strong>发送方收到重复的确认后，直接丢弃</strong></li><li><strong>接收方收到重复的消息后，也直接丢弃重复的消息</strong></li></ol></blockquote></li></ul><p><strong>连续ARQ协议</strong></p><p><strong>概念</strong>：</p><ul><li><strong>发送方维持一个发送窗口</strong>，凡<strong>位于发送窗口内的分组可以连续发送出去</strong>，而<strong>不需要等待对方确认</strong></li><li><strong>接收方</strong>一般<strong>采用累计确认</strong>，<strong>对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了</strong></li><li><code>累计确认</code>：就是接收端并不是收到一个数据报就返回一个确认，而是<strong>接收多个后，再发一个确认</strong></li></ul><p><strong>冗余ACK</strong>：</p><p><strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。 比如：发送方发送了5条消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。<strong>发送方无法知道后三个分组的下落，而只好把后三个全部重传一次</strong>。这也叫 Go-Back-N(回退 N)，表示需要退回来重传已经发送过的 N 个消息。</p><p><strong>优点</strong>：<strong>信道利用率高，容易实现，即使确认丢失，也不必重传</strong></p><p><strong>缺点</strong>：<strong>冗余ACK</strong></p><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><p><strong>概念</strong>：</p><ul><li>指在给定的发送端和接收端之间的<strong>点对点通信量的控制</strong></li><li>TCP<strong>利用滑动窗口实现流量控制</strong>，控制发送方发送速率，保证接收方来得及接收</li><li><strong>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小</strong>，从而影响发送方的发送速率</li><li>将窗口字段设置为 0，则发送方不能发送数据</li></ul><p><strong>工作过程</strong>：</p><ol><li>发送方<strong>接收到接收方的确认报文</strong>，将<strong>发送窗口大小设置为接受方窗口大小</strong></li><li>在发送窗口的字节就可以<strong>连续传送</strong>给接收方</li><li>接收方可以进行<strong>累计确认</strong>，将接收的<strong>最后一个按序排列序号返回确认</strong></li><li>发送方就可以<strong>将接收方已经接收的字节进行丢弃</strong>，<strong>将发送窗口起始位置移动到接收了的最后一个字节的后一位</strong></li><li>然后重复以上操作，直到将字节流全部传完</li></ol><p>**选择确认(SACK)**：</p><ul><li>之前在连续ARQ协议中有讲过冗余ACK的确认来防止数据报丢失，但是其还是太浪费资源</li><li>选择确认(SACK)<strong>是确认报文中的一个报文段</strong>，在<strong>接收到失序包时</strong>，接收端就知道中间的包已经丢失，则<strong>接收端可以在返回确认时设置SACK字段告诉发送端具体是哪个包丢失了</strong>，因此<strong>发送方</strong>收到确认<strong>就可以指发送丢失的包，不用发送冗余的数据报</strong></li></ul><h6 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h6><p><strong>概念</strong>：</p><ul><li>TCP每发送一个报文段，就对这个报文段设置一次计时器，只要计时器设置的重传时间到但还没收到确认，就要重传这一报文段</li><li>而这个超时重传时间是通过一个公式动态计算出来</li><li><strong>超时重传时间应较大于上面得出的加权平均往返时间RTTs(通过公式计算出来的)</strong></li></ul><p><strong>RTTs公式</strong>：</p><blockquote><p><code>新的RTTs=(1-a)\*(旧的RTTs)+a*(新的RTT样本)</code></p><p>RFC2988推荐的<strong>a值为1&#x2F;8</strong></p></blockquote><h6 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h6><p><strong>出现资源拥塞的条件</strong>：对资源需求的总和&gt;可用资源</p><p><strong>概念</strong>：</p><ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</li><li>为了进行拥塞控制，TCP 发送方要维持一个**拥塞窗口(cwnd)**的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。</li><li>发送方让自己的<strong>发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</strong></li><li>TCP的拥塞控制采用了四种算法，即<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</li></ul><p><strong>拥塞控制实现</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544425.png" alt="image"></p><ul><li><p><strong>慢开始</strong>：</p><blockquote><ul><li>当主机开始发送数据时，先探测一下，由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。</li><li><code>cwnd初始值为1</code>，<strong>每经过一个传播轮次，cwnd加倍(乘2)。</strong></li></ul></blockquote></li><li><p><strong>拥塞避免</strong>：</p><blockquote><ul><li>并非指完全避免了拥塞，而是使网络出现拥塞的概率降低</li><li>当前<strong>拥塞窗口大小等于慢开始门限时</strong>，则就<strong>进入了拥塞避免阶段</strong></li><li>在拥塞避免阶段，拥塞窗口控制为<strong>按线性规律增长(每轮+1)</strong></li><li>当<strong>出现网络拥塞时</strong>，则将<strong>慢开始的门限(ssthresh)取一半</strong>(<code>初始慢开始门限为16</code>)</li></ul></blockquote></li><li><p><strong>快重传</strong>：</p><blockquote><ul><li>使用累计确认时，如果中间丢包了，得等接收端接收了一定的包才发来确认，这样就导致丢失的包重传的时间太慢了</li><li>快重传就是<strong>当接收包收到了失序的包，则认为没收到的包丢失了，则接收端就立即向发送端发送3次确认</strong></li><li>当发送端收到3次确认，就<strong>重传确认包里告诉的丢失包给接收端</strong>。</li><li>例子：当发送端发送了1、2、3、4，而接收端是5个就发一次确认，当接收了4但没收到3，则接收端就发送3个确认给发送端，发送端就将3重发</li></ul></blockquote></li><li><p><strong>快恢复</strong>：</p><blockquote><ul><li>当发生了快重传现象时，就认定当前网络拥塞，原先是直接重新从1继续慢开始阶段，慢开始门限变为原来的一半</li><li>而快恢复将能够快速恢复发送窗口的发送速率，也就是<strong>出现快重传后</strong>，不在从慢开始阶段开始而是<strong>直接从拥塞避免阶段开始</strong>，<strong>也就是当前拥塞窗口大小为慢开始门限(除了一半后的)。</strong></li></ul></blockquote></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ol><li>域名系统DNS</li><li>DHCP协议</li><li>FTP协议</li><li>TELNET协议</li><li>远程桌面协议RDP</li><li>HTTP协议</li><li>电子邮件协议</li></ol><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p><strong>客户&#x2F;服务器(C&#x2F;S)模型</strong></p><p><code>服务器</code>：</p><ol><li>提供计算服务的设备</li><li>永久提供服务</li><li>永久性访问地址&#x2F;域名</li></ol><p><code>客户机</code>：</p><ol><li>请求计算服务的主机</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li><strong>不与其他客户机直接通信</strong></li></ol><p><strong>P2P模型</strong>：</p><ol><li>不存在永久在线的服务器</li><li>每个主机既可以提供服务，也可以请求服务</li><li>任意端系统&#x2F;节点之间<strong>可以直接通讯</strong></li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li><li>可扩展性好</li><li>网络健壮性强</li></ol><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p><strong>域名</strong>：</p><ul><li>访问一个网站往往不是访问其IP地址，因为IP地址比较难记，因此就出现了<strong>域名来担任网站的标识名称，并且全球唯一的</strong></li><li>顶级域名：.com、.edu、.cn等等</li><li>二级域名：baidu  (baidu.com)</li><li>三级域名：例如：dea(dea.baidu.com)</li></ul><p><strong>作用</strong>：</p><ul><li>负责解析域名，将域名解析成IP</li></ul><p><strong>域名服务器</strong>：</p><ol><li>根域名服务器：知道所有顶级域名服务器的IP地址</li><li>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</li><li>权限域名服务器：负责一个区的域名服务器</li><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ol><p><strong>工作过程</strong>：</p><ol><li>主机访问网站，先<strong>向DNS服务器发送DNS查询请求</strong></li><li><strong>如果访问的网站域名后缀跟请求的DNS服务器解析的域名不同，</strong>则<strong>向根域名服务器请求</strong>让根域名服务器找寻对应的DNS服务器并把解析结果返回(例如DNS为.com的域名服务器，主机访问.cn的网站，因此.com会向根域名服务器请求)</li><li>将<strong>解析后的IP地址返回给主机</strong>，主机或域名服务器进行缓存</li><li><strong>主机访问IP地址来访问方网站</strong></li></ol><p><strong>域名解析过程</strong>：</p><ol><li><code>递归查询</code>：<strong>靠别人</strong>，也就是该DNS服务器没有该结果，就向其他DNS服务器请求，例如向根域名服务器，如果<strong>根域名服务器也没有则根域名服务器向顶级域名服务器请求</strong></li><li><code>迭代查询</code>：<strong>靠自己</strong>，如果本地域名服务器查询不到，然后本地域名服务器就向根域名服务器发送请求，如果还没有，则<strong>由本地域名服务器向其他服务器发送请求</strong>。</li><li><code>高速缓存</code>：为了提高查询效率，则添加了高速缓存，<strong>也就是查询过一次，则域名服务器将该查询结果进行缓存</strong>，这样就减少请求次数，需要定期更新(增加时间减少网络开销，减少时间提高域名转换的准确性)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544426.png" alt="image"></p><h3 id="DHCP动态主机配置"><a href="#DHCP动态主机配置" class="headerlink" title="DHCP动态主机配置"></a>DHCP动态主机配置</h3><p><strong>概念</strong>：</p><ul><li>动态主机配置协议DHCP是应用层协议，<strong>使用客户&#x2F;服务器方式</strong>，客户端和服务端<strong>通过广播方式</strong>进行交互，<strong>基于UDP</strong>。</li><li>DHCP提供<strong>即插即用</strong>联网的机制，主机可以从服务器<strong>动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址</strong></li><li><strong>支持移动用户加入网络，支持在用地址续租</strong></li></ul><p><strong>请求过程</strong>：</p><ol><li><code>主机广播发送DHCP发送报文</code>，找到网络中的DHCP服务器，服务器获得一个IP地址</li><li><code>DHCP服务器广播发送DHCP提供报文</code>，服务器拟分配给主机一个IP地址及相关配置，先到先得</li><li><code>主机广播发送DHCP请求报文</code>，主机向服务器请求提供IP地址</li><li><code>DHCP服务器广播发送DHCP确认报文</code>，正式将IP地址分配给主机</li></ol><h3 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h3><p><strong>概念</strong>：</p><ul><li>FTP协议<strong>提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力</strong></li><li>FTP是<strong>基于客户&#x2F;服务器(C&#x2F;S)<strong>的协议，</strong>基于TCP进行传输的</strong></li><li>用户通过一个客户机程序连接至远程计算机上运行的服务器程序</li><li>依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器</li><li>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</li></ul><p><strong>FTP使用两个TCP连接</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544427.png" alt="image"></p><ul><li><p><code>TCP控制连接</code>：<strong>传送文件操作命令</strong>(删除、下载、上传等)，<strong>使用服务器21端口，连接始终保持</strong></p></li><li><p><code>TCP数据连接</code>：<strong>用来传输数据的</strong>(下载、上传等)，<strong>连接保持一会</strong>，有两种模式</p><blockquote><ol><li><strong>主动模式</strong>：<strong>服务端从20端口主动向客户端发起连接</strong>。如果服务器有防火墙需要打开21和20端口</li><li><strong>被动模式</strong>：**服务端在指定范围内的某个端口被动等待客户端发起连接(端口&gt;1024)**。如果服务器有防火墙只打开21和20端口，FTP不能下载和上传数据</li></ol></blockquote></li></ul><p><strong>FTP传输模式</strong>：</p><ul><li><strong>文本模式</strong>：ASCII模式，以文本序列传输数据</li><li><strong>二进制模式</strong>：Binary模式，以二进制序列传输数据</li></ul><h3 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h3><p><strong>概念</strong>：</p><ul><li>telnet是基于TCP的远程终端协议，默认端口为23</li><li>用户用TELNET就可在其所在地通过TCP连接注册(即登录)到远地的另一台主机上(使用主机名或IP地址)</li><li>基于客户服务器方式的协议，传输的格式使用NVT</li></ul><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><strong>概念</strong>：</p><ul><li>HTTP协议定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</li></ul><p><strong>具体过程</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544428.png" alt="image"></p><ol><li><strong>浏览器分析URL</strong></li><li>浏览器<strong>向DNS请求解析IP地址</strong></li><li><strong>DNS解析出IP地址</strong></li><li>浏览器与服务器<strong>建立TCP连接</strong></li><li><strong>浏览器发出取文件命令</strong></li><li>服务器响应</li><li><strong>释放TCP连接</strong></li><li>浏览器<strong>显示</strong></li></ol><p><strong>特点</strong>：</p><ul><li>http 1.0是无状态的，http 1.1是持续连接的</li><li>HTTP采用TCP作为传输层协议，但HTTP协议本身是无连接的(通信双方在交换HTTP报文之前不需要先建立HTTP连接)</li></ul><p><strong>HTTP的连接方式</strong>：</p><ol><li><p><code>非持久连接</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544429.png" alt="image"></p></li><li><p><code>持久连接</code></p><blockquote><p>两种工作方式：</p><ul><li>非流水线方式：收到响应后再发出请求</li><li>流水线方式：连续发送，只花费RTT时间</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544430.png" alt="image"></p></li></ol><p><strong>HTTP报文结构</strong>：</p><ul><li>HTTP报文是<strong>面向文本</strong>的，因此在报文中的每一个字段都是一些ASCII码串</li></ul><ol><li><p><code>请求报文</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544431.png" alt="image"></p></li><li><p><code>响应报文</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544432.png" alt="image"></p></li></ol><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><strong>电子邮件系统组成结构</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544433.png" alt="image"></p><ul><li>用户代理就是用户与电子邮件系统的接口，是电子邮件客户端软件。</li></ul><p><strong>简单邮件传送协议SMTP</strong>：</p><ul><li>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息</li><li><strong>负责发送邮件</strong>的SMTP进程就<strong>是SMTP客户</strong>，<strong>负责接收邮件</strong>的进程<strong>就是SMTP服务器</strong></li><li>SMTP规定了14条命令(几个字母)和21种应答信息(三位数字代码+简单文字说明)</li><li>SMTP协议是<strong>基于TCP连接以及C&#x2F;S方式的协议，端口号为25</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544434.png" alt="image"></p><p><strong>SMTP缺点</strong>：</p><ol><li>SMTP不能传送可执行文件或者其他二进制对象</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</li><li>SMTP服务器会拒绝超过一定长度的邮件</li></ol><p><strong>MIME</strong>：</p><ul><li>可以将邮件传送的附件类型码放进SMTP协议数据报中</li><li>使得接收用户浏览器知道用什么插件解析</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544435.png" alt="image"></p><p><strong>邮局协议POP3</strong>：</p><ul><li>基于TCP连接和C&#x2F;S方式的协议，端口号110</li><li>用于接收邮件的协议</li><li>工作方式：1.下载并保存(在服务器)，2.下载并删除</li></ul><p><strong>网际报文存取协议IMAP</strong>：</p><ul><li>当用户PC上的IMAP客户程序<strong>打开IMAP服务器的邮箱时，用户可以看到邮箱的首部</strong>，若用户<strong>需要打开某个邮件，该邮件才上传到用户的计算机上</strong></li><li>IMAP可以让用户在不同的地方使用不同的计算机<strong>随时上网阅读处理邮件</strong>，还允许只读邮件中的某一个部分(先看正文，有wifi的时候再下载附件)</li></ul><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="网络安全问题概述"><a href="#网络安全问题概述" class="headerlink" title="网络安全问题概述"></a>网络安全问题概述</h3><p><strong>四种威胁</strong>：</p><ol><li><code>截获</code> – 从网络上窃听他人的通信内容</li><li><code>中断</code> – 有意中断他人在网络上的通信</li><li><code>篡改</code> – 故意篡改网络上传送的报文</li><li><code>伪造</code> – 伪造信息在网络上传送</li></ol><p><strong>截获信息的攻击称为被动攻击</strong>，而<strong>更改伪造信息</strong>和<strong>拒绝用户使用资源</strong>的攻击<strong>称为主动攻击</strong></p><p><strong>恶意程序</strong>：</p><ol><li><code>计算机病毒</code>：会传染其他程序的程序，例如熊猫烧香，可以对计算机内的信息和系统变量进行篡改以及删除</li><li><code>计算机蠕虫</code>：会消耗计算机资源(cpu、内存等)</li><li><code>特洛伊木马</code>：需要与外网进行连通，将从计算机获取到的数据进行传送给攻击者</li><li><code>逻辑炸弹</code>：需要满足特定条件进行触发的程序</li></ol><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h3><p><strong>对称加密</strong>：</p><ul><li><strong>加密密钥与解密密钥是同一个密钥</strong>的加密技术就是对称加密</li><li>优点：<strong>效率高</strong></li><li>缺点：<strong>密钥不适合网上传输，密钥维护麻烦</strong></li></ul><p><strong>非对称加密</strong>：</p><ul><li><strong>加密密钥和解密密钥是不同的</strong>，是一个密钥对(公钥和私钥)</li><li>公钥加密私钥解密，私钥加密公钥解密</li><li><strong>缺点：效率低</strong></li></ul><p><strong>数字签名</strong>：防止抵赖，能够检查签名之后内容是否被更改</p><p><strong>证书颁发机构作用</strong>：</p><ul><li>为企业和用户颁发数字证书</li><li>确认这些企业和个人的身份</li><li>发布证书以及吊销列表</li><li>企业和个人信任证书颁发机构</li></ul><h3 id="Internet上使用的安全协议"><a href="#Internet上使用的安全协议" class="headerlink" title="Internet上使用的安全协议"></a>Internet上使用的安全协议</h3><h4 id="运输层安全协议TLS-SSL"><a href="#运输层安全协议TLS-SSL" class="headerlink" title="运输层安全协议TLS&#x2F;SSL"></a>运输层安全协议TLS&#x2F;SSL</h4><p><strong>安全套接字SSL</strong></p><p><strong>概念</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544436.png" alt="image"></p><ul><li>在发送方，SSL接收应用层的数据(如HTTP或IMAP报文)，<strong>对数据进行加密</strong>，然后把加了密的数据送往TCP套接字</li><li>在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层</li><li><strong>网站使用SSL技术是https协议</strong>，而不是http协议，使用<code>tcp协议443端口</code></li><li><strong>SSL是TLS的前身</strong></li></ul><p><strong>功能</strong>：</p><ol><li><code>SSL服务器鉴别</code>：<strong>允许用户证实服务器的身份</strong>。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CA和它们的公钥</li><li><code>加密的SSL会话</code>：客户和服务器交互的所有<strong>数据都在发送方加密，在接收方解密</strong></li><li><code>SSL客户鉴别</code>：<strong>允许服务器证实客户的身份</strong></li></ol><p><strong>运输层安全TLS</strong></p><p><strong>概念</strong>：</p><ul><li>TLS是继SSL后的运输层安全协议</li><li>TLS采用<strong>主从式架构模型</strong>，用于在两个应用程序间透过网络创建起安全的连接，<strong>防止在交换数据时受到窃听及篡改</strong>。</li><li>TLS协议的优势是<strong>与高层的应用层协议无耦合</strong>。<strong>应用层协议能透明地运行在TLS协议之上</strong>，由TLS协议进行<strong>创建加密通道需要的协商和认证</strong>。应用层协议传送的数据<strong>在通过TLS协议时都会被加密</strong>，从而保证通信的私密性。</li><li>一旦客户端和服务器都同意使用TLS协议，他们通过使用一个握手过程协商出一个有状态的连接以传输数据。通过握手，客户端和服务器协商各种参数用于创建安全连接</li></ul><p><strong>创建安全连接过程</strong>：</p><ol><li>当客户端连接到支持TLS协议的服务器<strong>要求创建安全连接并列出了受支持的密码组合(加密密码算法和散列算法)，握手开始</strong></li><li><strong>服务器</strong>从该列表中<strong>决定加密算法和散列算法，并通知客户端</strong>；</li><li><strong>服务器发回其数字证书</strong>，此证书通常包含服务器的名称、受信任的证书颁发机构(CA)和服务器的公钥；</li><li><strong>客户端验证</strong>其收到的服务器<strong>证书的有效性</strong>；</li><li>为了生成会话密钥用于安全连接，<strong>客户端使用服务器的公钥加密随机生成的密钥</strong>，并将其发送到服务器，<strong>只有服务器才能使用自己的私钥解密</strong>；</li><li><strong>利用随机数，双方生成用于加密和解密的对称密钥</strong>。这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接(被)关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。</li></ol><h4 id="网络层安全协议IPsec"><a href="#网络层安全协议IPsec" class="headerlink" title="网络层安全协议IPsec"></a>网络层安全协议IPsec</h4><p><strong>概念</strong>：</p><ul><li><strong>IPsec数据报称为IP安全数据报</strong></li></ul><p><strong>IPsec对等端</strong>：</p><ol><li>两个端系统</li><li>两个路由器&#x2F;防火墙</li><li>一个路由器&#x2F;防火墙与一个端系统</li></ol><p><strong>组成</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544437.png" alt="image"></p><ol><li><p>IP安全数据报格式的两个协议：</p><blockquote><ul><li><strong>鉴别首部AH协议</strong></li><li><strong>封装安全有效载荷ESP协议</strong></li></ul></blockquote></li><li><p>有关加密算法的三个协议</p></li><li><p><strong>互联网密钥交换IKE协议</strong></p></li></ol><p><strong>传输模式</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544438.png" alt="image"></p><ul><li>IPsec数据报的发送与接收均由端系统完成，<strong>主机是IPsec感知</strong>的</li></ul><p><strong>隧道模式</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544439.png" alt="image"></p><ul><li><strong>边缘路由器是IPsec感知</strong>的</li></ul><p><strong>服务</strong>：</p><ul><li>机密性</li><li>数据完整性</li><li>源认证&#x2F;鉴别</li><li>重放攻击预防</li></ul><p><strong>安全关联SA</strong>：</p><ul><li>SA是构成IPsec的基础，<strong>是两个通信实体经协商(利用IKE协议)建立起来的一种协定</strong></li><li>它决定了用来<strong>保护数据分组安全的安全协议(AH协议或者ESP协议)、转码方式、密钥与密钥的有效存在时间等</strong></li><li>发送IP安全数据报(或者使用AH或者ESP)之前，<strong>从发送实体到接收实体之间需要建立安全关联SA</strong></li><li>SA是单工的：<strong>单向</strong></li><li>发送实体与接收实体均需维护SA的状态，<strong>IPsec是面向连接的</strong></li></ul><p><code>主要参数</code>;</p><ul><li>**安全参数索引(SPI)**：32位SA唯一标识</li><li><strong>加密密钥、认证密钥</strong></li><li><strong>密码算法标识</strong></li><li>**序列号(32位)**，用来抗重放攻击</li><li><strong>抗重播窗口</strong>，接收方使用滑动窗口检测恶意主机重放数据报</li><li><strong>生存周期</strong>，规定SA的有效使用周期</li><li><strong>运行模式</strong>：传输模式或隧道模式</li><li><strong>IPsec隧道源、目的地址</strong>(如果是隧道模式)</li></ul><p><strong>安全关联数据库SAD</strong>：</p><ul><li>IPsec端点<strong>将SA状态保存在安全关联数据库SAD</strong>中</li><li>在处理IPsec数据包时，定位这些信息</li><li>对于n个销售人员，1个分支机构的VPN，总部路由器R1的SAD中存储2+2n条SAs</li><li>当发送IPsec数据包时，R1访问SAD，确定如何处理数据报</li><li>当IPsec数据报到达R2，R2检验IPsec数据报中的SPI，利用SPI检索SAD，处理数据报</li></ul><p><strong>安全策略数据库SPD</strong>：</p><ul><li><p><strong>安全策略SP</strong>：定义了对什么样的数据流实施什么样的安全处理</p></li><li><p>策略一般<strong>分三种：应用IPsec、绕过、丢弃</strong></p></li><li><p>安全策略组成了SPD，每个记录就是一条SP</p><blockquote><ul><li>提取关键信息填充到一个称为“选择符”的结构，包括目标IP、源IP、传输层协议、源和目标端口等</li><li>利用选择符去搜索SPD，检索匹配的SP</li></ul></blockquote></li><li><p><strong>安全处理需要的参数存储在SP指向的SA结构</strong></p></li></ul><p><strong>密钥交换协议IKE</strong>：</p><ul><li><p>IKE协议<strong>可自动管理SA的建立、协商、修改和删除，是IPsec唯一的密钥管理协议</strong></p></li><li><p>IKE：</p><blockquote><ul><li>ISAKMP的通用框架：定义了协商、建立、修改和删除SA过程的通用框架</li><li>OAKLEY的密钥交换模式：一个密钥交换协议，允许认证过的双方通过不安全的网络交换密钥参数</li><li>SKEME的共享和密钥更新技术：提供IKE交换密钥的算法</li></ul></blockquote></li></ul><p><strong>提供不同服务模型的两个协议</strong>：</p><ul><li><strong>AH协议</strong>：认证头协议，在IP数据报文头中的<strong>协议号为51</strong></li><li><strong>ESP协议</strong>：封装安全协议，在IP数据报文头中的<strong>协议号为50</strong></li></ul><p><strong>认证头协议AH协议</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544440.png" alt="image"></p><ul><li><strong>提供源认证&#x2F;鉴别和数据完整性检验</strong>，但<strong>不提供机密性</strong></li><li>在传输过程，中间的路由器都不查看AH首部，当数据报到达终点时，目的主机才处理AH字段，以鉴鉴别源点和检查数据报的完整性</li></ul><p><strong>封装安全协议ESP</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544441.png" alt="image"></p><ul><li><strong>提供源认证&#x2F;鉴别、数据完整性检验以及机密性</strong></li><li>比AH应用更广泛</li><li>当IP首部检查到协议字段是50时，就知道在<strong>IP首部后面紧接着是ESP首部</strong>，同时在原IP数据报后面<strong>增加ESP尾部和ESP数据字段</strong></li></ul><h4 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙(firewall)"></a><strong>防火墙(firewall)</strong></h4><p><strong>概念</strong>：</p><ul><li>防火墙是由软件、硬件构成的系统，是一种特殊编程的路由器，<strong>用来在两个网络之间实施接入控制策略。</strong></li><li><strong>接入控制策略是由使用防火墙的单位自行制订的</strong>，为的是可以最适合本单位的需要</li><li>防火墙内的网络称为”可信赖的网络”，而将外部的因特网称为”不可信赖的网络”</li><li><strong>防火墙可用来解决内联网和外联网的安全问题</strong></li></ul><p><strong>两类防火墙技术</strong>：</p><ol><li><code>网络防火墙</code>：用来<strong>防止整个网络出现外来非法的入侵</strong>。属于这类的<strong>有分组过滤和授权服务器</strong>。前者检查所有流入本网络的信息，然后拒绝不符合事先制定好的一套准则的数据，而后者则是检查用户的登录是否合法</li><li><code>应用级防火墙</code>：从<strong>应用程序来接入控制</strong>。通常<strong>使用应用网关或代理服务器来区分各种应用</strong>。例如：可以只允许通过访问万维网的应用，而阻止FTP应用通过</li></ol><p><strong>防火墙网络拓扑</strong>：</p><ul><li><p><code>三向外围网</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544442.png" alt="image"></p></li><li><p><code>背靠背防火墙</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544443.png" alt="image"></p></li><li><p><code>单一网卡防火墙</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544444.png" alt="image"></p></li><li><p><code>边缘防火墙</code></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405191544445.png" alt="image"></p></li></ul><h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><p><strong>概念</strong>：</p><p>- </p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后台开发</tag>
      
      <tag>计算机网络</tag>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github博客搭建</title>
    <link href="/2024/05/19/hexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/05/19/hexo-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>个人之前用的是django加阿里云服务器搭建的<a href="https://codebooks.xyz/">个人博客</a>，但是我发现这样的博客还是太麻烦了，费钱又费力(毕竟在使用的过程中也需要更新迭代)，所以有了hexo+github的这种简单省事的搭建博客。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><strong>node.js</strong></li><li><strong>git</strong></li></ol><p>这两个应用windows用户直接搜索下载安装就可以。 如果习惯了使用linux命令的朋友，推荐windows神器<code>cmder</code>。 可以直接在windows环境下使用linux命令，样式可调，再也不要用黑乎乎的cmd了，而且自带git，完全可以不用下载windows git。</p><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p><a href="https://hexo.io/zh-cn/docs/">hexo官方中文文档</a></p><p>在node.js安装好的前提下，全局安装hexo 如何判断node.js是否安装成功？执行以下命令，如果能够看到版本号则说明安装成功了</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br></code></pre></td></tr></table></figure><p>安装<code>hexo</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>自选合适的目录，新建文件夹<folder></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> <span class="hljs-symbol">&lt;folder&gt;</span><br>hexo init<br>npm install<br></code></pre></td></tr></table></figure><p>不再赘述，直接看官方文档。</p><h3 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h3><p>新建仓库，仓库名必须为**[your_name.github.io]**</p><blockquote><p>补充：本地配置github ssh连接，方便自动部署，以及clone你喜欢的主题(theme)</p></blockquote><p>windows用户直接在<code>c:/用户/youername/.ssh/</code>下查看是否有<code>id_rsa.pub</code>文件。 没有的话命令行执行命令<code>ssh-keygen -t rsa -C &quot;your eamil&quot;</code>，会自动生成<code>id_rsa.pub</code>文件，打开后复制。</p><p>github-&gt;头像-&gt;Settings→SSH kyes→Add SSH key，粘贴复制的内容。</p><p>配置本地账户</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name “your_username” <span class="hljs-meta">#设置用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email “your_email” <span class="hljs-meta">#设置邮箱地址,最好使用注册邮箱地址</span><br></code></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h3 id="hexo配置以及使用"><a href="#hexo配置以及使用" class="headerlink" title="hexo配置以及使用"></a>hexo配置以及使用</h3><p>有两个配置文件：</p><ul><li>一个是根目录下的<code>_config.yml</code>称为<code>站点配置</code>文件</li><li>一个是<code>themes/landscape/_config.yml</code>称为<code>主题配置</code>文件(默认主题：landscape)</li></ul><p>站点配置如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">url:</span> https:<span class="hljs-comment">//yourname.github.io/</span><br><span class="hljs-symbol">theme:</span> landscape <span class="hljs-meta">#选择你想用的主题，我用的是indigo</span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">    type:</span> git <span class="hljs-meta"># 不要使用github</span><br><span class="hljs-symbol">    repo:</span> git@github.com:pengwenwu/pengwenwu.github.io.git <span class="hljs-meta"># 使用ssh连接</span><br><span class="hljs-symbol">    branch:</span> master <span class="hljs-meta"># 默认master分支</span><br><span class="hljs-symbol">    message:</span> add new blog <span class="hljs-meta"># 自动部署commit备注，可不填</span><br></code></pre></td></tr></table></figure><h4 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h4><p><a href="https://segmentfault.com/a/1190000002632530">hexo命令参考</a></p><p><code>hexo n &quot;我的博客&quot;</code> &#x3D;&#x3D; <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> &#x3D;&#x3D; <code>hexo publish</code><br><code>hexo g</code> &#x3D;&#x3D; <code>hexo generate</code> #生成<br><code>hexo s</code> &#x3D;&#x3D; <code>hexo server</code> #启动服务本地预览<br><code>hexo d</code> &#x3D;&#x3D; <code>hexo deploy</code> #部署<br><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令</p><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p>在执行之前，记得安装自动部署 (–save 加不加的区别在于是否写入到依赖文件package.json中)</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>正常本地预览，直接执行<code>hexo s</code>,如果要发布话最好执行<code>clean</code>命令，会去删除生成的public文件，完整部署命令:<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。或者直接<code>hexo d -g</code></p><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>安装完自动部署后，是不需要本地git init新建仓库的。执行<code>hexo g</code>会在根目录生成public文件夹，自动部署， 本质是将public文件夹内容全部提交到仓库中去，默认会访问编译好的index.html。</p><p>如果部署完，访问your_name.github.io 404,可能有下面几个原因</p><ol><li>首先检查仓库文件，是不是全都是public的文件内容，如果整个本地blog文件夹都提交了，首先清空 仓库，然后删除本地<code>.deploy_git</code>文件夹，再重新部署</li><li>文件有报错，本地<code>hexo s</code>观察是否有报错。</li></ol><p>不喜欢原主题的朋友，可以github去找喜欢的主题。执行命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">XXXX</span>.next.git themes\next<br></code></pre></td></tr></table></figure><p>这个会将新的主题下载到themes下对应的next目录，next为主题的名字。</p><p>主题的配置，可以看文档，修改对应的<code>主题配置</code>文件。<br>我使用的主题是<code>indigo</code>,详细文档<a href="https://github.com/yscoder/hexo-theme-indigo">indigo</a></p><p><code>markdown</code>不会使用的朋友，参考链接<a href="https://www.appinn.com/markdown/">markdown中文文档</a><br>如果没有ide的话，可以使用在线预览<a href="https://www.zybuluo.com/mdeditor">Cmd Markdown</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile基本使用</title>
    <link href="/2024/05/19/Makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/19/Makefile%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile基本使用"><a href="#Makefile基本使用" class="headerlink" title="Makefile基本使用"></a>Makefile基本使用</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>项目代码编译管理</li><li>节省编译项目时间</li><li>一次编写终身受益</li></ul><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p><strong>基本原则</strong>：</p><ol><li>若想生成目标，检查规则中的依赖条件是否存在，如不存在，则寻找是否有规则用来生成依赖文件</li><li>检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任一被更新，则目标必须更新</li></ol><p><strong>规则</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标:依赖条件</span><br>(注意需要tab缩进)命令<br></code></pre></td></tr></table></figure><ul><li><code>ALL变量</code>：<strong>用于指定makefile的最终目标</strong></li></ul><p>示例:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">ALL:test   --&gt;用于指定终极目标，当最终目标不在第一组规则的时候使用</span><br><span class="hljs-section">test:test.cpp wrap.cpp</span><br>g++ test.cpp wrap.cpp -o test<br><br><span class="hljs-comment">#在当前工作目录输入make编译会生成test目标</span><br></code></pre></td></tr></table></figure><h2 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a>Makefile变量</h2><p><strong>自动变量</strong>:</p><ul><li><code>$@</code>：<strong>表示规则中的目标</strong></li><li><code>$&lt;</code>：<strong>表示规则中的第一个依赖条件，在模式规则中，它可以将依赖条件列表中的所有依赖依次取出，套用模式规则</strong></li><li><code>$^</code>：<strong>表示规则中的所有依赖条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项</strong></li></ul><blockquote><p>注：自动变量是使用于规则的命令中</p></blockquote><h2 id="Makefile函数"><a href="#Makefile函数" class="headerlink" title="Makefile函数"></a>Makefile函数</h2><p><strong>函数</strong>：</p><ul><li><code>src=$(wildcard *.cpp)</code>：<strong>找到当前目录下所有后缀为.cpp的文件，赋值给src</strong>，wildcard为函数名，$()是函数调用方式，*.cpp是参数</li><li><code>obj=$(patsubst %.cpp,%.o,$(src))</code>：<strong>把src变量里所有后缀为.cpp的文件替换成.o</strong>，patsubst为函数名，$()是函数调用方式，%.cpp为替换前的文件后缀，%.o为替换后的文件后缀</li></ul><h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p><strong>模式规则</strong>：</p><ul><li>使用模式匹配来自动化帮我们实现手写规则</li><li>例如：我要将.cpp文件生成.o文件就可以写成这样：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.o:%.cpp</span><br>g++ -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><strong>静态模式规则</strong>：<strong>就是指定模式规则给谁用</strong></p><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(obj)</span>:%.o:%.cpp<br>g++ -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><span class="hljs-comment">#这个就是将%.o:%.cpp这个规则给$(obj)使用</span><br></code></pre></td></tr></table></figure><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p><strong>使用</strong>：</p><ul><li><strong>可以在makefile中定义clean来清理编译后不需要的文件</strong></li><li>在终端使用<code>make clean</code>命令执行</li></ul><p><strong>规则</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>命令<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>-rm -rf *.o<br><span class="hljs-comment">#删除当前目录下的所有.o后缀文件</span><br></code></pre></td></tr></table></figure><blockquote><p>注：<strong>rm前的-表示忽略出错执行，也就是当删除一个文件出错时，会忽略这个错误继续执行后面的操作</strong></p></blockquote><p><strong>生成伪目标</strong>：</p><ul><li><code>伪目标</code>：<strong>不管条件满足与否，目标都要被执行</strong></li><li>当我们有一个名字为clean文件或者ALL的文件，这样会导致make出错，因此我们需要生成伪目标</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean ALL</span><br></code></pre></td></tr></table></figure><h2 id="最终模板"><a href="#最终模板" class="headerlink" title="最终模板"></a>最终模板</h2><p><strong>模板1</strong>：用于指定文件执行，比方单个文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cxx=g++<br>target=test  <span class="hljs-comment">#命名自己定义</span><br>obj=test.o wrap.o<br><br>arg=-c -Wall<br><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br><span class="hljs-variable">$(cxx)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">%.o:%.cpp</span><br><span class="hljs-variable">$(cxx)</span> <span class="hljs-variable">$(arg)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean ALL</span><br><span class="hljs-section">clean:</span><br>-rm -rf <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure><p><strong>模板2</strong>：适用于项目</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cxx=g++<br>target=test<br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.cpp)</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp,%.o,<span class="hljs-variable">$(src)</span>)</span><br><br>arg=-c -Wall<br><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br><span class="hljs-variable">$(cxx)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">%.o:%.cpp</span><br><span class="hljs-variable">$(cxx)</span> <span class="hljs-variable">$(arg)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean ALL</span><br><span class="hljs-section">clean:</span><br>-rm -rf <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目管理</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习</title>
    <link href="/2024/05/19/C-%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/19/C-%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-学习"><a href="#C-学习" class="headerlink" title="C++ 学习"></a>C++ 学习</h1><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009275.jpg" alt="image"></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>通常头文件我们都选择使用<iostream>,虽然&lt;bits&#x2F;stdc++.h&gt;包含c++所有的头文件，但是会产生很多我们不使用的头文件，导致编译时间增长。个人认为输入输出还是使用c的函数为好(c的输入输出更快)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  <span class="hljs-comment">//为输入输出流的头文件(c++)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  <span class="hljs-comment">//该头文件包含c++中所有的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  <span class="hljs-comment">//在c语言头文件的基础上加上c，去掉.h尾缀</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">//使用定义的名字空间，指定缺省的命名空间，如果没有该声明，后面的输入输出前都需加入std::</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<span class="hljs-comment">//cin为c++的输入函数</span><br>    cout&lt;&lt;n&lt;&lt;endl; <span class="hljs-comment">//cout为c++的输出函数，而endl就是换行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>变量的定义</strong></p><p>相比c语言，c++多了string字符串类型的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">string name;<br></code></pre></td></tr></table></figure><p><strong>宏常量</strong></p><p>一般在main函数的上面声明，用大写命名.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 常量名 值</span><br></code></pre></td></tr></table></figure><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>c++规定给标识符(变量、常量、函数、结构体、类等)命名时，必须遵守以下规则。</p><ul><li>在名称中只能使用字母字符、数字和下划线</li><li>名称的第一个字符不能是数字</li><li>区分大写字符与小写字符</li><li>不能将C++关键词用作名称</li><li>以下划线和大写字母打头的名称被保留给编译器机器使用的资源使用，如果违反了这一规则，会导致行为的不确定性</li><li>C++对名称的长度没有限制，但有些平台可能有长度限制</li></ul><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>注意：</p><ul><li>整数进行除法运算时，如果分母为0，程序将异常退出</li><li>浮点数进行除法运算时，如果分母为0.0，将得到inf(nfinite，无穷大)</li><li>两个整数进行除法运算时，将舍去小数部分，得到一个整数</li><li>整数与浮点数进行除法运算时，得到的结果是浮点数</li><li>在整数前面加(float)或(double)可以将整数转换为float或double类型</li><li>取模运算只能用于整数(分母也不能为0)</li></ul><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>注意</p><ul><li>字符串(string)只能使用等号赋值，不能使用其他的赋值运算符</li><li>浮点数不能使用%&#x3D;运算符</li></ul><h3 id="C-初始化"><a href="#C-初始化" class="headerlink" title="C++初始化"></a>C++初始化</h3><ol><li><p>把值写在小括号中，等于号可以省略(C++标准）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=(<span class="hljs-number">15</span>);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span><br></code></pre></td></tr></table></figure></li><li><p>把值写在花括号中，等于号也可以省略(C++11标准)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=&#123;<span class="hljs-number">15</span>&#125;;<br><span class="hljs-type">int</span> b&#123;<span class="hljs-number">20</span>&#125;;<br></code></pre></td></tr></table></figure><p>注意：在Linux平台下，编译需要加-std&#x3D;c++11 参数。</p></li></ol><h3 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h3><p><strong>功能</strong>:</p><ul><li>强制转换类型</li></ul><p><strong>C++类型转换符</strong>：</p><ul><li><code>static_cast</code></li><li><code>dynamic_cast</code></li><li><code>reinterpret_cast</code></li><li><code>const_cast</code></li><li><strong>使用方式</strong>：<code>xx_cast&lt;type&gt;(expression)</code></li></ul><p>C语言的风格：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(type)expression;<br></code></pre></td></tr></table></figure><p>C++语言风格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xx_cast</span>&lt;type&gt;(expression);<br></code></pre></td></tr></table></figure><p><strong>const_cast转换符</strong></p><ul><li><p><strong>功能</strong>：一般用于去除const属性，<strong>将const类型转换成非const</strong></p></li><li><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Person *p1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>Person *p2=<span class="hljs-built_in">const_cast</span>&lt;Person *&gt;(p1);<br></code></pre></td></tr></table></figure></li></ul><h2 id="读写优化"><a href="#读写优化" class="headerlink" title="读写优化"></a>读写优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>用于解决名字冲突</p><p>使用关键字namespace，控制名称的作用域</p><p>命名空间的<strong>本质</strong>：对符号常量、变量、函数、结构、枚举、类和对象等等进行封装</p><p>命名空间<strong>语法</strong>：<code>namespace A&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-type">int</span> data=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">namespace</span> C&#123;<br>        <span class="hljs-type">int</span> data=<span class="hljs-number">30</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> B&#123;<br>    <span class="hljs-type">int</span> data=<span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> D&#123;<br>    <span class="hljs-type">int</span> data=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">//1000行代码</span><br><span class="hljs-keyword">namespace</span> D&#123;  <span class="hljs-comment">//如果存在就追加，不存在就新建</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;func函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">using</span> A::a;<span class="hljs-comment">//下方如果出现a，就拿A中的a使用</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl; <br>    cout&lt;&lt;<span class="hljs-string">&quot;A::data= &quot;</span>&lt;&lt;A::data&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;A::B::data= &quot;</span>&lt;&lt;A::B::data&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>命名空间只能定义在全局中</li><li>命名空间可以嵌套</li><li>命名空间是开放的，可以随时将新的成员加入命名空间</li><li>命名空间可以声明和实现分离(外部实现时要加作用域)</li><li>无名空间(<code>namespace&#123;&#125;</code>)只能在本源文件使用，里面的成员相当于静态全局成员一样</li><li>命名空间起别名(<code>namespace 别名=要取别名的空间名</code>)</li><li>使用using声明命名空间中的某几个成员可用，容易造成名字冲突(会合普通变量名字冲突)</li><li>using使用命名空间中的函数重载过的函数，函数重载，命名空间的所有同名函数都被声明</li></ul><p><strong>using编译指令</strong>：</p><p><em>using声明整个命名空间，可以直接通过成员名使用</em></p><p>语法：<code>using namespace 空间名</code></p><p><strong>注意事项</strong>：如果外部有定义空间中的变量，调用时则会先找普通变量，再找命名空间的，全局范围的变量会与局部的命名空间的变量产生冲突</p><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序运行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li></ul><p><strong>内存四区意义</strong>：</p><p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>在程序编译后，生成了exe可执行程序，为执行该程序前分为两个区域</p><p><strong>代码区</strong>：</p><p>​存放cpu执行的机器指令</p><p>​代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p><p><strong>全局区</strong>：</p><p>​全局变量和静态变量存放在此</p><p>​全局区还包含了常量区，字符串常量和其他常量也存放在此</p><p>​<em>该区域的数据在程序结束后由操作系统释放</em></p><p><strong>总结</strong>：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区存放全局变量、静态变量、常量</li><li>常量区中存放const修饰的全局常量和字符串常量</li></ul><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p><strong>栈区</strong>：</p><p>​由编译器自动分配释放，存放函数的参数值，局部变量等</p><p>​注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>堆区</strong>：</p><p>​由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><p>​在C++中主要利用new在堆区开辟内存</p><p>​</p><p><strong>总结</strong>：</p><p>​堆区数据由程序员管理开辟和释放</p><p>​堆区数据利用new关键字进行开辟内存</p><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>​C++中利用<strong>new</strong>操作符在堆区开辟数据</p><p>​堆区开辟的数据，由程序员手动开辟，手动释放，释放利用<strong>delete</strong></p><p>​语法：<em>new 数据类型</em></p><p>​利用new创建的数据，会返回该数据对应的类型的指针</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//new的基本语法</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//在堆区创建整型数据</span><br>    <span class="hljs-comment">//new返回是该数据类型的指针</span><br>    <span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-built_in">func</span>();<br>    cout&lt;&lt;*p&lt;&lt;endl;<br>    cout&lt;&lt;*p&lt;&lt;endl;<br>    cout&lt;&lt;*p&lt;&lt;endl;<br>    <span class="hljs-comment">//堆区的数据是由程序员管理开辟和释放</span><br>    <span class="hljs-comment">//如果想释放用关键字delete</span><br>    <span class="hljs-keyword">delete</span> p;<br>    cout&lt;&lt;*p&lt;&lt;endl; <span class="hljs-comment">//内存已经被释放，再次访问就是非法操作</span><br>&#125;<br><br><span class="hljs-comment">//在堆区利用new开辟数组f</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建10整型数据的数组，在堆区</span><br>    <span class="hljs-type">int</span> *arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//10代表数组有10个元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        arr[i]=i+<span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        cout&lt;&lt;arr[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//释放堆区数组</span><br>    <span class="hljs-comment">//释放数组的时候，要加入[]</span><br>    <span class="hljs-keyword">delete</span>[] arr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><p>作用：给变量起别名</p><p>语法：<em>数据类型 &amp;别名 &#x3D; 原名</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b=a;<br>    cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul><li>引用必须要初始化</li><li>引用在初始化后，不可以改变</li></ul><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p><strong>作用</strong>：函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点</strong>：可以简化指针修改实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">myswap</span>(a,b);  <span class="hljs-comment">//引用传递，形参会修饰实参的</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a= &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b= &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：通过引用参数产生的效果同地址传递是一样的，引用的语法更清楚更简单</p><h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><p><strong>作用</strong>：引用是可以作为函数的返回值存在的</p><p><strong>注意</strong>：<em>不要返回局部变量引用</em></p><p><strong>用法</strong>：函数调用作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//不要返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<span class="hljs-comment">//局部变量存放在栈区</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-comment">//函数的调用可以作为左值</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>; <span class="hljs-comment">//静态变量，存放在全局区，全局区上的数据在程序结束后系统释放</span><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> &amp;ref=<span class="hljs-built_in">test01</span>(); <span class="hljs-comment">//非法操作</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;ref= &quot;</span>&lt;&lt;ref&lt;&lt;endl;<span class="hljs-comment">//第一次结果正确是编译器做了保留</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;ref= &quot;</span>&lt;&lt;ref&lt;&lt;endl;<span class="hljs-comment">//第二次结果错误是因为a的内存已经释放</span><br>    <span class="hljs-type">int</span> &amp;ref2=<span class="hljs-built_in">test02</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;ref2= &quot;</span>&lt;&lt;ref2&lt;&lt;endl;<span class="hljs-comment">//输出10</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;ref2= &quot;</span>&lt;&lt;ref2&lt;&lt;endl;<br>    <span class="hljs-built_in">test02</span>()=<span class="hljs-number">1000</span>; <span class="hljs-comment">//如果函数的返回值是引用，这个函数的调用可以作为左值</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;ref2= &quot;</span>&lt;&lt;ref2&lt;&lt;endl;<span class="hljs-comment">//输出1000</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;ref2= &quot;</span>&lt;&lt;ref2&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p><strong>本质</strong>：<em>引用的本质在C++内部实现是一个指针常量</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//发现是引用，转换为int* const ref=&amp;a;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ref)</span></span>&#123;<br>    ref=<span class="hljs-number">100</span>;<span class="hljs-comment">//ref是引用，转换为*ref=100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//自动转换为int* const ref=&amp;a;指针常量是指针指向不可改，也说明为什么引用不可更改</span><br>    <span class="hljs-type">int</span>&amp; ref=a;<br>    ref=<span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为：*ref=20;</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;ref:&quot;</span>&lt;&lt;ref&lt;&lt;endl;<br>    <span class="hljs-built_in">func</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：C++推荐使用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p><strong>作用</strong>：常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//打印数据函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;val)</span></span>&#123;<br>    <span class="hljs-comment">//val=1000;   如果没加上const，外面的a也会更改</span><br>    <span class="hljs-comment">//加上了const，上段代码就会报错</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;val= &quot;</span>&lt;&lt;val&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//常量引用</span><br>    <span class="hljs-type">int</span> &amp;ref=<span class="hljs-number">10</span>;<span class="hljs-comment">//错误，引用必须引一块合法的内存空间</span><br>    <span class="hljs-comment">//加上const之后，编译器将代码修改为 int temp=10; const int &amp;ref=temp;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref=<span class="hljs-number">10</span>;<span class="hljs-comment">//正确</span><br>    <span class="hljs-comment">//使用场景：用来修饰形参，防止误操作</span><br>    <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">showValue</span>(a);<br>    cout&lt;&lt;<span class="hljs-string">&quot;a= &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p><strong>语法</strong>：<em>返回值类型 函数名 (参数 &#x3D; 默认值){}</em></p><p><strong>注意事项</strong>：</p><ul><li>如果某个位置已经有了默认参数，那么从这个位置往后，从左向右的形参都必须要有默认参数</li><li>如果函数声明有默认参数，函数实现就不能有默认参数</li><li>声明和实现只能有一个有默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//函数默认参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">20</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">30</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>)&lt;&lt;endl;<span class="hljs-comment">//有默认值可以只传没有默认值的形参</span><br>    cout&lt;&lt;<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>)&lt;&lt;endl;<span class="hljs-comment">//如果自己传入数据，就用自己的数据</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法</strong>：<em>返回值类型 函数名(数据类型){}</em></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;this is func&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//占位参数还可以默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> =<span class="hljs-number">10</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;this is func1&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>作用</strong>：函数名可以相同，提高复用性</p><p><strong>函数重载满足条件</strong>：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></li></ul><p><strong>注意</strong>：函数的返回值类型不可以作为函数重载的条件</p><p>例如：函数func返回值类型为int，而还有一个func函数返回值为void，这个时候编译器会报错！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//函数重载需要在同一个作用域中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//个数不同</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func(int a)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//参数类型不同</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func(double a)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//顺序不同</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func(int a,double b)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func(double a,int b)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//注意事项</span><br><span class="hljs-comment">//函数的返回值类型不能作为函数重载的条件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">0.1</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">0.1</span>);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul><li>引用作为函数重载条件</li><li>函数重载碰到函数默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//引用作为函数重载条件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;  <span class="hljs-comment">//int &amp;a=10;不合法</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;func(int &amp;a)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>&#123;  <span class="hljs-comment">//const int &amp;a=10;合法</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;func(const int &amp;a)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//函数重载碰到默认参数,出现二义性，报错，尽量避免这种情况</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func2(int a,int b)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func2(int a)的调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">func</span>(a);<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h2><p>C++面向对象的三大特性为：<em>封装</em>、<em>继承</em>、<em>多态</em></p><p>C++认为万事万物都皆为对象，对象上有其属性和行为</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a><strong>封装的意义</strong></h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一</strong>：</p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法</strong>：<em>class 类名{ 访问权限：属性 &#x2F; 行为 };</em></p><p>类中的属性和行为，我们统一称为成员</p><p>属性：成员属性 成员变量</p><p>行为：成员函数 成员方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//设计一个圆类，求圆的周长</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br>    <span class="hljs-comment">//访问权限</span><br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//公共权限</span><br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-type">int</span> m_r;<br>    <span class="hljs-comment">//行为</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*PI*m_r;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//通过圆类，创建具体的圆(对象)</span><br>    <span class="hljs-comment">//实例化  （通过一个类，创建一个对象的过程）</span><br>    Circle c1;<br>    <span class="hljs-comment">//给圆对象的属性进行赋值</span><br>    c1.m_r=<span class="hljs-number">10</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;圆的周长为：&quot;</span>&lt;&lt;c1.<span class="hljs-built_in">calculateZC</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>封装的意义二</strong>：</p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li><em>public公共权限，成员类内外可以访问</em></li><li><em>protected保护权限，成员类内可以访问，类外不可以访问，在继承中，父类的保护权限的内容，子类也可以访问</em></li><li><em>private私有权限，成员类内可以访问，类外不可以访问，父类的私有权限的内容，子类不可以访问</em></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-comment">//公共权限</span><br><span class="hljs-keyword">public</span>:<br>    string m_Name;<br>  <span class="hljs-comment">//保护权限</span><br><span class="hljs-keyword">protected</span>:<br>    string m_car;<br>  <span class="hljs-comment">//私有权限</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_password;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_Name=<span class="hljs-string">&quot;张三&quot;</span>;<br>        m_car=<span class="hljs-string">&quot;拖拉机&quot;</span>;<br>        m_password=<span class="hljs-number">123456</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Person p1;<br>    p1.m_Name=<span class="hljs-string">&quot;李四&quot;</span>;<br>    p1.m_car=<span class="hljs-string">&quot;奔驰&quot;</span>;  <span class="hljs-comment">//报错，保护权限类外不可访问</span><br>    p1.m_password=<span class="hljs-number">12</span>;  <span class="hljs-comment">//报错，私有权限类外不可访问</span><br>    p1.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//公共权限可以访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h4><p>在C++中struct和class唯一的区别就在于<strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li><em>struct 默认权限为公共</em></li><li><em>class 默认权限为私有</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>&#123;<br>    <span class="hljs-type">int</span> m_A;   <span class="hljs-comment">//默认权限  是私有</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C2</span>&#123;<br>    <span class="hljs-type">int</span> m_A;  <span class="hljs-comment">//默认权限为公有</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>C1 c1;<br>    c1.m_A=<span class="hljs-number">100</span>;  <span class="hljs-comment">//报错</span><br>    C2 c2;<br>    c2.m_A=<span class="hljs-number">100</span>;  <span class="hljs-comment">//不会报错,在struct默认的权限为公共的，所以可以访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p><strong>优点1</strong>：将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2</strong>：对于写权限，我们可以监测数据的有效性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//设置姓名</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span></span>&#123;<br>        m_Name=name;<br>    &#125;<br>    <span class="hljs-comment">//获取姓名</span><br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> m_Name;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//姓名  可读可写</span><br>    string m_Name;<br>    <span class="hljs-comment">//年龄 只读</span><br>    <span class="hljs-type">int</span> m_Age;<br>    <span class="hljs-comment">// 只写</span><br>    string m_lover;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Person p1;<br>    p1.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt;p1.<span class="hljs-built_in">getName</span>()&lt;&lt;endl;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><p>C++中的面向对象来源于生活，每个对象也会有初始化设置以及对象销毁前的清理数据的设置</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><ul><li>一个对象或者变量没有初始状态，对其使用后果是未知的</li><li>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul><p>C++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现</strong></p><ul><li><em>构造函数</em>：主要用于创建的对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</li><li><em>析构函数</em>：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数</strong>：</p><p>语法：<em>类名(){}</em></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次</li></ol><p><strong>析构函数</strong>：</p><p>语法：*~类名(){}*</p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上<em>符号~</em></li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动化调用，无须手动调用，而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数进行初始化操作</span><br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person 构造函数的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//析构函数进行清理的操作</span><br>~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person 析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;    <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p; <span class="hljs-comment">//创建对象就会自动调用构造函数</span><br>    <span class="hljs-comment">//在栈上的数据，test01执行完毕后，释放这个对象，对象销毁前会执行析构函数的操作</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//test01();</span><br>    Person p; <span class="hljs-comment">//main函数内，析构执行代码的操作输出我们看不到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="析构函数的分类及调用"><a href="#析构函数的分类及调用" class="headerlink" title="析构函数的分类及调用"></a>析构函数的分类及调用</h4><p>两种分类方式：</p><ul><li>按参数分为：有参构造和无参构造</li><li>按类型分为：普通构造和拷贝构造</li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p>注意事项：</p><ol><li>调用默认构造函数的时候不用加(),加入了括号，编译器会认为是一个函数的声明，不会认为在创建对象</li><li>不要利用拷贝构造函数初始化匿名对象，编译器会认为Person(p3)&#x3D;&#x3D;Person p3; 造成重定义报错</li><li></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//分类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//普通构造函数</span><br>    <span class="hljs-comment">//无参构造</span><br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person的无参构造函数的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//有参构造</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age=a;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person的有参构造函数的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;  <span class="hljs-comment">//将实例化对象传入，将这个对象的属性拷贝到这个函数的实例化对象中</span><br>        age=p.age;<br>    &#125;<br>~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person 析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;  <br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//括号法</span><br>    Person p; <span class="hljs-comment">//默认构造函数调用</span><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//有参构造函数</span><br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<span class="hljs-comment">//拷贝构造函数</span><br>    <br>    <span class="hljs-comment">//显示法</span><br>    Person p1; <span class="hljs-comment">//默认</span><br>    Person p2=<span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//调用有参构造函数</span><br>    Person p3=<span class="hljs-built_in">Person</span>(p2);<span class="hljs-comment">//调用拷贝构造函数</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//匿名对象，特点：当前行执行结束后，系统会立即回收掉匿名对象</span><br>    <br>    <span class="hljs-comment">//隐式转换法</span><br>    Person p4=<span class="hljs-number">10</span>; <span class="hljs-comment">//相当于写了Person p4(10); 有参构造</span><br>    Person p5=p4; <span class="hljs-comment">//拷贝构造函数</span><br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person默认构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_Age=age;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person拷贝构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_Aoge=p.m_Age;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//值传递的方式给函数参数传值</span><br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">doWork</span><span class="hljs-params">(Person p)</span></span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-built_in">doWotk</span>(p); <span class="hljs-comment">//值传递时，会拷贝一个副本，所以会执行拷贝构造函数</span><br>&#125;<br><br><span class="hljs-comment">//以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span>&#123;<br>    Person p1;<br>    cout&lt;&lt;(<span class="hljs-type">int</span>*)&amp;p1&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> p1;    <span class="hljs-comment">//局部对象会拷贝出新对象返回</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>    Person p=<span class="hljs-built_in">doWork2</span>();<br>    cout&lt;&lt;(<span class="hljs-type">int</span>*)&amp;p&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-built_in">test03</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，C++编译器至少给一个类添加3个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，C++不会再提供其他构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person默认构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_Age=age;<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person拷贝构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_Age=p.m_Age;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>Person p;<br>    p.m_Age=<span class="hljs-number">18</span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.m_Age&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>深浅拷贝是面试的经典问题，也是一个常见的坑</p><p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p><p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p><p><em>浅拷贝带来的问题就是堆区的内存重复释放</em></p><p><em>浅拷贝的问题要利用深拷贝进行解决，自己写一个拷贝函数</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person的默认构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age,<span class="hljs-type">int</span> height)&#123;<br>        m_Age=age;<br>        m_Height=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height); <span class="hljs-comment">//需要程序员手动销毁</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//自己实现拷贝函数来解决浅拷贝带来的问题</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造函数的调用&quot;</span>&lt;&lt;endl;<br>        m_Age=p.m_Age;<br>        <span class="hljs-comment">//m_Height=p.m_Height; 编译器默认实现</span><br>        <span class="hljs-comment">//深拷贝操作</span><br>        m_Height=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Height);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        <span class="hljs-comment">//析构代码，将堆区开辟数据做释放操作</span><br>        <span class="hljs-keyword">if</span>(m_Height!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_Height;<br>            m_Height=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_Age;<br>    <span class="hljs-type">int</span> *m_Height<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>,<span class="hljs-number">160</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1的年龄为: &quot;</span>&lt;&lt;p1.m_Age&lt;&lt;<span class="hljs-string">&quot;p1的身高为：&quot;</span>&lt;&lt;*p1.m_Height&lt;&lt;endl;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;  <span class="hljs-comment">//编译器给的拷贝是浅拷贝操作</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="hljs-string">&quot;p2的身高为：&quot;</span>&lt;&lt;*p2.m_Height&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用</strong>：</p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法</strong>：<em>构造函数():属性1(值1),属性2(值2) …{}</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//传统初始化操作</span><br>    <span class="hljs-comment">//Person(int a,int b,int c)&#123;</span><br>        <span class="hljs-comment">//m_A=a;</span><br>        <span class="hljs-comment">//m_B=b;</span><br>        <span class="hljs-comment">//m_C=c;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//初始化列表初始化属性</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c):<span class="hljs-built_in">m_A</span>(a),<span class="hljs-built_in">m_B</span>(b),<span class="hljs-built_in">m_C</span>(c)&#123;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>    <span class="hljs-type">int</span> m_C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)</span></span>; <span class="hljs-comment">//传统给属性赋初值方法</span><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>)</span></span>;  <span class="hljs-comment">//初始化列表赋初值方法</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为<em>对象成员</em></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    A a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>B类中有对象作为一个成员，A为对象成员</p><p>那么创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><em>先构造A对象再构造B对象</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-built_in">Phone</span>(string PName)&#123;<br>        m_PName=PName;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Phone的构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Phone</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Phone的析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//手机品牌名称</span><br>    string m_PName;<br>    <br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,string pName):<span class="hljs-built_in">m_Name</span>(name),<span class="hljs-built_in">m_Phone</span>(pName)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Person析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//姓名</span><br>    string m_Name;<br>    <span class="hljs-comment">//手机</span><br>    Phone m_Phone; <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;苹果MAX&quot;</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：当其他类对象作为本类成员，我们称该成员为<em>对象成员</em>，构造顺序是：先调用对象成员的构造，再调用本类构造，析构顺序与构造相反。</p></blockquote><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键词static，称为<em>静态成员</em></p><p>静态成员分为：</p><ul><li><strong>静态成员变量</strong><ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化(必须的操作)</li></ul></li><li><strong>静态成员函数</strong><ul><li>所有成员共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>静态成员变量：</p><p><strong>注意事项</strong>：静态成员变量也是有访问权限的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//静态成员变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//所有对象都共享同一份数据</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::m_A=<span class="hljs-number">100</span>; <span class="hljs-comment">//类外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    cout&lt;&lt;p.m_A&lt;&lt;endl;<br>    Person p2;<br>    p2.m_A=<span class="hljs-number">200</span>;<br>    cout&lt;&lt;p.m_A&lt;&lt;endl;  <span class="hljs-comment">//所有对象共享同一份数据,会输出200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//静态成员变量不属于某个对象上，所有对象都共享同一分数据</span><br>    <span class="hljs-comment">//1.通过对象进行访问</span><br>    Person p;<br>    cout&lt;&lt;p.m_A&lt;&lt;endl;<br>    <span class="hljs-comment">//2.通过类名进行访问</span><br>    cout&lt;&lt;Person::m_A&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员函数：</p><p><strong>注意事项</strong>：静态成员函数也是有访问权限的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//静态成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//静态成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_A=<span class="hljs-number">100</span>;<span class="hljs-comment">//静态成员函数可以访问静态成员变量</span><br>        m_B=<span class="hljs-number">200</span>;<span class="hljs-comment">//静态成员函数不可以访问非静态成员变量,无法区分是哪个对象的属性</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;static void func函数的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//非静态成员变量</span><br>&#125;;<br><br><span class="hljs-type">int</span> Person::m_A=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//通过对象访问</span><br>    Person p;<br>    p.<span class="hljs-built_in">func</span>();<br>    <span class="hljs-comment">//通过类名访问</span><br>    Person::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//非静态成员变量属于类的对象上的</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//静态成员变量不属于类的对象上</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//非静态成员函数不属于类的对象上的</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//静态成员函数不属于类的对象上的</span><br>&#125;;<br><br><span class="hljs-type">int</span> Person::m_B=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-comment">//空对象占用空间为：1</span><br>    <span class="hljs-comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span><br>    <span class="hljs-comment">//每个空对象也应该有一个独一无二的内存地址</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;size of p= &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    <span class="hljs-comment">//非空对象占用空间为：根据类对象非静态成员变量的字节数计算</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;size of p= &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>通过上一个章节我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p><strong>概念</strong>：</p><p>C++通过提供特殊的对象指针—-this指针，来进行区分哪个对象调用哪一块代码,<strong>this指针指向被调用的成员函数所属的对象</strong></p><p><em>this指针是隐含每一个非静态成员函数内的一种指针</em></p><p><em>this指针不需要定义，直接使用即可</em></p><p><strong>this指针的用途</strong>：</p><ul><li><strong>解决名称冲突</strong>：当形参和成员变量同名时，可用this指针来区分</li><li><strong>返回对象本身：</strong>在类的非静态成员函数中返回对象本身，可使用*return <em>this</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-comment">//this指针指向被调用的成员函数所属的对象</span><br>        <span class="hljs-keyword">this</span>-&gt;age=age;<br>    &#125;<br>    <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddAge</span><span class="hljs-params">(Person &amp;p)</span></span>&#123; <span class="hljs-comment">//如果返回是值的类型会发生拷贝函数，最后无法对对象属性进行修改，所以得用引用的方式返回</span><br>        <span class="hljs-keyword">this</span>-&gt;age+=p.age;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//返回执行完函数代码的对象本身</span><br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//解决名称冲突</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p1的年龄为：&quot;</span>&lt;&lt;p1.age&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//返回对象本身</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    p2.<span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1).<span class="hljs-built_in">PersonAddAge</span>(p1);<span class="hljs-comment">//多次调用，可以函数返回对象本身然后就可以继续调用</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showClassName</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;this is Person class&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPersonAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;age = &quot;</span>&lt;&lt;m_Age&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person *p=<span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">showClassName</span>();<br>    p-&gt;<span class="hljs-built_in">showPersonAge</span>();<span class="hljs-comment">//报错，传入的指针是空指针，无法访问类的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p><strong>常函数</strong>：</p><ul><li><strong>成员函数后</strong>加入const后我们称这个函数为<em>常函数</em></li><li>常函数内不可以修改成员属性</li><li><em>成员属性声明时加关键词<strong>mutable</strong>时，在常函数和常对象中依然可以修改</em></li></ul><p><strong>常对象</strong>：</p><ul><li>声明对象前加const后称该对象为<em>常对象</em></li><li>常对象只能调用常函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//this指针的本质是指针常量，指针的指向是不可以修改的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;  <span class="hljs-comment">//常函数</span><br>        <span class="hljs-keyword">this</span>-&gt;m_B=<span class="hljs-number">100</span>;<br>       <span class="hljs-comment">//this-&gt;m_A=100;</span><br>       <span class="hljs-comment">//this=NULL; this指针不可以修改指针的指向的</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_A=<span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量，即使在常函数中，也可以修改这个值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p;<br>    p.<span class="hljs-built_in">showPerson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//常对象</span><br>    <span class="hljs-type">const</span> Person p;<span class="hljs-comment">//在对象前加const，变为常对象</span><br>    p.m_A=<span class="hljs-number">100</span>;<span class="hljs-comment">//报错</span><br>    p.m_B=<span class="hljs-number">100</span>;<span class="hljs-comment">//mutable的变量在常对象下也可以调用</span><br>    <span class="hljs-comment">//常对象只能调用常函数</span><br>    p.<span class="hljs-built_in">showPerson</span>();<br>    p.<span class="hljs-built_in">func</span>();<span class="hljs-comment">//报错，常对象不可以调用普通成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类访问另一个类中私有成员</p><p>友元的关键词为 <strong>friend</strong></p><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>&#123;<br>    <span class="hljs-comment">//test01全局函数可以访问Building的私有成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(Building *building)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()&#123;<br>        m_SittingRoom=<span class="hljs-string">&quot;客厅&quot;</span>;<br>        m_BedRoom=<span class="hljs-string">&quot;卧室&quot;</span>;<br>    &#125;<br>    string m_SittingRoom;<br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<br>&#125;;<br><br><span class="hljs-comment">//全局函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(Building *building)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;全局函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_SittingRoom&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;全局函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl; <span class="hljs-comment">//私有属性</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    Building building;<br>    <span class="hljs-built_in">test01</span>(&amp;building);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gy</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">gy</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//参观函数访问Building中的属性</span><br>    Building *building;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">gy</span>; <span class="hljs-comment">//可以访问Building的私有成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>    string m_SittingRoom;<br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<br>&#125;;<br><br><span class="hljs-comment">//类外写成员函数</span><br>Building::<span class="hljs-built_in">Building</span>()&#123;<br>    m_SttingRoom=<span class="hljs-string">&quot;客厅&quot;</span>;<br>    m_BedRoom=<span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>gy::<span class="hljs-built_in">gy</span>()&#123;<br>    building=<span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gy::visit</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;gy类正在访问：&quot;</span>&lt;&lt;building-&gt;m_SttingRoom&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;gy类正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    gy gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gy</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">gy</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//让visit函数可以访问building中私有成员</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit1</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//让其不可以访问Building中的私有成员</span><br>    Building *building;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>&#123;<br>    <span class="hljs-comment">//gy类下的visit函数可以访问building的私有属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gy::visit</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>();<br>string m_SttingRoom;<br><span class="hljs-keyword">private</span>:<br>    string m_BedRoom;<br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()&#123;<br>    m_SttingRoom=<span class="hljs-string">&quot;客厅&quot;</span>;<br>    m_BedRoom=<span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>gy::<span class="hljs-built_in">gy</span>()&#123;<br>    building=<span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gy::visit</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;visit函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_SttingRoom&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;visit函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gy::visit1</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;visit1函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_SttingRoom&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;visit函数正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;<span class="hljs-comment">//不可以访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    gy gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>    gg.<span class="hljs-built_in">visit1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><strong>运算符重载概念</strong>：<em>对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型</em></p><p><strong>注意事项</strong>：运算符重载也可以发生函数重载</p><p>用<strong>operator运算符</strong>作为运算符的重载的运算符标记</p><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p><strong>作用</strong>：实现两个自定义数据类型相加的运算</p><p>重载实现方法：</p><ul><li>通过成员函数重载+号</li><li>通过全局函数重载+号</li></ul><p>用**operator+**作为加号运算符的重载的运算符标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//成员函数重载+号</span><br>    Person <span class="hljs-keyword">operator</span>+(Person &amp;p)&#123;<br>        Person temp;<br>        temp.m_A=<span class="hljs-keyword">this</span>-&gt;m_A+p.m_A;<br>        temp.m_B=<span class="hljs-keyword">this</span>-&gt;m_B+p.m_B;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;;<br>    <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><span class="hljs-comment">//全局函数重载+号</span><br>Person <span class="hljs-keyword">operator</span>+(Person &amp;p1,Person &amp;p2)&#123;<br>    Person temp;<br>    temp.m_A=p1.m_A+p2.m_A;<br>    temp.m_B=p1.m_B+p2.m_B;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-comment">//函数重载版本</span><br>Person <span class="hljs-keyword">operator</span>+(Person &amp;p1,<span class="hljs-type">int</span> num)&#123;<br>    Person temp;<br>    temp.m_A=p1.m_A+num;<br>    temp.m_B=p1.m_B+num;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person p1;<br>    p1.m_A=<span class="hljs-number">10</span>;<br>    p1.m_B=<span class="hljs-number">10</span>;<br>    Person p2;<br>    p2.m_A=<span class="hljs-number">10</span>;<br>    p2.m_B=<span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//本质调用</span><br>    Person p3=p1.<span class="hljs-keyword">operator</span>+(p2);<br>    <span class="hljs-comment">//简化调用</span><br>    Person p3=p1+p2;<br>    <span class="hljs-comment">//运算符重载也可以发生函数重载</span><br>    Person p4=p1+<span class="hljs-number">10</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p3.m_A= &quot;</span>&lt;&lt;p3.m_A&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p3.m_B= &quot;</span>&lt;&lt;p3.m_B&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul></blockquote><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p><strong>作用</strong>：可以输出自定义数据类型</p><p>重载实现方法：</p><ul><li>只能通过全局函数重载左移运算符</li></ul><p><strong>注意事项</strong>：重载的成员函数要想访问类的私有成员，就得利用友元技术</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<br>        m_A=a;<br>        m_B=b;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_A:<br>    <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//只能利用全局函数重载左移运算符</span><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_A= &quot;</span>&lt;&lt;p.m_A&lt;&lt;<span class="hljs-string">&quot; m_B= &quot;</span>&lt;&lt;p.m_B;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)</span></span>;<br>    cout&lt;&lt;p&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p><strong>作用</strong>：通过重载递增运算符，实现自己的整型数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span>&#123;<br>    <span class="hljs-keyword">friend</span> ostream <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,MyInteger myint)<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyInteger</span>()&#123;<br>        m_Num=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载前置++运算符，前置返回引用</span><br>    MyInteger&amp; <span class="hljs-keyword">operator</span>++()&#123;<br>        m_Num++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>    &#125;<br>    <span class="hljs-comment">//重载后置++运算符,后置返回值</span><br>    <span class="hljs-comment">//int代表的占位参数，用于区分前置和后置递增</span><br>    MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;<br>        <span class="hljs-comment">//先记录当时结果</span><br>        MyInteger temp=*<span class="hljs-keyword">this</span>;<br>        <span class="hljs-comment">//后递增</span><br>        m_Num++;<br>        <span class="hljs-comment">//最后将记录结果做返回操作</span><br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br><span class="hljs-comment">//重载左移运算符</span><br>ostream <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,MyInteger myint)&#123;<br>    cout&lt;&lt;myint.m_Num;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    MyInteger myint;<br>    cout&lt;&lt;myint&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    MyInteger myint;<br>    cout&lt;&lt;myint++&lt;&lt;endl;<br>    cout&lt;&lt;myint&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：前置递增返回引用，后置递增返回值</p></blockquote><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>C++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符operator&#x3D;，对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题(堆区内存重复释放，导致程序崩溃)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)&#123;<br>        m_Age=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        <span class="hljs-keyword">if</span>(m_Age!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重载赋值运算符</span><br>    Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)&#123;<br>        <span class="hljs-comment">//编译器提供浅拷贝</span><br>        <span class="hljs-comment">//m_Age=p.m_Age;</span><br>        <span class="hljs-comment">//应先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝</span><br>        <span class="hljs-keyword">if</span>(m_Age!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_Age;<br>            m_Age=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">//深拷贝</span><br>        m_Age=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Age);<br>        <span class="hljs-comment">//返回对象本身</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> *m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br>    p3=p2=p1; <span class="hljs-comment">//赋值操作</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p1的年龄：&quot;</span>&lt;&lt;*p1.m_Age&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p2的年龄：&quot;</span>&lt;&lt;*p2.m_Age&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p3的年龄：&quot;</span>&lt;&lt;*p3.m_Age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p><strong>作用</strong>：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        m_Name=name;<br>        m_Age=age;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp;p)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_Name==p.m_Name&amp;&amp;<span class="hljs-keyword">this</span>-&gt;m_Age==p.m_Age)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp;p)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_Name!=p.m_Name&amp;&amp;<span class="hljs-keyword">this</span>-&gt;m_Age!=p.m_Age)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    string m_Name;<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Jerry&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(p1==p2)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1和p2是相等的&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1和p2不相等&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p1!=p2)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1和p2不相等&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1和p2是相等的&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符()也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为<em>仿函数</em></li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span>&#123;<br>        cout&lt;&lt;test&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    MyPrint myprint;<br>    <span class="hljs-comment">//由于使用非常像函数调用，因此称为仿函数</span><br>    <span class="hljs-built_in">myprint</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//仿函数非常灵活，没有固定的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> num1,<span class="hljs-type">int</span> num2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> num1+num2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    MyAdd myadd;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">myadd</span>(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;ret= &quot;</span>&lt;&lt;ret&lt;&lt;endl;<br>    <br>    <span class="hljs-comment">//匿名函数对象</span><br>    cout&lt;&lt;<span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象的三大特性之一</strong></p><p>我们发现，定义一些类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p><p>这个时候我们就考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p><strong>语法</strong>：<em>class 子类:继承方式 父类类名</em></p><p>子类 也成为派生类</p><p>父类 也称为基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//继承实现页面</span><br><span class="hljs-comment">//公共页面类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;首页、公开课(公共头部)&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;帮助中心...(公共脚部)&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//继承语法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span>:<span class="hljs-keyword">public</span> BasePage&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Java学科视频&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span>:<span class="hljs-keyword">public</span> BasePage&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;python学科视频&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//c++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cpp</span>:<span class="hljs-keyword">public</span> BasePage&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;C++学科视频&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Java下载视频页面如下：&quot;</span>&lt;&lt;endl;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">footer</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;python下载视频页面如下：&quot;</span>&lt;&lt;endl;<br>    Python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">footer</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;C++下载视频页面如下：&quot;</span>&lt;&lt;endl;<br>    Cpp cpp;<br>    cpp.<span class="hljs-built_in">header</span>();<br>    cpp.<span class="hljs-built_in">footer</span>();<br>    cpp.<span class="hljs-built_in">content</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>继承的好处：可以减少重复的代码</p><p>派生类中的成员，包含两大部分：</p><ul><li>一类是从基类继承过来的，从基类继承过来的表现其共性</li><li>一类是自己增加的成员，新增的成员体现其个性</li></ul></blockquote><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p><strong>继承方式一共有三种</strong>：</p><ul><li><em>公共继承</em><ul><li>父类的公共权限到子类依然是公共权限</li><li>父类的保护权限到子类中依然是保护权限</li><li>父类中的私有权限成员子类访问不到</li></ul></li><li><em>保护继承</em><ul><li>父类中公共成员到子类中，变为保护权限</li><li>父类中保护成员到子类中，依然为保护权限</li><li>父类中的私有权限成员子类访问不到</li></ul></li><li><em>私有继承</em><ul><li>父类的公共成员到子类变为私有成员</li><li>父类的保护成员到子类变为私有成员</li><li>父类中的私有权限成员子类访问不到</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009276.png" alt="image"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span>:<span class="hljs-keyword">public</span> Base1&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_A=<span class="hljs-number">10</span>; <span class="hljs-comment">//父类的公共权限到子类依然是公共权限</span><br>        m_B=<span class="hljs-number">10</span>; <span class="hljs-comment">//父类的保护权限到子类中依然是保护权限</span><br>        <span class="hljs-comment">//m_C=10; //父类中的私有权限成员子类访问不到</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>:<span class="hljs-keyword">protected</span> Base1&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        m_A=<span class="hljs-number">100</span>;  <span class="hljs-comment">//父类中公共成员到子类中，变为保护权限</span><br>        m_B=<span class="hljs-number">100</span>;  <span class="hljs-comment">//父类中保护成员到子类中，变为保护权限</span><br>        <span class="hljs-comment">//m_C=10; //父类中的私有权限成员子类访问不到</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span>:<span class="hljs-keyword">private</span> Base1&#123;<br><span class="hljs-keyword">public</span>:<br>    m_A=<span class="hljs-number">100</span>;  <span class="hljs-comment">//父类的公共成员到子类变为私有成员</span><br>    m_B=<span class="hljs-number">100</span>;  <span class="hljs-comment">//父类的保护成员到子类变为私有成员</span><br>    <span class="hljs-comment">//m_C=10; //父类中的私有权限成员子类访问不到</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son1 s1;<br>    Son2 s2;<br>    Son3 s3;<br>    s1.m_A=<span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//s1.m_B=100;  保护权限类外不能访问</span><br>    <span class="hljs-comment">//s2.m_A=1000; 保护权限类外不能访问</span><br>    <span class="hljs-comment">//s3.m_A=1000; //私有权限类外不能访问</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><em>父类的所有非静态成员属性，子类都继承下来</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//结果为16，父类的所有属性，子类都继承下来</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;size of Son = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(Son)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：父类的私有属性也被子类继承下来了，只是访问不到，但是依然存在于子类中</p></blockquote><h4 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base构造函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//Base b;</span><br>    Son s;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>先构造父类，再构造子类，析构顺序与构造顺序相反</p></blockquote><h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><ul><li><strong>访问子类同名成员，直接访问即可</strong></li><li><strong>访问父类同名成员，需要加作用域</strong></li></ul><p>访问父类同名成员语法：</p><p><em>子类实例对象.父类名称::要调用的父类同名成员</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()&#123;<br>        m_A=<span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base-func函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base-func(int)函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        m_A=<span class="hljs-number">200</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Son-func函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Son-func(int)函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><span class="hljs-comment">//同名成员属性处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Son 下m_A&quot;</span>&lt;&lt;s.m_A&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Son 下m_A&quot;</span>&lt;&lt;s.Base::m_A&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//同名成员函数处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ul></blockquote><h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li><strong>访问子类同名成员，直接访问即可</strong></li><li><strong>访问父类同名成员，需要加作用域</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base-static func的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A=<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Son-static func的调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Son::m_A=<span class="hljs-number">200</span>;<br><br><span class="hljs-comment">//同名静态成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    <span class="hljs-comment">//1.通过对象访问静态成员</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Son m_A=&quot;</span>&lt;&lt;s.m_A&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Base m_A=&quot;</span>&lt;&lt;s.Base::m_A&lt;&lt;endl;<br>    <span class="hljs-comment">//2.通过类名访问静态成员</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;通过类名访问静态成员&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Son m_A=&quot;</span>&lt;&lt;Son::m_A&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Base m_A=&quot;</span>&lt;&lt;Son::Base::m_A&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//同名静态成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    s.<span class="hljs-built_in">func</span>();<br>    s.Base::<span class="hljs-built_in">func</span>();<br>    Son::<span class="hljs-built_in">func</span>();<br>    Son::Base::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名)</p></blockquote><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++中允许<em>一个类继承多个类</em></p><p><strong>语法</strong>：</p><p><em>class 子类:继承方式 父类1,继承方式 父类2…</em></p><p><strong>注意事项</strong>：</p><ul><li>多继承可能会引发父类中有同名成员出现，需要加作用域区分</li><li><strong>C++实际开发中不建议用多继承</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        m_A=<span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>()&#123;<br>        m_A=<span class="hljs-number">200</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base1,<span class="hljs-keyword">public</span> Base2&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        m_C=<span class="hljs-number">300</span>;<br>        m_D=<span class="hljs-number">400</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m_C;<br>    <span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    cout&lt;&lt;<span class="hljs-string">&quot;sizeof Son=&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(s)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;m_A=&quot;</span>&lt;&lt;s.Base1::m_A&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>概念</strong>：</p><p>两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承</p><p><strong>问题</strong>：</p><p>同名成员产生二义性，并且继承两个派生类的类会继承两份来自同一个基类的数据(资源浪费)，但是实际只需要一份就行了</p><p><strong>解决方法</strong>：</p><p>利用虚继承解决菱形继承的问题，<strong>语法</strong>：<em>class 子类:virtual public 父类{};</em>,则父类被称为虚基类,进行了虚继承(底层利用虚基类指针，让两个类都指向同一份数据)，则继承的数据是共享的，更改两份继承下来的数据就是更改一份数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal&#123;<br>    <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal&#123;<br>    <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span>:<span class="hljs-keyword">public</span> Sheep,<span class="hljs-keyword">public</span> Tuo&#123;<br>    <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    SheepTuo st;<br>    st.Sheep::m_Age=<span class="hljs-number">18</span>;<br>    st.Tuo::m_Age=<span class="hljs-number">28</span>;<br>    <span class="hljs-comment">//输出为28</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;st.Sheep::m_Age=&quot;</span>&lt;&lt;st.Sheep::m_Age&lt;&lt;endl;<br>    <span class="hljs-comment">//输出为28</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;st.Tuo::m_Age= &quot;</span>&lt;&lt;st.Tuo::m_Age&lt;&lt;endl;<br>    <span class="hljs-comment">//数据只需要一份</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象的三大特性之一</strong></p><p><strong>多态分为两类</strong>：</p><ul><li><em>静态多态</em>：函数重载和运算符重载属于静态多态，复用函数名</li><li><em>动态多态</em>：派生类和虚函数(加virtual关键词)实现运行时多态</li></ul><p><strong>静态多态和动态多态的区别</strong>：</p><ul><li>静态多态的<em>函数地址早绑定</em> - 编译阶段确定函数地址</li><li>动态多态的<em>函数地址晚绑定</em> - 运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//虚函数，加入virtual关键词</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;动物在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//没加virtual关键词,地址早绑定，在编译阶段就确定函数地址</span><br><span class="hljs-comment">//如果想执行让猫说话，则函数地址不能提前绑定，需要晚绑定</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal &amp;animal)</span></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">doSpeak</span>(cat);<span class="hljs-comment">//执行动物在说话</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>动态多态满足条件：</p><ol><li>有继承关系</li><li>子类有重写父类的虚函数</li></ol><p>动态多态的使用：父类的指针或引用指向子类对象</p></blockquote><p><strong>原理剖析</strong>：</p><p><img src="/../../../../../study/images/Snipaste_2023-05-17_11-32-07.jpg" alt="image"></p><p><strong>多态的优点</strong>：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期扩展以及维护</li></ul><blockquote><p><strong>总结</strong>：C++开发提倡利用多态设计程序架构，因为多态的优点很多</p></blockquote><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p><strong>语法</strong>：<em>virtual 返回值类型 函数名 (参数列表) &#x3D; 0;</em></p><p>当类中有了纯虚函数，这个类也成为<strong>抽象类</strong></p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Son func函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//Base b; 抽象类无法实例化对象</span><br>    Son s;<span class="hljs-comment">//如果没重写父类(抽象类)的纯虚函数，则该子类也为抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p><strong>解决方式</strong>：将父类中的析构函数改为<em>虚析构</em>或者<em>纯虚析构</em></p><p><strong>虚析构和纯虚析构共性</strong>:</p><ul><li>可以解决父类指针释放子类对象的问题</li><li>都需要有具体的函数实现</li></ul><p><strong>虚析构和纯虚析构区别</strong>：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构语法</strong>： <em>virtual ~类名(){}</em></p><p><strong>纯虚析构语法</strong>： </p><p><em>virtual ~类名()&#x3D;0;</em> 类外：<em>类名::~类名(){}</em></p><p><strong>注意事项</strong>：需要声明，也需要具体的实现代码(在类外实现)，有了纯虚析构函数之后，这个类也属于抽象类，无法实例化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Animal构造函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//利用虚析构可以解决父类指针释放子类对象时不干净的问题</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Animal析构函数调用&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//纯虚析构函数</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>()=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//纯虚析构也需要代码实现</span><br>Animal::~<span class="hljs-built_in">Animal</span>()&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Animal纯虚析构函数调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;*m_Name&lt;&lt;<span class="hljs-string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">Cat</span>(string name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;cat构造函数调用&quot;</span>&lt;&lt;endl;<br>        m_Name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    ~<span class="hljs-built_in">Cat</span>()&#123;<br>        <span class="hljs-keyword">if</span>(m_Name!=<span class="hljs-literal">NULL</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;cat析构函数调用&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">delete</span> m_Name;<br>            m_Name=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Animal *animal <span class="hljs-keyword">new</span> <span class="hljs-title">Cat</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>)</span></span>;<br>    animal-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-comment">//父类指针在析构时候不会调用子类中析构函数，导致子类如果有堆区属性，会出现内存泄漏</span><br>    <span class="hljs-keyword">delete</span> animal;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ol><li>虚析构或纯虚析构就是用来解决通过父类指针释放的子类对象</li><li>如果子类中没有堆区数据，可以不写虚析构或纯虚析构函数</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol></blockquote><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<em>文件可以将数据持久化</em></p><p>C++中对文件操作需要包含头文件**<fstream>**</p><p>文件类型分为两种：</p><ul><li><strong>文本文件</strong>   - 文件以文本的<em>ASCII码</em>形式存储在计算机中</li><li><strong>二进制文件</strong>   - 文件以文本的<em>二进制形式</em>存储在计算机中，用户一般不能直接读懂它们</li></ul><p>操作文件的三大类：</p><ul><li><strong>ofstream</strong>：写操作</li><li><strong>ifstream</strong>：读操作</li><li><strong>fstream</strong>：读写操作</li></ul><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件步骤如下：</p><ol><li><p><strong>包含头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建流对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ofstream ofs;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>,打开方式);<br></code></pre></td></tr></table></figure></li><li><p><strong>写数据</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ofs&lt;&lt;<span class="hljs-string">&quot;写入的数据&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ofs.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure></li></ol><p><strong>文件打开方式</strong>：</p><table><thead><tr><th><strong>打开方式</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意</strong>：文件打开方式可以配合使用，利用*|*操作符</p><p>例如：用二进制方式写文件<code>ios::binary|ios::out</code></p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p><strong>读文件步骤如下</strong>：</p><ol><li><p><strong>包含头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建流对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifstream ifs;<br></code></pre></td></tr></table></figure></li><li><p><strong>打开文件并判断文件是否打开成功</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>,打开方式);<br></code></pre></td></tr></table></figure></li><li><p><strong>读数据</strong></p><p>四种方式读取</p></li><li><p><strong>关闭文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ifs.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,ios::in);<br>    <span class="hljs-keyword">if</span>(!ifs.<span class="hljs-built_in">is_open</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//读数据</span><br>    <span class="hljs-comment">//第一种</span><br><span class="hljs-comment">//    char buf[1024]=&#123;0&#125;;</span><br><span class="hljs-comment">//    while(ifs&gt;&gt;buf)&#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//第二种</span><br><span class="hljs-comment">//    char buf[1024]=&#123;0&#125;;</span><br><span class="hljs-comment">//    while(ifs.getline(buf,sizeof(buf)))&#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//第三种</span><br><span class="hljs-comment">//    string buf;</span><br><span class="hljs-comment">//    while (getline(ifs,buf))&#123;</span><br><span class="hljs-comment">//        cout&lt;&lt;buf&lt;&lt;endl;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//第四种,不推荐</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span>((c=ifs.<span class="hljs-built_in">get</span>())!=EOF)&#123;  <span class="hljs-comment">//EOF end of file</span><br>        cout&lt;&lt;c;<br>    &#125;<br>    ifs.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>读文件可以利用ifstream，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close关闭文件</li></ul></blockquote><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为<code>iso::binary</code></p><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;test1.txt&quot;</span>,ios::out|ios::binary)</span></span>;<br><span class="hljs-comment">//    ofs.open(&quot;test1.txt&quot;,ios::out|ios::binary);</span><br>    Person p=&#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>&#125;;<br>    <span class="hljs-comment">//要把数据地址转化成const char*</span><br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(Person));<br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;test1.txt&quot;</span>,ios::in|ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span>(!ifs.<span class="hljs-built_in">is_open</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;文件打开失败&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Person p;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p, <span class="hljs-built_in">sizeof</span>(Person));<br>    cout&lt;&lt;p.m_Name&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;p.m_Age&lt;&lt;endl;<br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><strong>概念</strong>：</p><p>模板就是建立通用的模具，大大提高复用性</p><p><strong>特点</strong>：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ul><li>C++另一种编程思想称为<em>泛型编程</em>，主要利用的技术就是模板</li><li>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></li></ul><h4 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h4><p><strong>作用</strong>：</p><p>建立一个通用函数，其返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表</p><p><strong>语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或定义<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><p>template  —  声明创建模板</p><p>typename  —  表现其后面的符号是一种数据类型，可以用class代替</p><p>T  —  通用的数据类型，名称可以替换，通常为大写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">//声明一个函数模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>&#123;<br>    T temp=a;<br>    a=b;<br>    b=a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapInt</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapDouble</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;a,<span class="hljs-type">double</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">double</span> temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-comment">//swapInt(a,b);</span><br>    <span class="hljs-comment">//利用函数模板交换</span><br>    <span class="hljs-comment">//两种方式使用函数模板</span><br>    <span class="hljs-comment">//1. 自动类型推导</span><br>    <span class="hljs-built_in">myswap</span>(a,b);<br>    <span class="hljs-comment">//2. 显示指定类型</span><br>    <span class="hljs-built_in">myswap</span>&lt;<span class="hljs-type">int</span>&gt;(a,b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;a= &quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;b= &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-type">double</span> c=<span class="hljs-number">1.1</span>;<br>    <span class="hljs-type">double</span> d=<span class="hljs-number">2.2</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;c= &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;d= &quot;</span>&lt;&lt;d&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>函数模板利用关键词template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul></blockquote><h4 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h4><p><strong>注意事项</strong>：</p><ul><li>自动类型推导，必须推到出一致的数据类型T，才可以使用</li><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">(T&amp;a,T&amp;b)</span></span>&#123;<br>    T temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br><br><span class="hljs-comment">//模板必须要确定出T的数据类型，才可以使用</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;func调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-comment">//自动类型推导，必须推到出一致的数据类型T，才可以使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c=<span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-built_in">myswap</span>(a,b);<br>    <span class="hljs-built_in">myswap</span>(a,c);<span class="hljs-comment">//错误，数据类型不同</span><br>    <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;();<span class="hljs-comment">//如果函数没有用到T，调用时，也必须需要给出T才能调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h4><p><strong>普通函数和函数模板的区别</strong>：</p><ul><li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAdd01</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">//函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myAdd02</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-type">char</span> c=<span class="hljs-string">&#x27;c&#x27;</span>;<span class="hljs-comment">//普通函数调用会把传入类型进行一个强制转换</span><br>    <span class="hljs-comment">//自动类型推导</span><br>    <span class="hljs-built_in">myAdd02</span>(a,c);<span class="hljs-comment">//模板函数使用自动类型推导调用不会发生强制转换</span><br>    <span class="hljs-comment">//显示指定类型</span><br>    <span class="hljs-built_in">myAdd02</span>&lt;<span class="hljs-type">int</span>&gt;(a,c);<span class="hljs-comment">//模板函数使用显示指定类型调用，能够发生类型转换的</span><br>    cout&lt;&lt;<span class="hljs-built_in">myAdd01</span>(a,c)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>建议使用指定类型的方，调用函数模板，因为可以自己确定通用类型T</p></blockquote><h4 id="普通函数和函数模板的调用规则"><a href="#普通函数和函数模板的调用规则" class="headerlink" title="普通函数和函数模板的调用规则"></a>普通函数和函数模板的调用规则</h4><p><strong>调用规则如下</strong>：</p><ul><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用的普通函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用的模板&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(T a,T b,T c)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用的重载模板&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    b=<span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">myprint</span>(a,b); <span class="hljs-comment">//优先调用普通函数</span><br>   <span class="hljs-comment">//通过空模板参数列表，强制调用函数调用</span><br>    myprint&lt;&gt;(a,b);<br>    <span class="hljs-built_in">myprint</span>(a,b,<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">//如果函数模板可以产生更好的匹配，优先调用函数模板</span><br>    <span class="hljs-type">char</span> c1=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-type">char</span> c2=<span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-built_in">myprint</span>(c1,c2); <span class="hljs-comment">//普通函数需要转类型，而模板不需要，所以优先调用模板函数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><p>既然有了函数模板，最好就不要提供同名普通函数，否则容易出现二义性</p></blockquote><h4 id="模板的局限性以及具体化"><a href="#模板的局限性以及具体化" class="headerlink" title="模板的局限性以及具体化"></a>模板的局限性以及具体化</h4><p><strong>局限性</strong>：</p><ul><li>模板的通用性并不是万能的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    a=b;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        ....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入是像Person这样自定义的数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供了模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mycompare</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//利用具体化自定义类型的版本实现代码，具体化优先调用</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mycompare</span><span class="hljs-params">(Person &amp;p1,Person &amp;p2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p1.m_name==p2.m_name&amp;&amp;p1.m_age==p2.m_age)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>    <span class="hljs-type">bool</span> ret=<span class="hljs-built_in">mycompare</span>(a,b);<br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;a==b&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;a!=b&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ret=<span class="hljs-built_in">mycompare</span>(p1,p2);<br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1==p2&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;p1!=p2&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul></blockquote><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h4><p><strong>作用</strong>：</p><ul><li>建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表</li></ul><p><strong>语法</strong>:<code>template&lt;class T&gt;</code> </p><p>​类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">nametype</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">agetype</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(nametype name,agetype age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>    nametype m_name;<br>    agetype m_age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">999</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h4><p><strong>区别</strong>：</p><ul><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//agetype默认参数为int</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">nametype</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">agetype</span>=<span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(nametype name,agetype age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>    nametype m_name;<br>    agetype m_age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">999</span>)</span></span>; <span class="hljs-comment">//报错，类模板是没有自动类型推导</span><br>    Person p1&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p1</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">999</span>);<br>Person p1&lt;string&gt;<span class="hljs-built_in">p1</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">999</span>);<span class="hljs-comment">//模板类型默认为int，所以不写就用int</span><br>    p1.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul></blockquote><h4 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person1</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show1</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;person1show&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show2</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;person2show&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myclass</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    T obj;<br>    <span class="hljs-comment">//类模板中成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show1</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show2</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    myclass&lt;Person1&gt;m;<br>    m.<span class="hljs-built_in">func1</span>();<br>    <span class="hljs-comment">//m.func2();</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p></blockquote><h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><p>类模板实例化出的对象，向函数传参的方式</p><p>三种传参方式：</p><ul><li>指定传入的类型  —  直接显示对象的数据类型</li><li>参数模板化  —  将对象中的参数变为模板进行传递</li><li>整个类模板化  —  将这个对象类型模板化进行传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>=<span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name,T2 age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">100</span>);<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p1</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">100</span>);<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p2</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printp1</span>(p);<br>    <span class="hljs-built_in">printp2</span>(p1);<br>    <span class="hljs-built_in">printp3</span>(p2);<br>&#125;<br><br><span class="hljs-comment">//指定传入类型(最常用)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printp1</span><span class="hljs-params">(Person&lt;string,<span class="hljs-type">int</span>&gt;&amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-comment">//参数模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printp2</span><span class="hljs-params">(Person&lt;T1,T2&gt;&amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;T1的类型为：&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>()&lt;&lt;endl; <span class="hljs-comment">//看推导出来的T1是什么类型</span><br>&#125;<br><br><span class="hljs-comment">//整个类模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printp3</span><span class="hljs-params">(T &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛的是第一种：指定传入的类型</li></ul></blockquote><h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需要变为类模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    T m;<br>&#125;;<br><br><span class="hljs-comment">//class Son:public Base //错误，c++编译器需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;;<br><br><span class="hljs-comment">//如果想灵活指定出父类中T的类型，子类也需要变为类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>:<span class="hljs-keyword">public</span> Base&lt;T2&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son2</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;T1的类型为：&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;T2的类型为：&quot;</span>&lt;&lt;<span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>()&lt;&lt;endl;<br>    &#125;<br>    T1 obj;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Son s1;<br>    Son2&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt;s2;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name,T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br><span class="hljs-comment">//构造函数的类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1,T2&gt;::<span class="hljs-built_in">Person</span>(T1 name,T2 age)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>    <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>&#125;<br><br><span class="hljs-comment">//成员函数的类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1,T2&gt;::<span class="hljs-built_in">show</span>()&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">P</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：类模板中成员函数类外实现时，需要加入模板的参数列表</p></blockquote><h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h4><p>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p><p><strong>解决方法</strong>：</p><ol><li>直接包含.cpp源文件</li><li>将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称，并不是强制</li></ol><p><strong>分文件编写的.h写法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once  <span class="hljs-comment">//防止重复</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><p>示例：</p><p>&#x2F;&#x2F;第一种解决方法</p><p>Person.h代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name,T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Person.cpp代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1,T2&gt;::<span class="hljs-built_in">Person</span>(T1 name,T2 age)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>    <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1,T2&gt;::<span class="hljs-built_in">show</span>()&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.cpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">P</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>    P.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;第二种解决方法</p><p>将.h和.cpp中的内容写到一起，将后缀名改为.hpp文件</p><p>.hpp被称为类模板</p><p>Person.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name,T2 age);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>Person&lt;T1,T2&gt;::<span class="hljs-built_in">Person</span>(T1 name,T2 age)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>    <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T1,T2&gt;::<span class="hljs-built_in">show</span>()&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;<span class="hljs-keyword">this</span>-&gt;m_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><p>类模板模板配合友元函数的类内和类外实现</p><p><strong>全局函数类外实现</strong> - 直接在类内声明友元即可</p><p><strong>全局函数类外实现</strong> - 需要提前让编译器知道全局函数的存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类外实现，需要让编译器提前知道Person类的存在</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>;<br><br><br><span class="hljs-comment">//通过全局函数打印Person信息</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//全局函数类内实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Person&lt;T1,T2&gt;p)</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name: &quot;</span>&lt;&lt;p.m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;p.m_age&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//全局函数类外实现</span><br>    <span class="hljs-comment">//需要加空模板参数列表</span><br>    <span class="hljs-comment">//如果全局函数是类外实现的话，需要提前让编译器知道全局函数的存在</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> print1&lt;&gt;(Person&lt;T1,T2&gt;p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T1 name,T2 age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    T1 m_name;<br>    T2 m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Person&lt;T1,T2&gt; p)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;类外实现name: &quot;</span>&lt;&lt;p.m_name&lt;&lt;<span class="hljs-string">&quot;age= &quot;</span>&lt;&lt;p.m_age&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Person&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">print</span>(p);<br>    <span class="hljs-built_in">print1</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p></blockquote><h4 id="类模板案例"><a href="#类模板案例" class="headerlink" title="类模板案例"></a>类模板案例</h4><p>案例描述：实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储在堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p>myArray.hpp代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myArray</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//有参构造</span><br>    <span class="hljs-built_in">myArray</span>(<span class="hljs-type">int</span> capacity)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_capacity=capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_size=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>-&gt;paddress=<span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;m_capacity];<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造,深拷贝</span><br>    <span class="hljs-built_in">myArray</span>(<span class="hljs-type">const</span> myArray&amp;arr)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_capacity=arr.m_capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_size=arr.m_size;<br>        <span class="hljs-keyword">this</span>-&gt;paddress=<span class="hljs-keyword">new</span> T[arr.m_capacity];<br>        <span class="hljs-comment">//将arr中的数组都拷贝过来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-keyword">this</span>-&gt;m_size;i++)&#123;<br>            <span class="hljs-keyword">this</span>-&gt;paddress[i]=arr.paddress[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//operator=防止浅拷贝问题</span><br>    myArray&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> myArray&amp; arr)&#123;<br>        <span class="hljs-comment">//先判断原来堆区是否有数据，如果有先释放</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;paddress!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;paddress;<br>            <span class="hljs-keyword">this</span>-&gt;paddress=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">this</span>-&gt;m_capacity=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">this</span>-&gt;m_size=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;m_capacity=arr.m_capacity;<br>        <span class="hljs-keyword">this</span>-&gt;m_size=arr.m_size;<br>        <span class="hljs-keyword">this</span>-&gt;paddress=<span class="hljs-keyword">new</span> T[arr.m_capacity];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-keyword">this</span>-&gt;m_size;i++)&#123;<br>            <span class="hljs-keyword">this</span>-&gt;paddress[i]=arr.paddress[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//尾插法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span>&#123;<br>        <span class="hljs-comment">//先判断容量是否等于大小</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_capacity== <span class="hljs-keyword">this</span>-&gt;m_size)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;paddress[<span class="hljs-keyword">this</span>-&gt;m_size]=val; <span class="hljs-comment">//在数组末尾插入数据</span><br>        <span class="hljs-keyword">this</span>-&gt;m_size++;  <span class="hljs-comment">//更新数组大小</span><br>    &#125;<br><br>    <span class="hljs-comment">//尾删法,让用户访问不到最后一个元素,逻辑删除</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;m_size--;<br>    &#125;<br><br>    <span class="hljs-comment">//通过下标来访问数组中的元素,重载中括号,引用可做左值存在</span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;paddress[index];<br>    &#125;<br><br>    <span class="hljs-comment">//返回数组容量</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_capacity</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//返回数组大小</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;m_size;<br>    &#125;<br><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">myArray</span>()&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;paddress!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> [] <span class="hljs-keyword">this</span>-&gt;paddress;<br>            <span class="hljs-keyword">this</span>-&gt;paddress=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T * paddress;  <span class="hljs-comment">//指针指向堆区开辟的真实的数组</span><br>    <span class="hljs-type">int</span> m_capacity;  <span class="hljs-comment">//数组容量</span><br>    <span class="hljs-type">int</span> m_size;  <span class="hljs-comment">//数组大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>myArray.cpp代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myArray.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;&#125;;<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_name = name;<br><span class="hljs-keyword">this</span>-&gt;m_age = age;<br>&#125;<br><br>string m_name;<br><span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarr</span><span class="hljs-params">(myArray&lt;Person&gt; &amp;arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">get_size</span>(); i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].m_name &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; arr[i].m_age &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(myArray&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">get_size</span>(); i++) &#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>myArray&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">arr</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-comment">//利用尾插法，向数组插入数据</span><br>arr.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr的打印输出：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print</span>(arr);<br>cout &lt;&lt; <span class="hljs-string">&quot;arr的容量：&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">get_capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr的大小：&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">get_size</span>() &lt;&lt; endl;<br>myArray&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">arr1</span>(arr);<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的打印输出：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print</span>(arr1);<br><span class="hljs-comment">//尾删法</span><br>arr1.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的容量：&quot;</span> &lt;&lt; arr1.<span class="hljs-built_in">get_capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1的大小：&quot;</span> &lt;&lt; arr1.<span class="hljs-built_in">get_size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>myArray&lt;Person&gt;<span class="hljs-built_in">arr</span>(<span class="hljs-number">10</span>);<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">999</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;韩信&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;妲己&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;安其拉&quot;</span>, <span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">28</span>)</span></span>;<br>arr.<span class="hljs-built_in">push_back</span>(p1);<br>arr.<span class="hljs-built_in">push_back</span>(p2);<br>arr.<span class="hljs-built_in">push_back</span>(p3);<br>arr.<span class="hljs-built_in">push_back</span>(p4);<br>arr.<span class="hljs-built_in">push_back</span>(p5);<br><span class="hljs-built_in">printarr</span>(arr);<br>cout &lt;&lt; <span class="hljs-string">&quot;arr的容量：&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">get_capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr的大小：&quot;</span> &lt;&lt; arr.<span class="hljs-built_in">get_size</span>() &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//test01();</span><br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li><li>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了STL</li></ul><h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL从广义上分为：<strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li><li>STL几乎所有代码都采用了模板类或者模板函数</li></ul><h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别为：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p><ol><li><strong>容器</strong>：各种数据结构，如：vector、list、deque、set、map等，用来存放数据</li><li><strong>算法</strong>：各种常用的算法，如：sort、find、copy、for_each等</li><li><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂</li><li><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略</li><li><strong>适配器</strong>：一种用来修饰容器或者仿函数或者迭代器接口的东西</li><li><strong>空间配置器</strong>：负责空间的配置与管理。</li></ol><h3 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h3><p><strong>容器</strong>：置物之所也</p><p>STL容器就是将运用最广泛的一些数据结构闪现出来</p><p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><ul><li><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置</li><li><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul><p><strong>算法</strong>：问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们称为算法(Algorithms)</p><p>算法分为<strong>质变算法</strong>和<strong>非质变算法</strong>：</p><ul><li><strong>质变算法</strong>：是指运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等等</li><li><strong>非质变算法</strong>：是指运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等等</li></ul><p><strong>迭代器</strong>：容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p><strong>迭代器种类</strong>：</p><table><thead><tr><th><strong>种类</strong></th><th><strong>功能</strong></th><th><strong>支持运算</strong></th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写操作，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器插入数据，并遍历这个容器</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p><strong>容器</strong>：<code>vector</code></p><p><strong>算法</strong>：<code>for_each</code></p><p>迭代器：<code>vector&lt;int&gt;::iterator</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;alogrithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//创建一个vector容器，数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//尾插法，插入数据</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br><span class="hljs-comment">//通过迭代器访问容器中的数据</span><br>    <span class="hljs-comment">//第一种遍历方式</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itBegin = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//起始迭代器指向容器中第一个元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = v.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">//结束迭代器，指向容器中最后一个元素的下一个位置</span><br><span class="hljs-keyword">while</span> (itBegin != itEnd) &#123;<br>cout &lt;&lt; *itBegin &lt;&lt; endl;<br>itBegin++;<br>&#125;<br>    <span class="hljs-comment">//第二种方法</span><br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">//第三种方式,利用STL中的遍历算法</span><br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),myprint);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector容器中存放自定义数据类型"><a href="#vector容器中存放自定义数据类型" class="headerlink" title="vector容器中存放自定义数据类型"></a>vector容器中存放自定义数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Person&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-number">40</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;eee&quot;</span>,<span class="hljs-number">50</span>)</span></span>;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br>    v.<span class="hljs-built_in">push_back</span>(p5);<br>    <span class="hljs-keyword">for</span>(vector&lt;Person&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        <span class="hljs-comment">//cout&lt;&lt;&quot;name：&quot;&lt;&lt;(*it).m_name&lt;&lt;&quot;  age：&quot;&lt;&lt;(*it).m_age&lt;&lt;endl;</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;name：&quot;</span>&lt;&lt;it-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;  age：&quot;</span>&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;*Person&gt; v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-number">40</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;eee&quot;</span>,<span class="hljs-number">50</span>)</span></span>;<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p1);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p2);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p3);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p4);<br>    v.<span class="hljs-built_in">push_back</span>(&amp;p5);<br>    <span class="hljs-keyword">for</span>(vector&lt;Person*&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;name：&quot;</span>&lt;&lt;(*it)-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;  age：&quot;</span>&lt;&lt;(*it)-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;v;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v4;<br>    <span class="hljs-comment">//向小容器中添加数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">2</span>);<br>        v3.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">3</span>);<br>        v4.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">4</span>);<br>    &#125;<br>    <span class="hljs-comment">//将小容器插入到大容器中</span><br>    v.<span class="hljs-built_in">push_back</span>(v1);<br>    v.<span class="hljs-built_in">push_back</span>(v2);<br>    v.<span class="hljs-built_in">push_back</span>(v3);<br>    v.<span class="hljs-built_in">push_back</span>(v4);<br>    <span class="hljs-comment">//通过大容器，把所有数据遍历一遍</span><br>    <span class="hljs-keyword">for</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        <span class="hljs-comment">//(*it) --- 容器vector&lt;int&gt;</span><br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit=(*it).<span class="hljs-built_in">begin</span>();vit!=(*it).<span class="hljs-built_in">end</span>();vit++)&#123;<br>            cout&lt;&lt;*vit&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL-–常用容器"><a href="#STL-–常用容器" class="headerlink" title="STL –常用容器"></a>STL –常用容器</h2><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><h4 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h4><p><strong>本质</strong>：</p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char*的区别</strong>：</p><ul><li>char*是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char指针型容器</li></ul><p><strong>特点</strong>：</p><p>string类内部封装了很多成员的方法</p><p>例如：查找find，拷贝copy，删除delete，替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h4><p>构造函数原型：</p><ul><li><p><code>string();</code>      &#x2F;&#x2F;创建一个空的字符串，例如：string str;</p><p><code>string(const char* s);</code>      &#x2F;&#x2F;使用字符串s初始化</p></li><li><p><code>string(const string&amp; str);</code>   &#x2F;&#x2F;使用一个string对象初始化另一个string对象</p></li><li><p><code>string(int n,char c);</code>     &#x2F;&#x2F;使用n个字符c初始化</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//string的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    string s1;  <span class="hljs-comment">//默认构造</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s2= &quot;</span>&lt;&lt;s2&lt;&lt;endl;<br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s3= &quot;</span>&lt;&lt;s3&lt;&lt;endl;<br>    <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;s4= &quot;</span>&lt;&lt;s4&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>       &#x2F;&#x2F;char*类型字符串赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>    &#x2F;&#x2F;把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                   &#x2F;&#x2F;字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>            &#x2F;&#x2F;把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s,int n);</code>  &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>         &#x2F;&#x2F;把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n,char c);</code>              &#x2F;&#x2F;把n个字符c赋给当前字符串</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//第一种</span><br>    string str1;<br>    str1=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>   <span class="hljs-comment">//第二种</span><br>    string str2;<br>    str2=str1;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str2= &quot;</span>&lt;&lt;str2&lt;&lt;endl;<br>    <span class="hljs-comment">//第三种</span><br>    string str3;<br>    str3=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3= &quot;</span>&lt;&lt;str3&lt;&lt;endl;<br>    <span class="hljs-comment">//第四种</span><br>    string str4;<br>    str4.<span class="hljs-built_in">assgin</span>(<span class="hljs-string">&quot;hello c++&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str4= &quot;</span>&lt;&lt;str4&lt;&lt;endl;<br>    <span class="hljs-comment">//第五种</span><br>    string str5;<br>    str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello c++&quot;</span>,<span class="hljs-number">5</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str5= &quot;</span>&lt;&lt;str5&lt;&lt;endl;<br>    <span class="hljs-comment">//第六种</span><br>    string str6;<br>    str6.<span class="hljs-built_in">assign</span>(str5);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str6= &quot;</span>&lt;&lt;str6&lt;&lt;endl;<br>    <span class="hljs-comment">//第七种</span><br>    string str7;<br>    str7.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;w&#x27;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str7= &quot;</span>&lt;&lt;str7&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：string的赋值方式狠多，<code>operator=</code>这种方式是比较实用的</p></blockquote><h4 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h4><p>功能描述：</p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; operator+=(const char* str);</code>           &#x2F;&#x2F;重载+&#x3D;操作符</li><li><code>string&amp; operator+=(const char c);</code>                &#x2F;&#x2F;重载+&#x3D;操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>        &#x2F;&#x2F;重载+&#x3D;操作符</li><li><code>string&amp; append(const char *s);</code>                      &#x2F;&#x2F;把字符s连接到当前字符串末尾</li><li><code>string&amp; append(const char *s,int n);</code>            &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                   &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str);</li><li><code>string&amp; append(const string &amp;s,int pos,int n);</code> &#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串末尾</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//第一种</span><br>    string str1=<span class="hljs-string">&quot;我&quot;</span>;<br>    str1+=<span class="hljs-string">&quot;爱玩游戏&quot;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>    <span class="hljs-comment">//第二种</span><br>    str1+=<span class="hljs-string">&#x27;:&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>    <span class="hljs-comment">//第三种</span><br>    string str2=<span class="hljs-string">&quot;LOL DNF&quot;</span>;<br>    str1+=str2;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>    <span class="hljs-comment">//第四种</span><br>    string str3=<span class="hljs-string">&quot;I&quot;</span>;<br>    str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;love&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3= &quot;</span>&lt;&lt;str3&lt;&lt;endl;<br>    <span class="hljs-comment">//第五种</span><br>    str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;game abcde&quot;</span>,<span class="hljs-number">4</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3= &quot;</span>&lt;&lt;str3&lt;&lt;endl;<br>    <span class="hljs-comment">//第六种</span><br>    str3.<span class="hljs-built_in">append</span>(str2);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3= &quot;</span>&lt;&lt;str3&lt;&lt;endl;<br>    <span class="hljs-comment">//第七种</span><br>    str3.<span class="hljs-built_in">append</span>(str2,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str3= &quot;</span>&lt;&lt;str3&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p><strong>功能描述</strong>：</p><ul><li>查找：查找指定字符串是否存放</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>int find(const string&amp; str,int pos=0) const;</code> &#x2F;&#x2F;查找str第一次出现位置，从pos开始查找</li><li><code>int find(const char* s,int pos=0) const;</code>    &#x2F;&#x2F;查找s第一次出现的位置，从pos开始查找</li><li><code>int find(const char* s,int pos,itn n) const;</code>  &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c,int pos=0) const;</code>   &#x2F;&#x2F;查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str,int pos=npos) const;</code>  &#x2F;&#x2F;查找str最后一次出现位置，从pos开始查找</li><li><code>int rfind(const char* s,int pos=npos) const;</code>   &#x2F;&#x2F;查找s最后一次出现位置，从pos开始查找</li><li><code>int rfind(const char* s,int pos,int n) const;</code>  &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c,int pos=0) const;</code>  &#x2F;&#x2F;查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos,int n,const string string&amp; str);</code>    &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos,int n,const char* s);</code>   &#x2F;&#x2F;替换从pos开始的n个字符为字符串</li></ul><p><strong>find和rfind的区别</strong>：</p><ul><li>find是从左往右查找</li><li>rfind是从右往左查找，但下标返回值是从左往右数的</li></ul><p><strong>注意事项</strong>：</p><ul><li>如果查找不到字符或者字符串，会返回值-1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//查找</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//find</span><br>    string str1=<span class="hljs-string">&quot;abcdefgede&quot;</span>;<br>    <span class="hljs-type">int</span> pos=str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;de&quot;</span>);  <span class="hljs-comment">//查找不到会返回-1</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;pos= &quot;</span>&lt;&lt;pos&lt;&lt;endl; <span class="hljs-comment">//3</span><br>    <span class="hljs-comment">//rfind</span><br>    pos=str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;de&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;pos= &quot;</span>&lt;&lt;pos&lt;&lt;endl;  <span class="hljs-comment">//7</span><br>&#125;<br><br><span class="hljs-comment">//替换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    string str1=<span class="hljs-string">&quot;abcdefg&quot;</span>;<br>    str1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;1111&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;   <span class="hljs-comment">//a1111efg</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h4><p><strong>功能描述</strong>：</p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式</strong>：</p><p>字符串比较是按字符的ASCII码进行对比</p><ul><li>*&#x3D;*返回 0</li><li>*&gt;*返回 1</li><li>*&lt;*返回 -1</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>int compare(const string &amp;s) const;</code>&#x2F;&#x2F;与字符串s比较</li><li><code>int compare(const char *s) const;</code>  &#x2F;&#x2F;与字符串s比较</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    string str1=<span class="hljs-string">&quot;hello&quot;</span>;<br>    string str2=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">if</span>(str1.<span class="hljs-built_in">compare</span>(str2)==<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;str1=str2&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str1.<span class="hljs-built_in">compare</span>(str2)&gt;<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;str1&gt;str2&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str1.<span class="hljs-built_in">compare</span>(str2)&lt;<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;str1&lt;str2&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h4><p>string中单个字符存取方式有两种：</p><ul><li><code>char&amp; operator[](int n);</code>    &#x2F;&#x2F;通过[]方式取字符</li><li><code>char&amp; at(int n);</code>     &#x2F;&#x2F;通过at方法获取字符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    string sr1=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-comment">//通过[]访问单个字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str1.<span class="hljs-built_in">size</span>();i++)&#123;<br>        cout&lt;&lt;str1[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//通过at方式访问单个字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str1.<span class="hljs-built_in">size</span>();i++)&#123;<br>        cout&lt;&lt;str1.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//修改单个字符</span><br>    str1[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;x&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>    str1.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>)=<span class="hljs-string">&#x27;x&#x27;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;str1= &quot;</span>&lt;&lt;str1&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>string&amp; insert(int pos,const char* s);</code>   &#x2F;&#x2F;插入字符串</li><li><code>string&amp; insert(int pos,const string&amp; str);</code>   &#x2F;&#x2F;插入字符串</li><li><code>string&amp; insert(int pos,int n,char c);</code>   &#x2F;&#x2F;在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos,int n=npos);</code>    &#x2F;&#x2F;删除从pos开始的n个字符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-comment">//插入</span><br>    str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;111&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str= &quot;</span>&lt;&lt;str&lt;&lt;endl;<br>    <span class="hljs-comment">//删除</span><br>    str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;str= &quot;</span>&lt;&lt;str&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h4><p><strong>功能描述</strong>：</p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>string substr(int pos=0,int n=npos) const;</code>  &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;abcedf&quot;</span>;<br>    string subStr=str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;subStr= &quot;</span>&lt;&lt;subStr&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//实用操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    string email=<span class="hljs-string">&quot;zhangsan@sina.com&quot;</span>;<br>    <span class="hljs-comment">//从邮件地址中获取用户名信息</span><br>    <span class="hljs-type">int</span> pos=email.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>    string username=email.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,pos);<br>    cout&lt;&lt;<span class="hljs-string">&quot;username= &quot;</span>&lt;&lt;username&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><h4 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h4><p><strong>功能</strong>：</p><ul><li>vector数据结构和数组非常相似，也成为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别</strong>：</p><ul><li>不同之处在于数组是静态空间，而vector可以动态扩展</li></ul><p><strong>动态扩展</strong>：</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><p><strong>功能描述</strong>：</p><ul><li>创建vector容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>vector&lt;T&gt; v;</code>  &#x2F;&#x2F;采用模块实现类实现，默认构造函数</li><li><code>vector(v.begin(),v.end());</code>   &#x2F;&#x2F;将v[begin(),end())区间中的元素拷贝给本身</li><li><code>vector(n,elem);</code>   &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li><code>vector(const vector &amp;vec);</code>   &#x2F;&#x2F;拷贝构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;  <span class="hljs-comment">//默认无参构造</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-comment">//通过区间方式进行构造</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v1</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(v1);<br>    <span class="hljs-comment">//n个elem方式构造</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v2</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">print</span>(v2);<br>    <span class="hljs-comment">//拷贝构造</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v3</span>(v2);<br>    <span class="hljs-built_in">print</span>(v3);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h4><p><strong>功能描述</strong>：</p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>   &#x2F;&#x2F;重载等号操作符</li><li><code>assign(beg,end);</code>   &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code>   &#x2F;&#x2F;将n个elem拷贝赋值给本身</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v);<br>    <br>    <span class="hljs-comment">//赋值 operator=</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    v1=v;<br>    <span class="hljs-built_in">print</span>(v1);<br>    <br>    <span class="hljs-comment">//assign</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    v2.<span class="hljs-built_in">assign</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(v2);<br>    <br>    <span class="hljs-comment">//n个elem方式赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v3;<br>    v3.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">print</span>(v3);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h4><p><strong>功能描述</strong>：</p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>empty();</code>    &#x2F;&#x2F;判断容器是否为空</li><li><code>capacity();</code>  &#x2F;&#x2F;容器的容量</li><li><code>size();</code>   &#x2F;&#x2F;返回容器中元素的个数</li><li><code>resize(int num);</code>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值(0)填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>resize(int num,elem);</code>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-keyword">if</span>(v.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;v为空&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;v不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;v的容量为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;v的大小为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//重新指定大小</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">100</span>);  <span class="hljs-comment">//可以指定默认填充值</span><br>    <span class="hljs-built_in">print</span>(v);   <span class="hljs-comment">//补的默认值为0</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">print</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>push_back(ele);</code>    &#x2F;&#x2F;尾部插入元素ele</li><li><code>pop_back();</code>    &#x2F;&#x2F;删除最后一个元素</li><li><code>insert(const_iterator pos,ele);</code>  &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos,int count,ele);</code>    &#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>  &#x2F;&#x2F;删除迭代器指向的元素</li><li><code>erase(const_iterator start,const_iterator end);</code>&#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li><code>clear();</code>    &#x2F;&#x2F;删除容器中所有元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i*<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v);<br>    v.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">//尾删</span><br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-comment">//插入</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">100</span>);  <span class="hljs-comment">//第一个参数为迭代器</span><br>    <span class="hljs-built_in">print</span>(v);<br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-comment">//删除</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>());  <span class="hljs-comment">//参数也为迭代器</span><br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-comment">//v.erase(v.begin(),v.end());  //从头到尾删除</span><br>    v.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">//也是清空操作</span><br>    <span class="hljs-built_in">print</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h4><p><strong>功能描述</strong>：</p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code>    &#x2F;&#x2F;返回索引idx所指的数据</li><li><code>operator[];</code>      &#x2F;&#x2F;返回索引idx所指的数据</li><li><code>front();</code>           &#x2F;&#x2F;返回容器中第一个数据元素</li><li><code>back();</code>            &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//利用[]方式访问数组中元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++)&#123;<br>        cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//利用at方式访问元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++)&#123;<br>cout&lt;&lt;v.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    cout&lt;&lt;<span class="hljs-string">&quot;第一个元素为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">front</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;最后一个元素为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h4><p><strong>功能描述</strong>：</p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>swap(vec);</code>    &#x2F;&#x2F;将vec与本身大的元素互换</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v);<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(v1);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后：&quot;</span>&lt;&lt;endl;<br>    v1.<span class="hljs-built_in">swap</span>(v);<br>    <span class="hljs-built_in">print</span>(v);<br>    <span class="hljs-built_in">print</span>(v1);<br>&#125;<br><br><span class="hljs-comment">//实际用途</span><br><span class="hljs-comment">//巧用swap可以收缩内存空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;   <span class="hljs-comment">//容量不变</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//巧用swap收缩内存</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);<br>    <span class="hljs-comment">//vector&lt;int&gt;(v)  匿名对象，当前行执行完，就将匿名对象回收</span><br>    <span class="hljs-comment">//.swap(v);   容量交换</span><br>    <span class="hljs-comment">//用swap会根据交换的容器大小来初始化容器的容量</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;v的容量：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">capacity</span>()&lt;&lt;endl;   <span class="hljs-comment">//容量收缩了</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;v的大小为：&quot;</span>&lt;&lt;v.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h4><p><strong>功能描述</strong>：</p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>reserve(int len);</code> &#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-comment">//利用reserve预留空间，减少开辟次数</span><br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//统计容器开辟次数</span><br>    <span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;i++)&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p!=&amp;v[<span class="hljs-number">0</span>])&#123;<br>            p=&amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>功能</strong>：</p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别</strong>：</p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度会比vector快</li><li>vector访问元素时速度会比deque快，这和两者内部实现有关</li></ul><p><strong>deque内部工作原理</strong>：</p><p>deque内部有一个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009277.png" alt="image"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><p><strong>功能描述</strong>：</p><ul><li>deque容器构造</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>deque&lt;T&gt; deqT;</code>   &#x2F;&#x2F;默认构造形式</li><li><code>deque(beg,end);</code>  &#x2F;&#x2F;构造函数将[beg,end)区间中的元素拷贝给本身</li><li><code>deque(n,elem);</code>    &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li><code>deque(const deque &amp;deq);</code>  &#x2F;&#x2F;拷贝构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt; &amp;d)</span></span>&#123;  <span class="hljs-comment">//内部的*it不能更改了</span><br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;:: const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        d1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(d1);<br>    deque&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">d2</span>(d1.<span class="hljs-built_in">begin</span>(),d1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(d2);<br>    deque&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">d3</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">print</span>(d3);<br>    deque&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">d4</span>(d3);<br>    <span class="hljs-built_in">print</span>(d4);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><p><strong>功能描述</strong>：</p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code>   &#x2F;&#x2F;重载等号操作符</li><li><code>assign(beg,end);</code>    &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code>     &#x2F;&#x2F;将n个elem赋值给本身</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt; &amp;d)</span></span>&#123;  <span class="hljs-comment">//内部的*it不能更改了</span><br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;:: const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        d1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//第一种赋值</span><br>    deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>    d2=d1;<br>    <span class="hljs-built_in">print</span>(d2);<br>    <span class="hljs-comment">//第二种</span><br>    deque&lt;<span class="hljs-type">int</span>&gt;d3;<br>    d3.<span class="hljs-built_in">assign</span>(d1.<span class="hljs-built_in">begin</span>(),d1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(d3);<br>    <span class="hljs-comment">//第三种</span><br>    deque&lt;<span class="hljs-type">int</span>&gt;d4;<br>    d4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">print</span>(d4);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><p><strong>功能描述</strong>：</p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>deque.empty();</code>     &#x2F;&#x2F;判断容器是否为空</li><li><code>deque.size();</code>      &#x2F;&#x2F;返回容器中的元素个数</li><li><code>deque.resize(num);</code> &#x2F;&#x2F;重新指定容器的长度num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>deque.resize(num,elem);</code>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp;d)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        d1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-keyword">if</span>(d1.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;d1为空&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;d1不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;d1的大小为：&quot;</span>&lt;&lt;d1.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>        <span class="hljs-comment">//deque容器没有容量概念</span><br>    &#125;<br>    <span class="hljs-comment">//重新指定大小</span><br>    d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：deque容器是没有容量的概念的。</p></blockquote><h4 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型</strong>：</p><p>两端插入删除操作：</p><ul><li><code>push_back(elem);</code>   &#x2F;&#x2F;在容器尾部添加一个数据</li><li><code>push_front(elem);</code> &#x2F;&#x2F;在容器的头部插入一个数据</li><li><code>pop_back();</code>     &#x2F;&#x2F;删除容器最后一个数据</li><li><code>pop_front();</code>   &#x2F;&#x2F;删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code>  &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>  &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li><code>insert(pos,beg,end);</code>  &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</li><li><code>clear();</code>  &#x2F;&#x2F;清空容器的所有数据</li><li><code>erase(beg,end);</code>   &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置</li><li><code>erase(pos);</code>   &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp;d)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    <span class="hljs-comment">//尾插法</span><br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//头插</span><br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//尾删</span><br>    d1.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//头删</span><br>    d1.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-built_in">print</span>(d1);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//insert插入</span><br>    d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//按照区间进行插入</span><br>    deque&lt;<span class="hljs-type">int</span>&gt;d2;<br>    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">begin</span>(),d2.<span class="hljs-built_in">begin</span>(),d2.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(d1);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d1;<br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-comment">//删除</span><br>    deque&lt;<span class="hljs-type">int</span>&gt;::iterator it=d1.<span class="hljs-built_in">begin</span>();<br>    it++;<br>    d1.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-built_in">print</span>(d1);<br>    <span class="hljs-comment">//按照区间方式删除</span><br>    d1.<span class="hljs-built_in">erase</span>(d1.<span class="hljs-built_in">begin</span>(),d1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//清空</span><br>    d1.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">print</span>(d1);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>插入和删除提供的位置是迭代器！</li></ul></blockquote><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><p><strong>功能描述</strong>：</p><ul><li>对deque中的数据的存取操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>at(int idx);</code>   &#x2F;&#x2F;返回索引idx所指数据</li><li><code>operator[];</code>   &#x2F;&#x2F;返回索引idx所指数据</li><li><code>front();</code>    &#x2F;&#x2F;返回容器中第一个数据元素</li><li><code>back();</code>      &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d;<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-comment">//通过[]方式访问元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;d.<span class="hljs-built_in">size</span>();i++)&#123;<br>        cout&lt;&lt;d[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <br>    <span class="hljs-comment">//通过at方式访问元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;d.<span class="hljs-built_in">size</span>();i++)&#123;<br>        cout&lt;&lt;d.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;第一个元素为：&quot;</span>&lt;&lt;d.<span class="hljs-built_in">front</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;最后一个元素为：&quot;</span>&lt;&lt;d.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h4><p><strong>功能描述</strong>：</p><ul><li>利用算法实现deque容器进行排序</li></ul><p><strong>算法</strong>：</p><ul><li><code>sort(iterator beg,iterator end)</code>   &#x2F;&#x2F;对beg和end区间内元素进行排序</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp;d)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    deque&lt;<span class="hljs-type">int</span>&gt;d;<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-comment">//排序</span><br>    <span class="hljs-comment">//对于支持随机访问的迭代器的容器，都可以利用sort算法直接进行排序</span><br>    <span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    cout&lt;&lt;<span class="hljs-string">&quot;排序后结果：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(d);  <span class="hljs-comment">//默认排序规则从小到大升序</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stack-栈-容器"><a href="#stack-栈-容器" class="headerlink" title="stack(栈)容器"></a>stack(栈)容器</h3><p><strong>基本概念</strong>：</p><p><strong>概念</strong>：stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009278.png" alt="image"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为 — <strong>入栈</strong><code>push</code></p><p>栈中弹出数据称为 — <strong>出栈</strong><code>pop</code></p><h4 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h4><p><strong>功能描述</strong>：</p><ul><li>栈容器常用的对外接口</li></ul><p><strong>构造函数</strong>：</p><ul><li><code>stack&lt;T&gt; stk;</code>   &#x2F;&#x2F;stack采用模板类实现，stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>   &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值操作</strong>：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><p><strong>数据存取</strong>：</p><ul><li><code>push(elem);</code>   &#x2F;&#x2F;向栈顶添加元素</li><li><code>pop();</code>    &#x2F;&#x2F;从栈顶移除第一个元素</li><li><code>top();</code>    &#x2F;&#x2F;返回栈顶元素</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>   &#x2F;&#x2F;判断堆栈是否为空</li><li><code>size();</code>     &#x2F;&#x2F;返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt;s;<br>    <span class="hljs-comment">//入栈</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">40</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;栈的大小：&quot;</span>&lt;&lt;s.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//只要栈不为空，查看栈顶，并且执行出栈操作</span><br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;栈顶元素为：&quot;</span>&lt;&lt;s.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        <span class="hljs-comment">//出栈</span><br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;栈的大小为：&quot;</span>&lt;&lt;s.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="queue-队列-容器"><a href="#queue-队列-容器" class="headerlink" title="queue(队列)容器"></a>queue(队列)容器</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>概念</strong>：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009279.png" alt="image"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong><code>push</code></p><p>队列中出数据称为 — <strong>出队</strong><code>pop</code></p><h4 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h4><p><strong>功能描述</strong>：</p><ul><li>队列容器常用的对外接口</li></ul><p><strong>构造函数</strong>：</p><ul><li><code>queue&lt;T&gt; que;</code>    &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>    &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值操作</strong>：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>   &#x2F;&#x2F;重载等号操作符</li></ul><p><strong>数据存取</strong>：</p><ul><li><code>push(elem);</code>   &#x2F;&#x2F;往队尾添加元素</li><li><code>pop();</code>    &#x2F;&#x2F;从队头移除第一个元素</li><li><code>back();</code>   &#x2F;&#x2F;返回最后一个元素</li><li><code>front();</code>  &#x2F;&#x2F;返回第一个元素</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>   &#x2F;&#x2F;判断堆栈是否为空</li><li><code>size();</code>    &#x2F;&#x2F;返回栈的大小</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;Person&gt;q;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;p1&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;p2&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;p3&quot;</span>,<span class="hljs-number">40</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;p4&quot;</span>,<span class="hljs-number">50</span>)</span></span>;<br>    <span class="hljs-comment">//入队</span><br>    q.<span class="hljs-built_in">push</span>(p1);<br>    q.<span class="hljs-built_in">push</span>(p2);<br>    q.<span class="hljs-built_in">push</span>(p3);<br>    q.<span class="hljs-built_in">push</span>(p4);<br>    cout&lt;&lt;<span class="hljs-string">&quot;队列大小：&quot;</span>&lt;&lt;q.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//判断只要队列不为空，查看队头，查看队尾，出队</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//查看队头</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;队头元素：&quot;</span>&lt;&lt;q.<span class="hljs-built_in">front</span>().m_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q.<span class="hljs-built_in">front</span>().m_age&lt;&lt;endl;<br>        <span class="hljs-comment">//查看队尾</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;队尾元素：&quot;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>().m_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>().m_age&lt;&lt;endl;<br>        <span class="hljs-comment">//出队</span><br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;队列大小：&quot;</span>&lt;&lt;q.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="priority-queue-优先队列-容器"><a href="#priority-queue-优先队列-容器" class="headerlink" title="priority_queue(优先队列)容器"></a>priority_queue(优先队列)容器</h3><p><strong>优先队列定义</strong>：</p><ul><li>使用优先队列,**定义参数&lt;数据类型，容器类型，比较方法&gt;**，默认是大根堆<br>例子：      <code>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt;q</code>;</li></ul><p><strong>数据存取操作</strong>：</p><ul><li><code>push(elem);</code>   &#x2F;&#x2F;添加元素</li><li><code>pop();</code>    &#x2F;&#x2F;从队列中删除最高优先级的元素</li><li><code>top();</code>    &#x2F;&#x2F;获取队列中最高优先级的元素</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>   &#x2F;&#x2F;判断是否为空</li><li><code>size();</code>    &#x2F;&#x2F;获取队列大小</li></ul><h3 id="list-链表-容器"><a href="#list-链表-容器" class="headerlink" title="list(链表)容器"></a>list(链表)容器</h3><p><strong>功能</strong>：将数据进行链式存储</p><p><strong>链表</strong>(list)：是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL的链表是一个<strong>双向循环链表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009280.png" alt="image"></p><p>由于链表的存储方式不是连续的内存内存空间，因此链表list中的迭代器只支持前移和后移属于<strong>双向迭代器</strong></p><p><strong>优点</strong>：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>缺点</strong>：</p><ul><li>链表灵活，但是空间(指针域)和时间(遍历)额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的</p><blockquote><p><strong>总结</strong>：STL中的<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p></blockquote><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p><strong>功能描述</strong>：</p><ul><li>创建list容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>list&lt;T&gt; lst;</code>   &#x2F;&#x2F;list采用模板类实现，对象的默认构造形式</li><li><code>list(beg,end);</code>  &#x2F;&#x2F;构造函数将[beg,end)区间中的元素拷贝给本身</li><li><code>list(n,elem);</code>  &#x2F;&#x2F;构造函数将n个elem拷贝给本身</li><li><code>list(const list &amp;lst);</code>   &#x2F;&#x2F;拷贝构造函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    <span class="hljs-comment">//添加数据</span><br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-comment">//遍历容器</span><br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-comment">//区间方式构造</span><br>    list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l1</span>(l.<span class="hljs-built_in">begin</span>(),l.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(l1);<br>    <span class="hljs-comment">//拷贝构造</span><br>    list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l2</span>(l1);<br>    <span class="hljs-built_in">print</span>(l2);<br>    <span class="hljs-comment">//n个elem</span><br>    list&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">l3</span>(<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">print</span>(l3);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p><strong>功能描述</strong>：</p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>assign(beg,end);</code>    &#x2F;&#x2F;将[beg,end)区间中的数据拷贝赋值给本身</li><li><code>assign(n,elem);</code>    &#x2F;&#x2F;将n个elem拷贝赋值给本身</li><li><code>list&amp; operator=(const list &amp;lst);</code>    &#x2F;&#x2F;重载等号操作符</li><li><code>swap(lst);</code>     &#x2F;&#x2F;将lst与本身的元素互换</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    list&lt;<span class="hljs-type">int</span>&gt;l1;<br>    l1=l;  <span class="hljs-comment">//operator= 赋值</span><br>    <span class="hljs-built_in">print</span>(l1);<br>    list&lt;<span class="hljs-type">int</span>&gt;l2;<br>    l2.<span class="hljs-built_in">assign</span>(l1.<span class="hljs-built_in">begin</span>(),l1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">print</span>(l2);<br>    list&lt;<span class="hljs-type">int</span>&gt;l3;<br>    l3.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">print</span>(l3);<br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    list&lt;<span class="hljs-type">int</span>&gt;l1;<br>    l1.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-built_in">print</span>(l1);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后：&quot;</span>&lt;&lt;endl;<br>    l.<span class="hljs-built_in">swap</span>(l1);<br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-built_in">print</span>(l1);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><strong>功能描述</strong>：</p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>size();</code>   &#x2F;&#x2F;返回容器中元素的个数</li><li><code>empty();</code>    &#x2F;&#x2F;判断容器是否为空</li><li><code>resize(num);</code>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</li><li><code>resize(num,elem);</code>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>    <span class="hljs-comment">//判断容器是否为空</span><br>    <span class="hljs-keyword">if</span>(l.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;l为空&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;l不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;l的大小为：&quot;</span>&lt;&lt;l.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">//重新指定大小</span><br>    l.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    l.<span class="hljs-built_in">resize</span>(<span class="hljs-number">11</span>,<span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    l.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>push_back(elem);</code>    &#x2F;&#x2F;在容器尾部加入一个元素</li><li><code>pop_back();</code>    &#x2F;&#x2F;删除容器中最后一个元素</li><li><code>push_front(elem);</code>   &#x2F;&#x2F;在容器开头插入一个元素</li><li><code>pop_front();</code>  &#x2F;&#x2F;在容器开头移除第一个元素</li><li><code>insert(pos,elem);</code>   &#x2F;&#x2F;在pos位置插入elem元素的拷贝，返回新数据的位置</li><li><code>insert(pos,n,elem);</code>   &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</li><li><code>insert(pos,beg,end);</code>   &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</li><li><code>clear();</code>   &#x2F;&#x2F;移除容器的所有数据</li><li><code>erase(beg,end);</code>   &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置</li><li><code>erase(pos);</code>    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置</li><li><code>remove(elem);</code>   &#x2F;&#x2F;删除容器中所有与elem值匹配的元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    <span class="hljs-comment">//尾插</span><br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    <br>    <span class="hljs-comment">//头插</span><br>    l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>    l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>    l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-comment">//尾删</span><br>    l.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-comment">//头删</span><br>    l.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>    <span class="hljs-comment">//insert插入</span><br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it=l.<span class="hljs-built_in">begin</span>();<br>    l.<span class="hljs-built_in">insert</span>(++it,<span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>    <span class="hljs-comment">//删除</span><br>    it=l.<span class="hljs-built_in">begin</span>();<br>    l.<span class="hljs-built_in">erase</span>(++it);<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>    <span class="hljs-comment">//移除</span><br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    l.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>    <span class="hljs-comment">//清空</span><br>    l.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">print</span>(l);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><strong>功能·描述</strong>：</p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>front();</code>   &#x2F;&#x2F;返回第一个元素</li><li><code>back();</code>     &#x2F;&#x2F;返回最后一个元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    <br>    <span class="hljs-comment">//l[0]  不可以用[]访问list容器中数据</span><br>    <span class="hljs-comment">//list本质是个链表，每个数据不是用连续的线性空间存储数据，迭代器也是不支持随机访问</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;第一个元素为：&quot;</span>&lt;&lt;l.<span class="hljs-built_in">front</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;最后一个元素为：&quot;</span>&lt;&lt;l.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>    <br>    <span class="hljs-comment">//验证迭代器是不支持随机访问的</span><br>    list&lt;<span class="hljs-type">int</span>&gt;::iterator it=l.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">//it=it+2;//不允许跳跃式访问(随机访问)</span><br>    it++;<br>    it--; <span class="hljs-comment">//支持双向</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：list容器中不可以通过[]或者at方式访问数据</p></blockquote><h4 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h4><p><strong>功能描述</strong>：</p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>reverse();</code>         &#x2F;&#x2F;反转链表</li><li><code>sort();</code>       &#x2F;&#x2F;链表排序</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;l)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=l.<span class="hljs-built_in">begin</span>();it!=l.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//反转</span><br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">print</span>(l);<br>    cout&lt;&lt;<span class="hljs-string">&quot;反转后：&quot;</span>&lt;&lt;endl;<br>    l.<span class="hljs-built_in">reverse</span>();<br>    <span class="hljs-built_in">print</span>(l);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mycompare</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>&#123;<br>    <span class="hljs-comment">//降序，就让第一个数大于第二个数</span><br>    <span class="hljs-keyword">return</span> v1&gt;v2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt;l;<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;排序前：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(l);<br>    cout&lt;&lt;<span class="hljs-string">&quot;排序后：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//所有不支持随机访问迭代器的容器，不可以用标准算法</span><br>    <span class="hljs-comment">//不支持随机访问迭代器的容器,内部会提供对应一些算法</span><br>    l.<span class="hljs-built_in">sort</span>();<span class="hljs-comment">//默认为升序</span><br>    <span class="hljs-built_in">print</span>(l);<br>    <span class="hljs-comment">//降序</span><br>    l.<span class="hljs-built_in">sort</span>(mycompare);<br>    <span class="hljs-built_in">print</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="set-multiset-集合-容器"><a href="#set-multiset-集合-容器" class="headerlink" title="set&#x2F;multiset(集合)容器"></a>set&#x2F;multiset(集合)容器</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>简介</strong>：</p><ul><li>所有元素都会插入时自动被排序</li></ul><p><strong>本质</strong>：</p><ul><li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h4><p><strong>功能描述</strong>：</p><ul><li>创建set容器以及赋值</li></ul><p><strong>构造</strong>：</p><ul><li><code>set&lt;T&gt;st;</code>    &#x2F;&#x2F;默认构造函数</li><li><code>set(const set &amp;st);</code>    &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值</strong>：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;<span class="hljs-type">int</span>&gt;s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    <span class="hljs-comment">//插入数据只有insert方式</span><br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">//set容器特点：所有元素插入时候自动排序</span><br>    <span class="hljs-comment">//set容器不允许插入重复值</span><br>    <span class="hljs-built_in">print</span>(s1);<br>    <span class="hljs-comment">//拷贝构造</span><br>    set&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">s2</span>(s1);<br>    <span class="hljs-built_in">print</span>(s2);<br>    <span class="hljs-comment">//赋值</span><br>    set&lt;<span class="hljs-type">int</span>&gt;s3;<br>    s3=s2;<br>    <span class="hljs-built_in">print</span>(s3);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><strong>功能描述</strong>：</p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>size();</code>    &#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty();</code>    &#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st);</code>    &#x2F;&#x2F;交换两个集合容器</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;<span class="hljs-type">int</span>&gt;s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-built_in">print</span>(s1);<br>    <br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;s1为空&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;s1不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;s1的大小为：&quot;</span>&lt;&lt;s1.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;s2;<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(s1);<br>    <span class="hljs-built_in">print</span>(s2);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后：&quot;</span>&lt;&lt;endl;<br>    s1.<span class="hljs-built_in">swap</span>(s2);<br>    <span class="hljs-built_in">print</span>(s1);<br>    <span class="hljs-built_in">print</span>(s2);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code>    &#x2F;&#x2F;在容器中插入元素</li><li><code>clear();</code>    &#x2F;&#x2F;清除所有元素</li><li><code>erase(pos);</code>    &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li><code>erase(beg,end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器</li><li><code>erase(elem);</code>    &#x2F;&#x2F;删除容器中值为elem的元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;<span class="hljs-type">int</span>&gt;s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::const_iterator it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-built_in">print</span>(s1);<br>    <br>    <span class="hljs-comment">//删除</span><br>    s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">print</span>(s1);<br>    <span class="hljs-comment">//删除重载版本</span><br>    s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">print</span>(s1);<br>    <br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-comment">//s1.erase(s1.begin(),s1.end());</span><br>    s1.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">print</span>(s1);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h4><p><strong>功能描述</strong>：</p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code>    &#x2F;&#x2F;查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>    &#x2F;&#x2F;统计key的元素个数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-comment">//查找</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator pos=s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-keyword">if</span>(pos!=s1.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到元素：&quot;</span>&lt;&lt;*pos&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到元素&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-comment">//统计,对于set而言，统计结果要么是0，要么是1</span><br>    <span class="hljs-type">int</span> num=s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h4><p><strong>区别</strong>：</p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s;<br>    pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator,<span class="hljs-type">bool</span>&gt; ret=s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(ret.second)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;第一次插入成功&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;第一次插入失败&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ret=s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(ret.second)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;第二次插入成功&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;第二次插入失败&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <br>    multiset&lt;<span class="hljs-type">int</span>&gt;m;<br>    <span class="hljs-comment">//允许插入重复的值</span><br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it=m.<span class="hljs-built_in">begin</span>();it!=m.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul></blockquote><h4 id="pair队组创建"><a href="#pair队组创建" class="headerlink" title="pair队组创建"></a>pair队组创建</h4><p><strong>功能描述</strong>：</p><ul><li>成对出现的数据，利用队组可以返回两个数据</li></ul><p><strong>两种创建方式</strong>：</p><ul><li><code>pair&lt;type,type&gt; p(value1,value2);</code></li><li><code>pair&lt;type,type&gt; p=make_pair(value1,value2);</code></li></ul><p><strong>注意事项</strong>：</p><ul><li>使用时不需要包含头文件</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//第一种方式</span><br>    pair&lt;string,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">20</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt;p.first&lt;&lt;<span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt;p.second&lt;&lt;endl;<br>    <br>    <span class="hljs-comment">//第二种方式</span><br>    pair&lt;string,<span class="hljs-type">int</span>&gt;p2=<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;jerry&quot;</span>,<span class="hljs-number">30</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt;p2.first&lt;&lt;<span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt;p2.second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则是从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>  set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> v1&gt;v2;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;s1;<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=s1.<span class="hljs-built_in">begin</span>();it!=s1.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//指定排序规则为从小到大</span><br>    set&lt;<span class="hljs-type">int</span>,mycompare&gt;s2;<br>    <br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>    s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>,mycompare&gt;::iterator it=s2.<span class="hljs-built_in">begin</span>();it!=s2.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp;p1,<span class="hljs-type">const</span> Person&amp;p2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> p1.m_age&gt;p2.m_age;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//自定义数据类型都会指定排序规则</span><br>    set&lt;Person,mycompare&gt;s;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张1&quot;</span>,<span class="hljs-number">24</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张2&quot;</span>,<span class="hljs-number">28</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张3&quot;</span>,<span class="hljs-number">25</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;张4&quot;</span>,<span class="hljs-number">21</span>)</span></span>;<br>    s.<span class="hljs-built_in">insert</span>(p1);<br>    s.<span class="hljs-built_in">insert</span>(p2);<br>    s.<span class="hljs-built_in">insert</span>(p3);<br>    s.<span class="hljs-built_in">insert</span>(p4);<br>    <span class="hljs-keyword">for</span>(set&lt;Person&gt;::iterator it=s.<span class="hljs-built_in">begin</span>();it!=s.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt;it-&gt;m_name&lt;&lt;<span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F;multimap容器"></a>map&#x2F;multimap容器</h3><h4 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h4><p><strong>简介</strong>：</p><ul><li>map中所有元素都是pair(队组)</li><li>pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值)</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质</strong>：</p><ul><li>map&#x2F;multimap属于<strong>关联式容器</strong>，底层使用二叉树实现</li></ul><p><strong>优点</strong>：</p><ul><li>可以根据key值快速找到value值</li></ul><p><strong>map和multimap区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h4><p><strong>功能描述</strong>：</p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型</strong>：</p><p><strong>构造</strong>：</p><ul><li><code>map&lt;T1,T2&gt;mp;</code>     &#x2F;&#x2F;map默认构造函数</li><li><code>map(const map &amp;mp);</code>   &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值</strong>：</p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::const_iterator it=m.<span class="hljs-built_in">begin</span>();it!=m.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;key= &quot;</span>&lt;&lt;(*it).first&lt;&lt;<span class="hljs-string">&quot;value= &quot;</span>&lt;&lt;(*it).second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m;<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>,<span class="hljs-number">40</span>));<br>    <br>    <span class="hljs-built_in">print</span>(m);<br>    <br>    <span class="hljs-comment">//拷贝构造</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">m2</span>(m);<br>    <span class="hljs-built_in">print</span>(m2);<br>    <br>    <span class="hljs-comment">//赋值</span><br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m3;<br>    m3=m2;<br>    <span class="hljs-built_in">print</span>(m3);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h4><p><strong>功能描述</strong>：</p><ul><li>统计map容器大小以及交换map容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>size();</code>    &#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty();</code>    &#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st);</code>    &#x2F;&#x2F;交换两个集合容器</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::const_iterator it=m.<span class="hljs-built_in">begin</span>();it!=m.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;key= &quot;</span>&lt;&lt;(*it).first&lt;&lt;<span class="hljs-string">&quot;value= &quot;</span>&lt;&lt;(*it).second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//大小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m;<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">empty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;m为空&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;m不为空&quot;</span>&lt;&lt;endl;<br>        cout&lt;&lt;<span class="hljs-string">&quot;m的大小为：&quot;</span>&lt;&lt;m.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m;<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m2;<br>    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>,<span class="hljs-number">100</span>));<br>    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>,<span class="hljs-number">200</span>));<br>    m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">6</span>,<span class="hljs-number">300</span>));<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(m);<br>    <span class="hljs-built_in">print</span>(m2);<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后：&quot;</span>&lt;&lt;endl;<br>    m.<span class="hljs-built_in">swap</span>(m2);<br>    <span class="hljs-built_in">print</span>(m);<br>    <span class="hljs-built_in">print</span>(m2);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h4><p><strong>功能描述</strong>：</p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>insert(elem);</code>   &#x2F;&#x2F;在容器中插入元素</li><li><code>clear();</code>    &#x2F;&#x2F;清除所有元素</li><li><code>erase(pos);</code>    &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li><code>erase(beg,end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有有元素，返回下一个元素的迭代器</li><li><code>erase(key);</code>      &#x2F;&#x2F;删除容器中值为key的元素</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;m)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::const_iterator it=m.<span class="hljs-built_in">begin</span>();it!=m.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;key= &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; value= &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m;<br>    <span class="hljs-comment">//第一种</span><br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    <span class="hljs-comment">//第二种</span><br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    <span class="hljs-comment">//第三种</span><br>    m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    <span class="hljs-comment">//第四种,不建议使用</span><br>    m[<span class="hljs-number">4</span>]=<span class="hljs-number">40</span>;<br>    <span class="hljs-comment">//[]不建议插入，用途可以利用key访问到value</span><br>    cout&lt;&lt;m[<span class="hljs-number">5</span>]&lt;&lt;endl;   <span class="hljs-comment">//如果容器没有这个key值会直接插入该键值实值为0的元素</span><br>    <span class="hljs-built_in">print</span>(m);<br>    <br>    <span class="hljs-comment">//删除</span><br>    m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">print</span>(m);<br>    m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">//按照key删除</span><br>    <span class="hljs-built_in">print</span>(m);<br>    <span class="hljs-comment">//清空</span><br>    <span class="hljs-comment">//m.erase(m.begin(),m.end());</span><br>    m.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">print</span>(m);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h4><p><strong>功能描述</strong>：</p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>find(key);</code>    &#x2F;&#x2F;查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>    &#x2F;&#x2F;统计key的元素个数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;m;<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>,<span class="hljs-number">20</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>,<span class="hljs-number">40</span>));<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator pos=m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span>(pos!=m.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;查到了元素key= &quot;</span>&lt;&lt;pos-&gt;first&lt;&lt;<span class="hljs-string">&quot; value= &quot;</span>&lt;&lt;pos-&gt;second&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到元素&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//统计</span><br>    <span class="hljs-comment">//map不允许插入重复key元素，count统计而言，结果要么0，要么1</span><br>    <span class="hljs-type">int</span> num=m.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;num= &quot;</span>&lt;&lt;num&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map容器排序"><a href="#map容器排序" class="headerlink" title="map容器排序"></a>map容器排序</h4><p><strong>学习目标</strong>：</p><ul><li>map容器默认排序规则为按照key值进行从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点</strong>：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>&#123;<br>        <span class="hljs-comment">//降序</span><br>        <span class="hljs-keyword">return</span> v1&gt;v2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,mycompare&gt;m;<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>,<span class="hljs-number">30</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>,<span class="hljs-number">30</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>,<span class="hljs-number">40</span>));<br>    m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">5</span>,<span class="hljs-number">50</span>));<br>    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;::iterator it=m.<span class="hljs-built_in">begin</span>();it!=m.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;key= &quot;</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; value= &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unordered-map-哈希-容器"><a href="#unordered-map-哈希-容器" class="headerlink" title="unordered_map(哈希)容器"></a>unordered_map(哈希)容器</h3><p><strong>功能描述</strong>：</p><ul><li>是一个底层由哈希表实现的无序容器，可存储若干个键值对，键有唯一性。</li></ul><h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a><strong>常用接口</strong></h4><p><strong>构造函数</strong>：</p><ul><li><code>unordered_map&lt;key_type,val_type&gt; um</code>    &#x2F;&#x2F;key_type为键的类型一般为int型，val_type为存储数据类型</li></ul><p><strong>赋值操作</strong>：</p><ul><li><code>unordered_map&amp; operator=(const unordered_map &amp;um);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><p><strong>数据存取</strong>：</p><ul><li><code>insert(make_pair(key,val))</code>      &#x2F;&#x2F;向哈希表中插入键值对</li></ul><p><strong>数据查找&#x2F;修改</strong>：</p><ul><li><code>count(const key_type&amp; key);</code>     &#x2F;&#x2F;返回键为key的元素个数</li><li><code>find(const key_type&amp; key);</code>      &#x2F;&#x2F;返回键为key的第一个元素，返回迭代器，没找到返回end()</li><li><code>emplace(const key_type&amp; key,const val_type&amp; val);</code>    &#x2F;&#x2F;如果容器中没有对应的键值，则插入一个新元素，如果有，就修改该键值对应的value值</li><li><code>clear();</code>    &#x2F;&#x2F;清除容器中所有元素</li><li><code>iterator erase ( const_iterator position ); </code>  &#x2F;&#x2F;删除指定迭代器的元素</li><li><code>size_type erase ( const key_type&amp; k );</code>       &#x2F;&#x2F;删除指定键值的元素</li><li><code>iterator erase ( const_iterator first, const_iterator last ); </code>    &#x2F;&#x2F;删除指定迭代器范围内的元素</li><li><code>swap(unordered_map&amp; ump);</code>    &#x2F;&#x2F;互相交换两个容器的内容，容器类型必须一致，但大小可以不同</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>   &#x2F;&#x2F;判断哈希表是否为空</li><li><code>size();</code>     &#x2F;&#x2F;返回哈希表的大小</li><li><code>max_size();</code>   &#x2F;&#x2F;返回哈希容器最大容纳数量</li></ul><h2 id="STL-–函数对象"><a href="#STL-–函数对象" class="headerlink" title="STL –函数对象"></a>STL –函数对象</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><h4 id="函数对象概念"><a href="#函数对象概念" class="headerlink" title="函数对象概念"></a>函数对象概念</h4><p><strong>概念</strong>：</p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质</strong>：</p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h4><p><strong>特点</strong>：</p><ul><li>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myadd</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> v1+v2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    myadd a;<br>    cout&lt;&lt;<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myprint</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myprint</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;cnt=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span>&#123;<br>        cout&lt;&lt;test&lt;&lt;endl;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    myprint p;<br>    <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;myprint调用次数为：&quot;</span>&lt;&lt;p.cnt&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doprint</span><span class="hljs-params">(myprint &amp;mp,string test)</span></span>&#123;<br>    <span class="hljs-built_in">mp</span>(test);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>    myprint p;<br>    <span class="hljs-built_in">doprint</span>(p,<span class="hljs-string">&quot;hello C++&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递</li></ul></blockquote><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><h4 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h4><p><strong>概念</strong>：</p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接收一个参数，那么叫做一元谓词</li><li>如果operator()接收两个参数，那么叫做二元谓词</li></ul><h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">greaterfive</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val&gt;<span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//查找容器中有没有大于5的数字</span><br>    <span class="hljs-comment">//greatefive()匿名函数对象</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greaterfive</span>());<br>    <span class="hljs-keyword">if</span>(it==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到了大于5的数字为：&quot;</span>&lt;&lt;*it&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h4><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val1,<span class="hljs-type">int</span> val2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val1&gt;val2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//使用函数对象，改变算法策略，变为降序排序规则</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">mycompare</span>());<br>    cout&lt;&lt;<span class="hljs-string">&quot;---------------------&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><h4 id="内建函数对象意义"><a href="#内建函数对象意义" class="headerlink" title="内建函数对象意义"></a>内建函数对象意义</h4><p><strong>概念</strong>：</p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类</strong>：</p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法</strong>：</p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件<code>#include &lt;functional&gt;</code></li></ul><h4 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h4><p><strong>功能描述</strong>：</p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型</strong>：</p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>        &#x2F;&#x2F;加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>     &#x2F;&#x2F;减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>  &#x2F;&#x2F;乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>   &#x2F;&#x2F;除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>    &#x2F;&#x2F;取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>     &#x2F;&#x2F;取反仿函数</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    negate&lt;<span class="hljs-type">int</span>&gt;n;<br>    cout&lt;&lt;<span class="hljs-built_in">n</span>(<span class="hljs-number">50</span>)&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    plus&lt;<span class="hljs-type">int</span>&gt;p;<br>    cout&lt;&lt;<span class="hljs-built_in">p</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p><strong>功能描述</strong>：</p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型</strong>：</p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>    &#x2F;&#x2F;等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>   &#x2F;&#x2F;不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>    &#x2F;&#x2F;大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>   &#x2F;&#x2F;大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>    &#x2F;&#x2F;小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>    &#x2F;&#x2F;小于等于</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> v1&gt;v2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//降序</span><br>    <span class="hljs-comment">//sort(v.begin(),v.end(),mycompare());</span><br>    <span class="hljs-comment">//使用内建仿函数</span><br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><p><strong>功能描述</strong>：</p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型</strong>：</p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>   &#x2F;&#x2F;逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>    &#x2F;&#x2F;逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>    &#x2F;&#x2F;逻辑非</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">bool</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>    <br>   <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it!=v.<span class="hljs-built_in">end</span>();it++)&#123;<br>       cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>   &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-comment">//利用逻辑非将容器v搬运到容器v2中，并执行取反的操作</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt;v2;<br>    v2.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());<br>    cout&lt;&lt;<span class="hljs-string">&quot;--------------------&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it=v2.<span class="hljs-built_in">begin</span>();it!=v2.<span class="hljs-built_in">end</span>();it++)&#123;<br>       cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>   &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：逻辑仿函数实际应用较少，了解即可</p></blockquote><h2 id="STL-–常用算法"><a href="#STL-–常用算法" class="headerlink" title="STL –常用算法"></a>STL –常用算法</h2><p><strong>概述</strong>：</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;</code>组成</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类，用以声明函数对象</li></ul><h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><p><strong>学习目标</strong>：</p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介</strong>：</p><ul><li><code>for_each</code>    &#x2F;&#x2F;遍历容器</li><li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li></ul><h4 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a>for_each算法</h4><p><strong>功能描述</strong>：</p><ul><li>实现遍历容器</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>for_each(iterator beg,iterator end,_func);</code></p><p>&#x2F;&#x2F;遍历算法  遍历容器元素</p><p>&#x2F;&#x2F;beg开始迭代器</p><p>&#x2F;&#x2F;end结束迭代器</p><p>&#x2F;&#x2F;_func函数或者函数对象</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#incude <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print01</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">print02</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print01);<br>    cout&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">print02</span>());<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：for_each在实际开发中是最常用遍历算法，需要熟练掌握</p></blockquote><h4 id="transform算法"><a href="#transform算法" class="headerlink" title="transform算法"></a>transform算法</h4><p><strong>功能描述</strong>：</p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>transform(iterator beg1,iterator end1,iterator beg2,_func);</code></p><p>&#x2F;&#x2F;beg1 源容器开始迭代器</p><p>&#x2F;&#x2F;end1 源容器结束迭代器</p><p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p><p>&#x2F;&#x2F;_func 函数或者函数对象</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transform</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> v+<span class="hljs-number">1000</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myprint</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;vt;  <span class="hljs-comment">//目标容器</span><br>    vt.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">//目标容器需要提前开辟空间</span><br>    <span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),vt.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">Transform</span>());<br>    for_each(vt.<span class="hljs-built_in">begin</span>(),vt.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">myprint</span>());<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p></blockquote><h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><p><strong>学习目标</strong>：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介</strong>：</p><ul><li><code>find</code>     &#x2F;&#x2F;查找元素</li><li><code>find_if</code>    &#x2F;&#x2F;按条件查找元素</li><li><code>abjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li><li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li><li><code>count</code>       &#x2F;&#x2F;统计元素个数</li><li><code>count_if</code>   &#x2F;&#x2F;按条件统计元素个数</li></ul><h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find 算法"></a>find 算法</h4><p><strong>功能描述</strong>：</p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>find(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;value  查找的元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//查找内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(it==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到：&quot;</span>&lt;&lt;*it&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    <span class="hljs-comment">//重载==号 让底层find知道如何对比person数据类型</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;m_name==p.m_name&amp;&amp;<span class="hljs-keyword">this</span>-&gt;m_age==p.m_age)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-comment">//查找自定义数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Person&gt;v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-number">40</span>)</span></span>;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br>    vector&lt;Person&gt;::iterator it=<span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),p2);<br>    <span class="hljs-keyword">if</span>(it==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到元素 姓名：&quot;</span>&lt;&lt;it-&gt;m_name&lt;&lt;<span class="hljs-string">&quot; 年龄：&quot;</span>&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="find-if-算法"><a href="#find-if-算法" class="headerlink" title="find_if 算法"></a>find_if 算法</h4><p><strong>功能描述</strong>：</p><ul><li>按条件查找元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>find_if(iterator beg,iterator end,_Pred);</code></p><p>&#x2F;&#x2F;按值查找元素，找到返回指定位置的迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;_Pred  函数或者谓词(返回bool类型的仿函数)</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">greaterfive</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val&gt;<span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//查找内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greaterfive</span>());<br>    <span class="hljs-keyword">if</span>(it==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;没有找到&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到大于5的数字为：&quot;</span>&lt;&lt;*it&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string name,<span class="hljs-type">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m_name=name;<br>        <span class="hljs-keyword">this</span>-&gt;m_age=age;<br>    &#125;<br>    string m_name;<br>    <span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">greater20</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Person &amp;p)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> p.m_age&gt;<span class="hljs-number">20</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//查找自定义数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Person&gt;v;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">30</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">40</span>)</span></span>;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    v.<span class="hljs-built_in">push_back</span>(p3);<br>    v.<span class="hljs-built_in">push_back</span>(p4);<br>    vector&lt;Person&gt;::iterator it=<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater20</span>());<br>    <span class="hljs-keyword">if</span>(it==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到姓名：&quot;</span>&lt;&lt;it-&gt;m_name&lt;&lt;<span class="hljs-string">&quot; 年龄：&quot;</span>&lt;&lt;it-&gt;m_age&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="adjacent-find-算法"><a href="#adjacent-find-算法" class="headerlink" title="adjacent_find 算法"></a>adjacent_find 算法</h4><p><strong>功能描述</strong>：</p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>adjacent_find(iterator beg,iterator end);</code></p><p>&#x2F;&#x2F;查找相邻重复元素，返回相邻元素的第一个位置的迭代器</p><p>&#x2F;&#x2F;beg开始迭代器</p><p>&#x2F;&#x2F;end 结束迭代器</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos=<span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span>(pos==v.<span class="hljs-built_in">end</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到相邻重复元素&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到相邻重复元素：&quot;</span>&lt;&lt;*pos&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：面试题中如果出现查找相邻重复元素，记得用STL中的adjacemt_find算法</p></blockquote><p><strong>binary_search 算法</strong></p><p><strong>功能描述</strong>：</p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>bool binary_search(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;查找指定的元素，查到返回true，否则返回false</p><p>&#x2F;&#x2F;<strong>注意</strong>：在<strong>无序序列中不可用</strong></p><p>&#x2F;&#x2F;beg 开始迭代器</p><p>&#x2F;&#x2F;end 结束迭代器</p><p>&#x2F;&#x2F;value 查找的元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//注意：容器必须是有序的序列，如果是无序序列结果未知</span><br>    <span class="hljs-type">bool</span> ret=<span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">9</span>);<br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;找到了元素&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;未找到&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search 算法"></a>binary_search 算法</h4><p><strong>功能描述</strong>：</p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>bool binary_search(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;查找指定的元素，查到返回true，否则false</p><p>&#x2F;&#x2F;<strong>注意</strong>：在<strong>无序序列中不可用</strong></p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;value  查找的元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">//注意：容器必须是有序的序列，如果是无序序列结果未知</span><br><span class="hljs-type">bool</span> ret = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">9</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素&quot;</span> &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：二分查找法查找效率很高，值得注意的是查找的容器中必须是有序序列</p></blockquote><h4 id="count-算法"><a href="#count-算法" class="headerlink" title="count 算法"></a>count 算法</h4><p><strong>功能描述</strong>：</p><ul><li>统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>count(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;统计元素出现次数</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;value  统计的元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//统计内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">40</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;40的元素个数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//统计自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_name = name;<br><span class="hljs-keyword">this</span>-&gt;m_age = age;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Person &amp;p) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_age == p.m_age) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>string m_name;<br><span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;Person&gt;v;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), p6);<br>cout &lt;&lt; <span class="hljs-string">&quot;与f同岁数的人员个数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：统计自定义数据类型时候，需要配合重载<code>operator==</code></p></blockquote><h4 id="count-if-算法"><a href="#count-if-算法" class="headerlink" title="count_if 算法"></a>count_if 算法</h4><p><strong>功能描述</strong>：</p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>count_if(iterator beg,iterator end,_Pred);</code></p><p>&#x2F;&#x2F;按条件统计元素出现次数</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;_Pred  谓词</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">greater20</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">20</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//统计内置数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater20</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;大于20的元素个数为：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_name = name;<br><span class="hljs-keyword">this</span>-&gt;m_age = age;<br>&#125;<br>string m_name;<br><span class="hljs-type">int</span> m_age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">agegreater</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span> </span>&#123;<br><span class="hljs-keyword">return</span> p.m_age &gt; <span class="hljs-number">20</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//统计自定义数据类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;Person&gt;v;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">35</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br>v.<span class="hljs-built_in">push_back</span>(p1);<br>v.<span class="hljs-built_in">push_back</span>(p2);<br>v.<span class="hljs-built_in">push_back</span>(p3);<br>v.<span class="hljs-built_in">push_back</span>(p4);<br>v.<span class="hljs-built_in">push_back</span>(p5);<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">agegreater</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;大于20岁的人员个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p><strong>算法简介</strong>：</p><ul><li><code>sort</code>    &#x2F;&#x2F;对容器内元素进行排序</li><li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌  指定范围内的元素随机调整次序</li><li><code>merge</code>    &#x2F;&#x2F;容器元素合并，并存储到另一个容器</li><li><code>reverse</code>    &#x2F;&#x2F;反转指定范围的元素</li></ul><h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort  算法"></a>sort  算法</h4><p><strong>功能描述</strong>：</p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>sort(iterator beg,iterator end,_Pred);</code></p><p>&#x2F;&#x2F;按值查找元素，找到返回指定值位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;_Pred  谓词</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myprint);<br>cout &lt;&lt; endl;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), myprint);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="random-shuffle-算法"><a href="#random-shuffle-算法" class="headerlink" title="random_shuffle 算法"></a>random_shuffle 算法</h4><p><strong>功能描述</strong>：</p><ul><li>洗牌  指定范围内的元素随机调整次序</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>random_shuffle(iterator beg,iterator end);</code></p><p>&#x2F;&#x2F;指定范围内的元素随机调整次序</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">print</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">print</span>());<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：random_shuffle算法使用时记得加随机数种子</p></blockquote><h4 id="merge-算法"><a href="#merge-算法" class="headerlink" title="merge 算法"></a>merge 算法</h4><p><strong>功能描述</strong>：</p><ul><li>两个容器元素合并，并存储到另一个容器中</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p><p>&#x2F;&#x2F;容器元素合并，并存储到另一容器中</p><p>&#x2F;&#x2F;<strong>注意</strong>：两个容器必须是<strong>有序的</strong></p><p>&#x2F;&#x2F;beg1  容器1开始迭代器</p><p>&#x2F;&#x2F;end1  容器1结束迭代器</p><p>&#x2F;&#x2F;beg2  容器2开始迭代器</p><p>&#x2F;&#x2F;end2  容器2结束迭代器</p><p>&#x2F;&#x2F;dest  目标容器开始迭代器</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//目标容器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-comment">//提前给目标容器分配空间</span><br>    v.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>()+v2.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">merge</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),v.<span class="hljs-built_in">begin</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：merge合并的两个容器必须的有序序列</p></blockquote><h4 id="reverse-算法"><a href="#reverse-算法" class="headerlink" title="reverse 算法"></a>reverse 算法</h4><p><strong>功能描述</strong>：</p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>reverse(iterator beg,iterator end);</code></p><p>&#x2F;&#x2F;反转指定范围的元素</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;反转前：&quot;</span>&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;反转后：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><p><strong>算法简介</strong>：</p><ul><li><code>copy</code>       &#x2F;&#x2F;容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>     &#x2F;&#x2F;将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code>   &#x2F;&#x2F;容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>     &#x2F;&#x2F;互换两个容器的元素</li></ul><h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy 算法"></a>copy 算法</h4><p><strong>功能描述</strong>：</p><ul><li>容器内指定范围的元素拷贝到另一个容器中</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>copy(iterator beg,iterator end,iterator dest);</code></p><p>&#x2F;&#x2F;按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;dest  目标容器开始迭代器</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    v2.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>());<br>    for_each(v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replace-算法"><a href="#replace-算法" class="headerlink" title="replace 算法"></a>replace 算法</h4><p><strong>功能描述</strong>：</p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>replace(iterator beg,iterator end,oldvalue,newvalue);</code></p><p>&#x2F;&#x2F;将区间内旧元素替换成新元素</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;oldvalue  旧元素</p><p>&#x2F;&#x2F;newvalue  新元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">print</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;替换前：&quot;</span>&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">print</span>());<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">20</span>,<span class="hljs-number">2000</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;替换后：&quot;</span>&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">print</span>());<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replace-if-算法"><a href="#replace-if-算法" class="headerlink" title="replace_if 算法"></a>replace_if 算法</h4><p><strong>功能描述</strong>：</p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>replace_if(iterator beg,iterator end,_pred,newvalue);</code></p><p>&#x2F;&#x2F;按条件替换元素，满足条件的替换成指定元素</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;_pred  谓词</p><p>&#x2F;&#x2F;newvalue  替换的新元素</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">greater30</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val&gt;=<span class="hljs-number">30</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;替换前：&quot;</span>&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">greater30</span>(),<span class="hljs-number">3000</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;替换后：&quot;</span>&lt;&lt;endl;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="swap-算法"><a href="#swap-算法" class="headerlink" title="swap 算法"></a>swap 算法</h4><p><strong>功能描述</strong>：</p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>swap(container c1,container c2);</code></p><p>&#x2F;&#x2F;互换两个容器的元素</p><p>&#x2F;&#x2F;c1容器1</p><p>&#x2F;&#x2F;c2容器2</p></li></ul><p><strong>注意</strong>：</p><ul><li>必须是同种容器才能交换</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">100</span>);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换前：&quot;</span>&lt;&lt;endl;<br>    for_each(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>    for_each(v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;交换后：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(v1,v2);<br>    for_each(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>    for_each(v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><p><strong>注意</strong>：</p><ul><li>算术生成算法属于小型算法，使用时包含头文件为<code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介</strong>：</p><ul><li><code>accumulate</code>    &#x2F;&#x2F;计算容器元素累计总和</li><li><code>fill</code>     &#x2F;&#x2F;向容器种添加元素</li></ul><h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate 算法"></a>accumulate 算法</h4><p><strong>功能描述</strong>：</p><ul><li>计算区间内容器元素累计总和</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>accumulate(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;计算容器元素累计总和</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;value  起始值</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//value 是起始的累加值</span><br>    <span class="hljs-type">int</span> total=<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;total = &quot;</span>&lt;&lt;total&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fill-算法"><a href="#fill-算法" class="headerlink" title="fill 算法"></a>fill 算法</h4><p><strong>功能描述</strong>：</p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>fill(iterator beg,iterator end,value);</code></p><p>&#x2F;&#x2F;向容器中填充元素</p><p>&#x2F;&#x2F;beg  开始迭代器</p><p>&#x2F;&#x2F;end  结束迭代器</p><p>&#x2F;&#x2F;value  填充的值</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//后期重新填充</span><br>    <span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),<span class="hljs-number">100</span>);<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><p><strong>算法简介</strong>：</p><ul><li><code>set_intersection</code>      &#x2F;&#x2F;求两个容器的并集</li><li><code>set_union</code>       &#x2F;&#x2F;求两个容器的并集</li><li><code>set_difference</code>       &#x2F;&#x2F;求两个容器的差集</li></ul><h4 id="set-intersection-算法"><a href="#set-intersection-算法" class="headerlink" title="set_intersection 算法"></a>set_intersection 算法</h4><p><strong>功能描述</strong>：</p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>set_intersection(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p><p>&#x2F;&#x2F;求两个集合的交集</p><p>&#x2F;&#x2F;beg1  容器1开始迭代器</p><p>&#x2F;&#x2F;end1  容器1结束迭代器</p><p>&#x2F;&#x2F;beg2  容器2开始迭代器</p><p>&#x2F;&#x2F;end2  容器2结束迭代器</p><p>&#x2F;&#x2F;dest  目标容器开始迭代器</p></li></ul><p><strong>注意事项</strong>：</p><ul><li><em>两个集合必须是有序序列</em></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(),v2.<span class="hljs-built_in">size</span>()));<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">set_intersection</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),v.<span class="hljs-built_in">begin</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(),it,print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>求交集的两个集合必须是有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值即是交集中最后一个元素的位置</li></ul></blockquote><h4 id="set-union-算法"><a href="#set-union-算法" class="headerlink" title="set_union 算法"></a>set_union 算法</h4><p><strong>功能描述</strong>：</p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>set_union(iterator beg1,itertaor end1,iterator beg2,iterator end2,iterator dest);</code></p><p>&#x2F;&#x2F;求两个集合的并集</p><p>&#x2F;&#x2F;beg1  容器1开始迭代器</p><p>&#x2F;&#x2F;end1  容器1结束迭代器</p><p>&#x2F;&#x2F;beg2  容器2开始迭代器</p><p>&#x2F;&#x2F;end2  容器2结束迭代器</p><p>&#x2F;&#x2F;dest  目标容器开始迭代</p></li></ul><p><strong>注意事项</strong>：</p><ul><li><em>两个集合必须是有序序列</em></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>    &#125;<br>    v.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>()+v2.<span class="hljs-built_in">size</span>());<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">set_union</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),v.<span class="hljs-built_in">begin</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(),it,print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>求并集的两个集合必须是有序序列</li><li>目标容器开辟空间需要从<strong>两个容器大小相加</strong></li><li>set_union返回值即是并集中最后一个元素的位置</li></ul></blockquote><h4 id="set-difference-算法"><a href="#set-difference-算法" class="headerlink" title="set_difference 算法"></a>set_difference 算法</h4><p><strong>功能描述</strong>：</p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型</strong>：</p><ul><li><p><code>set_difference(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p><p>&#x2F;&#x2F;求两个集合的差集</p><p>&#x2F;&#x2F;beg1  容器1开始迭代器</p><p>&#x2F;&#x2F;end1  容器1结束迭代器</p><p>&#x2F;&#x2F;beg2  容器2开始迭代器</p><p>&#x2F;&#x2F;end2  容器2结束迭代器</p><p>&#x2F;&#x2F;dest  目标容器开始迭代器</p></li></ul><p><strong>注意事项</strong>：</p><ul><li><em>两个集合必须是有序序列</em></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout&lt;&lt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v1;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v2;<br>    vector&lt;<span class="hljs-type">int</span>&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>        v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>    &#125;<br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>(),v2.<span class="hljs-built_in">size</span>()));<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=<span class="hljs-built_in">set_difference</span>(v1.<span class="hljs-built_in">begin</span>(),v1.<span class="hljs-built_in">end</span>(),v2.<span class="hljs-built_in">begin</span>(),v2.<span class="hljs-built_in">end</span>(),v.<span class="hljs-built_in">begin</span>());<br>    for_each(v.<span class="hljs-built_in">begin</span>(),it,print);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>总结</strong>：</p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器大小取大值</strong></li><li>set_difference返回值即是差集中最后一个元素的位置</li></ul></blockquote><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>概念</strong>：</p><ul><li>异常就是错误，而在程序中难免会有异常出现，但为了让程序正常运行而不是崩溃，则需要使用到异常处理，来解决</li><li>传统的异常处理是通过判断返回值来判断程序是否异常。</li><li>c++中提供了try、catch、throw的异常处理表达式。</li></ul><p><strong>函数</strong>：</p><ul><li><p><code>throw 表达式</code>   throw语句<strong>用来抛出异常</strong>，当有异常发生时，可以通过<strong>throw创建一个异常对象并抛掷</strong>。</p></li><li><p><code>try&#123;复合语句&#125; catch(异常声明)&#123;异常处理程序&#125;</code>   try内部的异常语句是保护段语句，<strong>当try内部的程序出现异常，则catch子句就会根据异常不同进行捕获异常，然后执行相对应的异常处理程序</strong>。如果出现异常但是catch子句<strong>未匹配到异常，则库函数terminate将被自动调用，默认是调用abort终止程序</strong>。当<strong>捕获异常并执行catch子句的时候则会自动帮你将try语块中的执行了尚未析构的语句析构了</strong>。</p></li></ul><p><strong>异常声明：</strong></p><ul><li><p>可以在函数的声明中列出这个函数可能抛掷的所有异常类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(A,B,C,D)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>若无异常接口声明，则此函数可以抛掷任何类型的异常</p></li><li><p>不抛掷任何类型异常的函数声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>或者：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;   <span class="hljs-comment">//这个c++推荐使用</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>异常类</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009281.png" alt="image"></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><strong>概念</strong>：</p><ul><li>智能指针是原始指针的封装，其优点是会<strong>自动分配内存</strong>，不用担心潜在的内存泄露</li></ul><p><strong>普通指针的不足</strong>：</p><ul><li>new和new[]的内存需要用delete和delete[]释放</li><li>程序员的主观失误，忘了或漏了释放</li><li>程序员也不确定何时释放</li></ul><p><strong>智能指针的设计思路</strong>：</p><ul><li>智能指针是类模板，在栈上创建智能指针对象</li><li>把<strong>普通指针交给智能指针对象</strong></li><li>智能指针对象过期时，调用析构函数释放普通指针的内存</li></ul><h3 id="独占指针-unique-ptr"><a href="#独占指针-unique-ptr" class="headerlink" title="独占指针  unique_ptr"></a>独占指针  unique_ptr</h3><p><strong>概念</strong>：</p><ul><li><code>unique_ptr</code>**独享一个原始指针(也就是unique_ptr指向的对象)**，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁</li></ul><p><strong>源码简介</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> D =default_delete&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> unique_ptr&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">unique_ptr</span>(pointer p) <span class="hljs-keyword">noexcept</span>;   <span class="hljs-comment">//不可用于转换函数</span><br>    ~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span>;<br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;    <span class="hljs-comment">//重载*操作符</span><br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">//重载-&gt;运算符</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;)=<span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//禁用拷贝构造函数</span><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr &amp;)=<span class="hljs-keyword">delete</span>;    <span class="hljs-comment">//禁用赋值函数</span><br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr &amp;&amp;) <span class="hljs-keyword">noexcept</span>;     <span class="hljs-comment">//右值引用</span><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp;) <span class="hljs-keyword">noexcept</span>;    <span class="hljs-comment">//右值引用</span><br>    <span class="hljs-comment">//...</span><br><span class="hljs-keyword">private</span>:<br>    pointer ptr;  <span class="hljs-comment">//内置的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能描述</strong>：</p><ul><li>在任何给定时候，<strong>只能有一个指针管理内存(也就是独占指针对象只管理一个指针资源)</strong></li><li>当指针超出作用域时，内存将自动释放</li><li><strong>unique_ptr指针不可Copy，也不可以进行赋值,只可以Move</strong></li><li>可以通过<strong>get()获取裸指针地址</strong>(<strong>&amp;unique_ptr对象得到的是对象指针地址</strong>不是裸指针)</li><li>可以通过-&gt;调用成员函数</li><li>可以通过*调用dereferencing</li></ul><p><strong>作为函数的参数</strong>：</p><ul><li><strong>传引用</strong>(<strong>不能传值</strong>，因为unique_ptr没有拷贝构造函数)</li><li><strong>裸指针</strong></li></ul><p><strong>注意</strong>：</p><ul><li><strong>不要用同一个裸指针初始化多个unique_ptr对象</strong></li><li><strong>不要用unique_ptr管理不是new分配的内存</strong></li><li><strong>不支持指针的运算(+、-、++、–)</strong></li></ul><p>**创建方式(初始化)**：</p><ul><li><p>通过<strong>已有裸指针</strong>创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br>  ....  <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    AA* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>    unique_ptr&lt;AA&gt; pu1=p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>new来创建</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明&quot;</span>))</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>std::make_unique创建</strong>(推荐)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;AA&gt; pu1=<span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//C++14标准</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>内置函数和使用方法</strong>：</p><ol><li><p><code>get()</code>：获取裸指针的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;<span class="hljs-type">int</span>&gt; p1=<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>cout&lt;&lt;p1.<span class="hljs-built_in">get</span>()&lt;&lt;endl;  <span class="hljs-comment">//0x6498f94942b0</span><br></code></pre></td></tr></table></figure></li><li><p><code>release()</code>：<strong>释放对原始指针的控制权</strong>，将unique_ptr对象置为空，<strong>返回裸指针地址</strong>(之前管理的指针地址)。可用于把unique_ptr传递给子函数，子函数将负责释放对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;<span class="hljs-type">int</span>&gt; p1=<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>cout&lt;&lt;p1.<span class="hljs-built_in">release</span>()&lt;&lt;endl;    <span class="hljs-comment">//0x5fb45e2472b0</span><br><span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">nullptr</span>) cout&lt;&lt;<span class="hljs-string">&quot;p1为空&quot;</span>&lt;&lt;endl;     <span class="hljs-comment">//p1为空</span><br></code></pre></td></tr></table></figure></li><li><p><code>std::move()</code>：<strong>转移对原始指针的控制权</strong>。(可用于把unique_ptr传递给子函数，子函数形参也是unique_ptr，传值的方法)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数func4()需要一个unique_ptr对象，并且会对这个对象负责</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(unique_ptr&lt;AA&gt; a)</span></span>&#123;<br>    cout&lt;&lt;a-&gt;m_name&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明&quot;</span>))</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;开始调用函数.\n&quot;</span>;<br>    <span class="hljs-built_in">func4</span>(std::<span class="hljs-built_in">move</span>(p));   <span class="hljs-comment">//将原始指针的控制权交给func4函数的形参</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;调用函数完成.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>reset()</code>：<strong>释放unique_ptr指向资源，以及更改指向</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* _ptr=(T*)<span class="hljs-literal">nullptr</span>)</span></span>;<br>unique_ptr&lt;AA&gt;<span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小明&quot;</span>));<br>p.<span class="hljs-built_in">reset</span>();   <span class="hljs-comment">//释放p对象所指向的资源对象</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);   <span class="hljs-comment">//释放p对象所指向的资源对象</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小蓝&quot;</span>));   <span class="hljs-comment">//释放p所指向对象，并指向新的对象</span><br></code></pre></td></tr></table></figure></li><li><p><code>swap()</code>：<strong>交换两个unique_ptr所指向的对象的控制权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_ptr&lt;T&gt;&amp;_Right)</span></span>;<br><br>unique_ptr&lt;AA&gt;<span class="hljs-built_in">p1</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小明&quot;</span>));<br>unique_ptr&lt;AA&gt;<span class="hljs-built_in">p2</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小红&quot;</span>));<br>p1.<span class="hljs-built_in">swap</span>(p2);<br>cout&lt;&lt;p1-&gt;m_name&lt;&lt;endl;<br>cout&lt;&lt;p2-&gt;m_name&lt;&lt;endl;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//小红</span><br><span class="hljs-comment">//小明</span><br></code></pre></td></tr></table></figure></li><li><p><code>[]</code>：unique_ptr重载了操作符[]，<strong>提供了支持数组的具体化版本</strong>，操作符[]<strong>返回的是引用，可以作为左值</strong></p><p><strong>使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//unique_ptr&lt;int[]&gt; parr1(new int[3]);  //不指定初始值</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">parr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>](<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span>))</span></span>;  <span class="hljs-comment">//指定初始值</span><br>cout&lt;&lt;<span class="hljs-string">&quot;parr1[0]=&quot;</span>&lt;&lt;parr1[<span class="hljs-number">0</span>]&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;parr1[1]=&quot;</span>&lt;&lt;parr1[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;parr1[2]=&quot;</span>&lt;&lt;parr1[<span class="hljs-number">2</span>]&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ol><p><strong>使用技巧</strong>：</p><ol><li><p>如果<strong>源unique_ptr对象是一个临时右值(一般是函数的返回值)，编译器允许将这个unique_ptr赋给另一个unique_ptr对象</strong>。如果源unique_ptr将存在一段时间，则编译器不允许赋值！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">func</span>()&#123;<br><br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; pp=<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> pp;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; p1=<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; p2;<br>    p2=p1;   <span class="hljs-comment">//错误,不可以</span><br><br>    p2=<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>));   <span class="hljs-comment">//使用匿名对象赋值,可以</span><br>    p1=<span class="hljs-built_in">func</span>();    <span class="hljs-comment">//利用函数返回值赋值，可以</span><br>    std::cout&lt;&lt;*p1&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p><strong>用nullptr给unique_ptr赋值将会释放对象，空的unique_ptr&#x3D;&#x3D;nullptr</strong></p><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190009282.png" alt="image-20240417141128949"></p></li><li><p>一些情况使用技巧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//函数func1()需要一个原始指针，但不对指针负责</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">const</span> AA* a)</span></span>&#123;<br>    cout&lt;&lt;a-&gt;m_name&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//函数func2()需要一个裸指针，并且对这个指针负责</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(AA* a)</span></span>&#123;<br>    cout&lt;&lt;a-&gt;m_name&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> a;<br>&#125;<br><br><span class="hljs-comment">//函数func3()需要一个unique_ptr对象,不会对这个对象负责</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-type">const</span> unique_ptr&lt;AA&gt; &amp;a)</span></span>&#123;<br>    cout&lt;&lt;a-&gt;m_name&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//函数func4()需要一个unique_ptr对象，并且会对这个对象负责</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(unique_ptr&lt;AA&gt; a)</span></span>&#123;<br>    cout&lt;&lt;a-&gt;m_name&lt;&lt;endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明&quot;</span>))</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;开始调用函数.\n&quot;</span>;<br>    <span class="hljs-built_in">func1</span>(p.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-built_in">func2</span>(p.<span class="hljs-built_in">release</span>());<br>    <span class="hljs-built_in">func3</span>(p);<br>    <span class="hljs-built_in">func4</span>(std::<span class="hljs-built_in">move</span>(p));<br>    cout&lt;&lt;<span class="hljs-string">&quot;调用函数完成.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>unique_ptr</strong>也可以像普通指针一样，当指向一个类继承体系的基类对象时，<strong>也具有多态性质</strong>，如同使用裸指针管理基类对象和派生类对象那样</p></li><li><p><strong>unique_ptr不是绝对安全</strong>，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明全局&quot;</span>))</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明局部&quot;</span>))</span></span>;<br>    <span class="hljs-comment">//return 0;  使用return全部自动释放</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">//局部无法进行释放</span><br>&#125;<br><span class="hljs-comment">//打印日志</span><br>|| 调用构造函数<span class="hljs-built_in">AA</span>(小明全局).<br>|| 调用构造函数<span class="hljs-built_in">AA</span>(小明局部).<br>|| 调用了析构函数~<span class="hljs-built_in">AA</span>(小明全局).<br>|| Exited with code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="共享指针-shared-ptr"><a href="#共享指针-shared-ptr" class="headerlink" title="共享指针 shared_ptr"></a>共享指针 shared_ptr</h3><p><strong>概念</strong>：</p><ul><li><code>shared_ptr</code><strong>共享它指向的对象，多个shared_ptr可以指向(关联)相同的对象，在内部采用计数机制来实现</strong>,共享不是复制，资源只有一个</li><li>当<strong>新的shared_ptr与对象关联</strong>时，<strong>引用计数增加1</strong></li><li>当<strong>shared_ptr超出作用域</strong>时，<strong>引用计数减1</strong>。</li><li>当<strong>引用计数为0</strong>时，则表示没有任何shared_ptr与对象相联，则<strong>释放该对象</strong></li></ul><p><strong>基本用法：</strong></p><p>注：shared_ptr的构造函数也是explicit，但是，<strong>没有删除拷贝构造函数和赋值函数</strong></p><ol><li><p><code>初始化</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法1：</span><br><span class="hljs-function">shared_ptr <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明&quot;</span>))</span></span>;  <span class="hljs-comment">//分配内存并初始化</span><br><br><span class="hljs-comment">//方法2[推荐]:</span><br>shared_ptr p=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);  <span class="hljs-comment">//C++11标准，效率更高</span><br><br><span class="hljs-comment">//方法3：</span><br>AA* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p0</span><span class="hljs-params">(p)</span></span>;   <span class="hljs-comment">//用已存在的裸指针初始化</span><br><br><span class="hljs-comment">//方法4：</span><br><span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p0</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;小明&quot;</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(p0)</span></span>;    <span class="hljs-comment">//用已存在的shared_ptr初始化，计数加1</span><br>shared_ptr&lt;AA&gt; p2=p0;   <span class="hljs-comment">//用已存在的shared_ptr初始化，计数加1</span><br></code></pre></td></tr></table></figure></li><li><p><code>use_count()</code>：<strong>显示shared_ptr所指向的资源引用次数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(p0)</span></span>;<br>shared_ptr&lt;AA&gt; p2=p0;<br>cout&lt;&lt;p0.<span class="hljs-built_in">use_count</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure></li><li><p><code>get()</code>：<strong>显示shared_ptr所指向的资源地址</strong></p></li><li><p><code>unique()</code>：<strong>判断shared_ptr所指向的资源是否被其他shared_ptr对象所共享</strong>，如果use.count()为1，返回true，否则返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(p0)</span></span>;<br>shared_ptr&lt;AA&gt; p2=p0;<br>cout&lt;&lt;p0.<span class="hljs-built_in">unique</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">//0</span><br>shared_ptr&lt;AA&gt; p3=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;111&quot;</span>);<br>cout&lt;&lt;p3.<span class="hljs-built_in">unique</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure></li><li><p><code>=</code>：shared_ptr重载了&#x3D;操作符，<strong>支持赋值，</strong>因为将右值shared_ptr赋值给了左值shared_ptr，因此<strong>右值shared_ptr所指向资源计数+1,则左值shared_ptr所指向资源计数-1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);<br>    <span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(p0)</span></span>;<br>    shared_ptr&lt;AA&gt; p2=p0;<br>    shared_ptr&lt;AA&gt; p3=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;111&quot;</span>);<br>    shared_ptr&lt;AA&gt; p4=p3;<br>    shared_ptr&lt;AA&gt; p5=p3;<br>    p2=p5;   <span class="hljs-comment">//p3+1,p0-1</span><br>    cout&lt;&lt;p0.<span class="hljs-built_in">use_count</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;   <span class="hljs-comment">//2</span><br>    cout&lt;&lt;p3.<span class="hljs-built_in">use_count</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;   <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>[]</code>：shared_ptr重载了操作符[]，<strong>提供了支持数组的具体化版本</strong>，操作符[]<strong>返回的是引用，可以作为左值</strong></p><p><strong>使用</strong></p></li><li><p><code>std::move()</code>：可以将转移对原始指针的控制权，<strong>还可以将unique_ptr转移成shared_ptr(反过来不行)</strong></p></li><li><p><code>reset()</code>：<strong>改变与资源的关联关系，以及指向</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;AA&gt; p=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);<br>p.<span class="hljs-built_in">reset</span>();    <span class="hljs-comment">//解除与资源的关系，资源的引用计数减1</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">&quot;111&quot;</span>));   <span class="hljs-comment">//解除与资源的关系，原资源的引用计数-1,关联新的资源，新资源引用计数+1</span><br></code></pre></td></tr></table></figure></li><li><p><code>swap()</code>：<strong>交换两个shared_ptr的控制权</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(shared_ptr&lt;T&gt; &amp;_Right)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><p><strong>作为函数的参数</strong>：</p><ul><li><strong>传引用</strong>(<strong>不能传值</strong>，因为unique_ptr没有拷贝构造函数)</li><li><strong>裸指针</strong></li></ul><p><strong>注意</strong>：</p><ul><li><strong>不要用同一个裸指针初始化多个shared_ptr对象</strong></li><li><strong>不要用shared_ptr管理不是new分配的内存</strong></li><li><strong>不支持指针的运算(+、-、++、–)</strong></li></ul><p><strong>使用技巧</strong>：</p><ol><li><strong>用nullptr给shared_ptr赋值时将计数减1</strong>,如果计数为0，将释放对象，空的shared_ptr&#x3D;&#x3D;nullptr</li><li><strong>shared_ptr</strong>也可以像普通指针一样，当指向一个类继承体系的基类对象时，<strong>也具有多态性质</strong>，如同使用裸指针管理基类对象和派生类对象那样</li><li><strong>shared_ptr不是绝对安全</strong>，如果程序中调用exit()退出，<strong>全局的shared_ptr可以自动释放，但局部的shared_ptr无法释放</strong></li><li>如果unique_ptr能解决问题，就不要在用shared_ptr，<strong>unique_ptr的效率更高，占用的资源更少</strong></li></ol><p><strong>shared_ptr的线程安全性</strong>：</p><ul><li>shared_ptr的<strong>引用计数本身是线程安全</strong>(引用计数是原子操作)</li><li><strong>多个线程同时读同一个shared_ptr对象是线程安全的</strong></li><li>如果<strong>多个线程对同一个shared_ptr对象进行读和写，则需要加锁</strong></li><li><strong>多线程读写shared_ptr所指向的同一个对象</strong>，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也<strong>需要加锁保护</strong></li></ul><p><strong>shared_ptr存在问题</strong>：</p><ul><li>shared_ptr内部维护一个共享的引用计数器，多个shared_ptr可以指向同一个资源</li><li>如果<strong>出现了循环引用</strong>的情况，<strong>引用计数永远无法归0，资源不会被释放</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用BB类资源</span><br>    shared_ptr&lt;BB&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">BB</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用AA资源</span><br>    shared_ptr&lt;AA&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明1&quot;</span>);   <br>    shared_ptr&lt;BB&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;BB&gt;(<span class="hljs-string">&quot;小明2&quot;</span>);<br>    <span class="hljs-comment">//循环引用</span><br>    p0-&gt;m_p=p1;<br>    p1-&gt;m_p=p0;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>|| 调用构造函数<span class="hljs-built_in">AA</span>(小明<span class="hljs-number">1</span>).<br>|| 调用构造函数<span class="hljs-built_in">BB</span>(小明<span class="hljs-number">2</span>).<br>|| Exited with code <span class="hljs-number">0</span><br><span class="hljs-comment">//没有调用析构函数</span><br></code></pre></td></tr></table></figure><h3 id="智能指针删除器"><a href="#智能指针删除器" class="headerlink" title="智能指针删除器"></a>智能指针删除器</h3><p><strong>概念</strong>：</p><ul><li>在默认情况下，智能指针过期时，它会自动调用缺省的删除器来删除资源</li><li><strong>程序员可以自定义删除器</strong>，改变智能指针释放资源的行为</li><li><strong>删除器可以是全局函数、仿函数和Lambda表达式，形参为原始指针</strong></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//删除器,普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletefunc</span><span class="hljs-params">(AA* a)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;自定义删除器(全局函数)。\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> a;<br>&#125;<br><br><span class="hljs-comment">//删除器，仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">deleteclass</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(AA* a)</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;自定义删除器(仿函数).\n&quot;</span>;<br>        <span class="hljs-keyword">delete</span> a;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//删除器,Lambda表达式</span><br><span class="hljs-keyword">auto</span> deletelamb=[](AA* a)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;自定义删除器(Lambda).\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//使用缺省的删除器</span><br>    <br>    <span class="hljs-comment">//shared_ptr自定义删除器</span><br>    <span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deletefunc)</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deleteclass())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;AA&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deletelamb)</span></span>;<br><br>    <span class="hljs-comment">//unique_ptr自定义删除器</span><br>    <span class="hljs-function">unique_ptr&lt;AA,<span class="hljs-title">decltype</span><span class="hljs-params">(deletefunc)</span>*&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deletefunc)</span></span>;  <span class="hljs-comment">//模板参数使用了decltype推导，也可以直接写</span><br>    <span class="hljs-comment">//unique_ptr&lt;AA,void(*)(AA*)&gt; pu1(new AA(&quot;111&quot;),deletefunc);</span><br>    <span class="hljs-function">unique_ptr&lt;AA,deleteclass&gt; <span class="hljs-title">pu2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deleteclass())</span></span>;<br>    <span class="hljs-function">unique_ptr&lt;AA,<span class="hljs-title">decltype</span><span class="hljs-params">(deletelamb)</span>&gt; <span class="hljs-title">pu3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;111&quot;</span>),deletelamb)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="弱智能指针-weak-ptr"><a href="#弱智能指针-weak-ptr" class="headerlink" title="弱智能指针 weak_ptr"></a>弱智能指针 weak_ptr</h3><p><strong>引言</strong>：为了解决shared_ptr循环引用带来的未自动清理的情况，C++还引入了weak_ptr指针来帮助shared_ptr解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将循环引用的shared_ptr改成使用weak_ptr可以解决问题</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用BB类资源</span><br>    weak_ptr&lt;BB&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">BB</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用AA资源</span><br>    weak_ptr&lt;AA&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明1&quot;</span>);   <br>    shared_ptr&lt;BB&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;BB&gt;(<span class="hljs-string">&quot;小明2&quot;</span>);<br>    <span class="hljs-comment">//循环引用</span><br>    p0-&gt;m_p=p1;<br>    p1-&gt;m_p=p0;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>|| 调用构造函数<span class="hljs-built_in">AA</span>(小明<span class="hljs-number">1</span>).<br>|| 调用构造函数<span class="hljs-built_in">BB</span>(小明<span class="hljs-number">2</span>).<br>|| 调用了析构函数~<span class="hljs-built_in">BB</span>(小明<span class="hljs-number">2</span>).<br>|| 调用了析构函数~<span class="hljs-built_in">AA</span>(小明<span class="hljs-number">1</span>).<br>|| Exited with code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>概念</strong>：</p><ul><li><code>weak_ptr</code>是为了<strong>配合shared_ptr而引入的</strong>，它指向一个由shared_ptr管理的资源但不影响资源的生命周期，也就是说，<strong>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数</strong></li><li><strong>不论是否有weak_ptr指向，如果最后一个指向资源的shared_ptr被销毁，资源就会被释放</strong></li><li>weak_ptr更像是shared_ptr的助手而不是智能指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AA</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~AA(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用BB类资源</span><br>    weak_ptr&lt;BB&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BB</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    string m_name;<br>    <span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB().\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">BB</span>(<span class="hljs-type">const</span> string &amp;name):<span class="hljs-built_in">m_name</span>(name)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用构造函数BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">BB</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用了析构函数~BB(&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="hljs-string">&quot;).\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//引用AA资源</span><br>    weak_ptr&lt;AA&gt; m_p;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明1&quot;</span>);   <br>    shared_ptr&lt;BB&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;BB&gt;(<span class="hljs-string">&quot;小明2&quot;</span>);<br>    <br>    cout&lt;&lt;p0.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>    cout&lt;&lt;p1.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>    <span class="hljs-comment">//循环引用</span><br>    p0-&gt;m_p=p1;<br>    p1-&gt;m_p=p0;<br><br>    cout&lt;&lt;p0.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>    cout&lt;&lt;p1.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>|| 调用构造函数<span class="hljs-built_in">AA</span>(小明<span class="hljs-number">1</span>).<br>|| 调用构造函数<span class="hljs-built_in">BB</span>(小明<span class="hljs-number">2</span>).<br>|| <span class="hljs-number">1</span><br>|| <span class="hljs-number">1</span><br>|| <span class="hljs-number">1</span><br>|| <span class="hljs-number">1</span><br>|| 调用了析构函数~<span class="hljs-built_in">BB</span>(小明<span class="hljs-number">2</span>).<br>|| 调用了析构函数~<span class="hljs-built_in">AA</span>(小明<span class="hljs-number">1</span>).<br>|| Exited with code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>基本用法</strong>：</p><ul><li><code>operator=();</code>：重载了&#x3D;操作符，可以<strong>将shared_ptr或weak_ptr赋值给weak_ptr</strong></li><li><code>expired()</code>：<strong>判断weak_ptr所指资源是否过期</strong>(是否被销毁)</li><li><code>lock()</code>：<strong>将weak_ptr升级成shared_ptr</strong>，如果<strong>指向资源存在</strong>，将weak_ptr升级成shared_ptr，<strong>返回shared_ptr</strong>；如果<strong>资源已过期</strong>，<strong>返回空的shared_ptr</strong></li><li><code>reset()</code>：将当前weak_ptr指针置为空</li><li><code>swap()</code>：交换两个weak_ptr控制权</li></ul><p><strong>注意</strong>：</p><ul><li>weak_ptr不控制对象的生命周期，但是它可以知道对象是否还活着</li><li><strong>lock()函数是线程安全的，因为它是一个原子操作的</strong>(对于多线程最好使用lock而不是expired)</li></ul><p>(多线程)错误做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明1&quot;</span>);<br>    &#123;<br><br>        shared_ptr&lt;BB&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;BB&gt;(<span class="hljs-string">&quot;小明2&quot;</span>);<br>    <br>        p0-&gt;m_p=p1;<br>        p1-&gt;m_p=p0;<br>        <br>        <span class="hljs-keyword">if</span>(p0-&gt;m_p.<span class="hljs-built_in">expired</span>()) cout&lt;&lt;<span class="hljs-string">&quot;语句块内部：p0-&gt;m_p已过期.\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;语句块内部：p0-&gt;m_p.lock()-&gt;m_name&quot;</span>&lt;&lt;p0-&gt;m_p.<span class="hljs-built_in">lock</span>()-&gt;m_name&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(p0-&gt;m_p.<span class="hljs-built_in">expired</span>()) cout&lt;&lt;<span class="hljs-string">&quot;语句块外部：p0-&gt;m_p已过期.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;语句块外部：p0-&gt;m_p.lock()-&gt;m_name&quot;</span>&lt;&lt;p0-&gt;m_p.<span class="hljs-built_in">lock</span>()-&gt;m_name&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(多线程)正确做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;AA&gt; p0=<span class="hljs-built_in">make_shared</span>&lt;AA&gt;(<span class="hljs-string">&quot;小明1&quot;</span>);<br>    &#123;<br><br>        shared_ptr&lt;BB&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;BB&gt;(<span class="hljs-string">&quot;小明2&quot;</span>);<br>    <br>        p0-&gt;m_p=p1;<br>        p1-&gt;m_p=p0;<br>        <br>        shared_ptr&lt;BB&gt; pp=p0-&gt;m_p.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">//把weak_ptr提升为shared_ptr</span><br>        <span class="hljs-keyword">if</span>(pp==<span class="hljs-literal">nullptr</span>) cout&lt;&lt;<span class="hljs-string">&quot;语句块内部：p0-&gt;m_p已过期.\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;语句块内部：pp-&gt;m_name=&quot;</span>&lt;&lt;pp-&gt;m_name&lt;&lt;endl;<br>    &#125;<br><br>    shared_ptr&lt;BB&gt; pp=p0-&gt;m_p.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(pp==<span class="hljs-literal">nullptr</span>) cout&lt;&lt;<span class="hljs-string">&quot;语句块外部：p0-&gt;m_p已过期.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;语句块外部：pp-&gt;m_name=&quot;</span>&lt;&lt;pp-&gt;m_name&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/19/hello-world/"/>
    <url>/2024/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
