

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190208396.jpg">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190208396.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta name="google-site-verification" content="AjiazagGb4CIlb9bWWd66wgpHJ5-hhpbR58p3yYikbE" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Moon">
  <meta name="keywords" content="">
  
    <meta name="description" content="讲解在Linux下进行编程，讲解Linux系统调用函数，以及Linux系统知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="https://moonfordream.github.io/posts/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Moon&#39;s Blog">
<meta property="og:description" content="讲解在Linux下进行编程，讲解Linux系统调用函数，以及Linux系统知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016853.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016854.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016855.png">
<meta property="article:published_time" content="2024-05-19T07:07:16.000Z">
<meta property="article:modified_time" content="2024-10-02T05:48:34.005Z">
<meta property="article:author" content="Moon">
<meta property="article:tag" content="后台开发">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016853.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Linux系统编程 - Moon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/selection.css">
<link rel="stylesheet" href="/css/mk.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"moonfordream.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Moon&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190159278.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux系统编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-19 15:07" pubdate>
          2024年5月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          209 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Linux"
        id="heading-edc9f0a5a5d57797bf68e37364743831" role="tab" data-toggle="collapse" href="#collapse-edc9f0a5a5d57797bf68e37364743831"
        aria-expanded="true"
      >
        Linux
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-edc9f0a5a5d57797bf68e37364743831"
           role="tabpanel" aria-labelledby="heading-edc9f0a5a5d57797bf68e37364743831">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/posts/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Linux系统编程</span>
        </a>
      
    
      
      
        <a href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Linux网络编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Linux网络编程</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Linux系统编程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>概念</strong>：</p>
<ul>
<li><strong>Linux系统编程就是基于linux提供的系统调用函数接口来进行编程</strong></li>
<li><strong>系统调用严格意义来讲是系统函数而非真系统调用</strong>，比方说<strong>read函数，他其实是将真正的系统调用函数sys_read函数封装了一层来提供的</strong>，所以read函数只能说是系统函数</li>
<li>对于Linux的C++开发程序员来说，在Linux系统下开发以及懂得使用Linux的系统函数尤为重要</li>
</ul>
<h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>静态库</code>是<strong>在可执行程序运行前就加入到执行码中，成为执行程序的一部分</strong></li>
<li>在生成可执行程序后，<strong>可执行程序的占用空间包括了静态库的大小</strong></li>
<li>静态库<strong>适用于对于空间要求较低，对时间要求较高的核心程序</strong></li>
</ul>
<p><strong>制作静态库及使用</strong>：</p>
<ol>
<li><p>准备好要制作静态库的程序文件和声明文件.h</p>
</li>
<li><p><code>生成目标文件</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c 程序文件.cpp -o 程序文件.o<br>//可以生成多个目标文件，最后将这些全部做到一个静态库中<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>生成静态库</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ar rcs lib库名.a 目标文件<span class="hljs-number">1.</span>o 目标文件<span class="hljs-number">2.</span>o ...<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>使用静态库</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在要使用静态库程序中引用.h文件</span><br><span class="hljs-comment">//然后编译程序文件时使用静态库</span><br><span class="hljs-comment">//c++</span><br>g++ 运行程序.cpp lib库名.a -o 运行程序<br><br>    <br><span class="hljs-comment">//c</span><br>gcc 运行程序.cpp lib库名.a -o 运行程序<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>动态库(共享库)</code>是<strong>在执行程序启动时加载到执行程序中，可以被多个执行能够程序共享使用</strong></li>
<li><strong>动态库是不会占用执行程序空间</strong>，也就是执行程序中的占用空间里不包含动态库，而可执行程序可调用动态库</li>
<li>动态库<strong>适用于对空间要求较高，对时间要求较低的核心程序</strong></li>
</ul>
<p><strong>制作动态库及使用</strong>：</p>
<ol>
<li><p>准备好要制作动态库的程序文件和声明文件.h</p>
</li>
<li><p><code>生成与位置无关的代码将.c或.cpp生成.o文件</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c 文件.cpp -o 文件.o -fPIC<br>//-fPIC参数将会生成与位置无关代码<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>制作动态库</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -shared -o lib库名.so 目标文件.o 目标文件1.o ...<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>使用动态库</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">//编译可执行程序时，指定所使用的动态库<br>//-l：指定库名<br>//-L：指定库路径<br><span class="hljs-meta prompt_">#</span><span class="language-bash">c</span><br>gcc 可执行程序.cpp -o 可执行程序.out -l 库名 -L 库路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">c++</span><br>gcc 可执行程序.cpp -o 可执行程序.out -l 库名 -L 库路径<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行可执行文件.out</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">报错</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">./test.out: error <span class="hljs-keyword">while</span> loading shared libraries: libadd.so: cannot open shared object file: No such file or directory</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>使用动态库后的.out程序运行报错解决</strong>：</p>
<ul>
<li><p>原因：</p>
<blockquote>
<p><strong>链接器</strong>：工作于链接阶段，工作时需要-l和-L</p>
<p><strong>动态链接器</strong>：工作于程序运行阶段，<strong>工作时需要提供动态库所在目录位置(会去默认目录去找)</strong></p>
<p>原因：因为使用动态库，所使用的是动态链接器，<strong>则工作时需要找到动态库，因为他在默认目录未找到，所以导致报错</strong></p>
</blockquote>
</li>
<li><p>解决：</p>
<blockquote>
<ol>
<li><p><strong>设置临时环境变量</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LD_LIBRARY_PATH=库路径<br><br>./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行成功</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>**编辑终端配置文件(永久)**：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">去到你对应的终端，bash就是.bashrc,zsh就是.zshrc</span><br>vim .zshrc<br>         <br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加,库路径建议使用绝对路径</span><br>export LD_LIBRARY_PATH=库路径<br><span class="hljs-meta prompt_">#</span><span class="language-bash">保存</span><br>         <br><span class="hljs-meta prompt_">#</span><span class="language-bash">生效配置文件</span><br>source .zshrc<br>         <br>./test.out<br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行成功</span><br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="open-close函数"><a href="#open-close函数" class="headerlink" title="open&#x2F;close函数"></a>open&#x2F;close函数</h2><p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>int open(const char *pathname,int flags)</code>：<strong>用来打开一个文件和创建一个文件(如果没有该文件就创建)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">int</span> flags)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:打开文件的路径名;<br><br>flags:操作标志参数,多个可以使用|包括;<br><span class="hljs-comment">//flags参数选择:</span><br>O_RDONLY:只读;<br>O_WRONLY:只写;<br>O_RDWR:读和写;<br>O_APPEND:追加;<br>O_CREAT:创建;<br>O_EXCL:文件是否存在;<br>O_TRUNC:截断;<br>O_NONBLOCK:非阻塞;<br><span class="hljs-comment">//返回值</span><br>成功:返回新的文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>int open(const char *pathname,int flags,mode_t mode)</code>：<strong>用来打开一个文件和创建一个文件(如果没有该文件就创建)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">int</span> flags,<span class="hljs-type">mode_t</span> mode)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//参数</span></span><br><span class="hljs-function">pathname:打开文件的路径名;</span><br><br>flags:操作标志参数,多个可以使用|包括;<br><span class="hljs-comment">//flags参数选择:</span><br>O_RDONLY:只读;<br>O_WRONLY:只写;<br>O_RDWR:读和写;<br>O_APPEND:追加;<br>O_CREAT:创建;<br>O_EXCL:文件是否存在;<br>O_TRUNC:截断;<br>O_NONBLOCK:非阻塞;<br><br>mode:为创建新文件设置权限参数,权限受到umask影响(默认文件操作权限);<br><span class="hljs-comment">//例如：rw-r--r-- 0644</span><br><span class="hljs-comment">//文件权限=mode&amp;(~umask)</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回新的文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>


</li>
<li><p><code>int close(int fd)</code>：<strong>关闭打开的文件描述符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要关闭文件的文件描述符;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>open常见错误</strong>：</p>
<ul>
<li>打开文件不存在(文件不存在，并且不设置创建参数)</li>
<li>以写方式打开只读文件(打开文件没有对应权限)</li>
<li>以只写方式打开目录</li>
</ul>
<h2 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read&#x2F;write函数"></a>read&#x2F;write函数</h2><p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>ssize_t read(int fd,void *buf,size_t count)</code>：原本<strong>是用于文件读取的操作，但是也可以用与socket的接收以及读取数据的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:是一个指向读或写数据的缓冲区指针;<br><br>count:缓冲区长度;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回读到的字节数,<span class="hljs-number">0</span>，表示已经到达文件末尾;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br><span class="hljs-number">-1</span>:<br>- 如果read返回<span class="hljs-number">-1</span>并且errno等于EAGIN或EWOULDBLOCK,说明不是read失败而是read以非阻塞读文件并且文件无数据<br>- 如果errno==EINTR，被异常终止，需要重启<br>- 如果errno==ECONNRESET,说明连接被重置<br>    <br><span class="hljs-comment">//创建缓冲区，可以使用BUFSIZ，BUFSIZ=4096</span><br><span class="hljs-type">char</span> buf[BUFSIZ];<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>ssize_t write(int fd,const void *buf,size_t count)</code>：<strong>用于进行文件写数据的操作</strong>，但是<strong>也可以用于socket通信的发送以及写数据的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:要操作的文件描述符;<br><br>buf:待写出数据的缓冲区;<br><br>count:数据大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回写入的字节数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>实现cp命令</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> fd1=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd1==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open argv1 error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> fd2=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd2==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open argv2 error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>((n=<span class="hljs-built_in">read</span>(fd1,buf,<span class="hljs-number">1024</span>))!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">write</span>(fd2,buf,n);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd1);<br>    <span class="hljs-built_in">close</span>(fd2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行</span><br><span class="hljs-comment">//g++ test.cpp -o test</span><br><span class="hljs-comment">//./test add.h add1.h</span><br><span class="hljs-comment">//发现add1.h的内容跟add.h一样</span><br></code></pre></td></tr></table></figure>























<h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p><strong>函数原型</strong>：</p>
<p><code>off_t lseek(int fd, off_t offset, int whence)</code>：<strong>用于读写文件偏移</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fd:文件描述符;<br><br>offset:偏移量;<br><br>whence:起始偏移位置;<br><span class="hljs-comment">//whence参数选择</span><br>SEEK_SET:文件开头;<br>SEEK_CUR:当前位置;<br>SEEK_END:文件末尾;<br><br><span class="hljs-comment">//返回值</span><br>成功:较起始位置向后偏移量;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li>lseek同样允许超过文件结尾设置偏移量，文件会因此扩展</li>
<li>注意文件”读”和”写”使用同一偏移位置</li>
</ul>
</blockquote>
<p><strong>应用场景</strong>:</p>
<ul>
<li>文件的”读”和”写”使用同一偏移位置</li>
<li>使用lseek获取文件大小(lseek(fd,0,SEEK_END);)</li>
<li>使用lseek扩展文件大小，要想使文件大小真正扩展，必须引起IO操作</li>
</ul>
<h2 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h2><p><strong>概念</strong>：</p>
<ul>
<li>Linux中也提供了一种用来查看错误原因的变量以及函数</li>
<li><strong>errno是Linux中的一个全局变量，当你程序发生报错时，会进行设置errno来告诉你报错的原因，而errno是一个整数</strong>，这个整数会对应着一个错误原因</li>
<li><strong>strerror函数是可以解读errno来返回这个errno所对应的原因</strong></li>
<li><strong>perror函数是可以设置报错提示，并且将errno的错误原因一起输出</strong></li>
</ul>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>char *strerror(int errnum)</code>：<strong>可以解读errno来返回这个errno所对应的原因</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>errnum:errno;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void perror(const char *s)</code>：<strong>可以设置报错提示，并且将errno的错误原因一起输出</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;cstdio&gt;</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>s:要设置的报错提示;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h2><p><strong>概念</strong>：</p>
<ul>
<li><code>阻塞</code>：当<strong>进程调用一个阻塞的系统函数时，该进程将会置于睡眠状态</strong>，这时内核调度其他进程运行，<strong>直到该进程等待的时间发生(<strong>比如网络上接收到包，或者调用sleep指定的睡眠时间到了)，</strong>它才可能继续运行</strong></li>
<li><code>非阻塞</code>：当调用非阻塞的系统函数时，<strong>如果不能立即得到结果，则不会阻塞当前线程或进程</strong>，但是<strong>调用者需要定时轮询查看处理状态</strong></li>
<li>产生阻塞的场景：读设备文件(dev目录)、读网络文件等等</li>
<li><code>阻塞、非阻塞是文件的属性</code>，而文件属性是可以修改的</li>
</ul>
<p><strong>阻塞示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> n;<br>    n=<span class="hljs-built_in">read</span>(STDIN_FILENO,buf,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read STDIN_FILENO&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//如果我不按键盘输入东西，它将会一直等待也就是阻塞</span><br></code></pre></td></tr></table></figure>













<p><strong>阻塞示例2</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> fd,n;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NOBLOCK);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open /dev/tty&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>  <br>tryagain:<br>    n=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(errno!=EAGAIN)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read /dev/tty&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-built_in">write</span>(STDOUT_FILENO,<span class="hljs-string">&quot;try again\n&quot;</span>,<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;try again\n&quot;</span>));<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">goto</span> tryagain;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//虽然设置了非阻塞文件属性，但是没有设置超时限制和结束限制，导致一直阻塞</span><br></code></pre></td></tr></table></figure>









<p><strong>非阻塞示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TRY <span class="hljs-string">&quot;try again\n&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TIMEOUT <span class="hljs-string">&quot;time out\n&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> fd,n,i;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open /dev/tty&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open /dev/tty ok... %d\n&quot;</span>,fd);<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        n=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(errno!=EAGAIN)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read /dev/tty&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">write</span>(STDOUT_FILENO,MSG_TRY,<span class="hljs-built_in">strlen</span>(MSG_TRY));<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)&#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,MSG_TIMEOUT,<span class="hljs-built_in">strlen</span>(MSG_TIMEOUT));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,n);<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//这种方式也不是最优的，最优的应该为响应的模式，当你们有需求我才响应，而不是我以轮询的方式去查看</span><br></code></pre></td></tr></table></figure>























<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p><strong>概念</strong>：</p>
<ul>
<li><code>fcntl函数</code>可以<strong>用来改变一个已经打开的文件的访问控制属性</strong></li>
</ul>
<p><strong>函数原型</strong>：</p>
<p><code>int fcntl(int fildes,int cmd,.../* arg */)</code>：可以<strong>用来改变一个已经打开的文件的访问控制属性</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">int</span> cmd, ...<span class="hljs-comment">/* arg */</span>)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>fildes:要操作的文件描述符;<br><br>cmd:函数行为参数;<br><span class="hljs-comment">//行为参数选择:</span><br>F_GETFL:获取文件属性;<br>F_SETFL:设置文件属性;<br><br>...:可变参数，也就是设置文件属性时可以加入文件属性作为第三个参数;<br><br><br><span class="hljs-comment">//返回值</span><br>F_GETFL:会返回文件属性;<br><br>F_SETFL:<span class="hljs-number">-1</span>以外的值;<br></code></pre></td></tr></table></figure>

























<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="stat-lstat函数"><a href="#stat-lstat函数" class="headerlink" title="stat&#x2F;lstat函数"></a>stat&#x2F;lstat函数</h3><p><strong>函数原型</strong>：</p>
<ul>
<li><code>int stat(const char *path,struct stat *buf)</code>：<strong>获取文件属性</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:文件路径或文件名;<br><br>buf:inode结构体指针,传出参数;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int lstat(const char *path,struct stat *buf)</code>：<strong>获取文件属性</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:文件路径或文件名;<br><br>buf:inode结构体指针,传出参数;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>









<p>inode结构体：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016853.png" srcset="/img/loading.gif" lazyload alt="image-20240425122528875"></p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><code>buf.st_size</code>：获取文件大小</li>
<li><code>buf.st_mode</code>：获取文件类型</li>
<li><code>buf.st_mode</code>：获取文件权限</li>
</ul>
<p><strong>判断文件类型</strong>：</p>
<ul>
<li><p>我们可以通过st_mode中给出的一些宏来进行判断文件类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">st_mode给出的宏:<br>m:st_mode<br><span class="hljs-number">1.</span><span class="hljs-built_in">S_ISREG</span>(m)：判断文件是不是普通文件;<br><span class="hljs-number">2.</span><span class="hljs-built_in">S_ISDIR</span>(m)：判断文件是不是目录;<br><span class="hljs-number">3.</span><span class="hljs-built_in">S_ISCHR</span>(m)：判断文件是不是设备文件;<br><span class="hljs-number">4.</span><span class="hljs-built_in">S_ISBLK</span>(m)：判断是否为块设备文件;<br><span class="hljs-number">5.</span><span class="hljs-built_in">S_ISFIFO</span>(m)：判断是否为管道;<br><span class="hljs-number">6.</span><span class="hljs-built_in">S_ISLNK</span>(m)：判断是否为符号链接;<br><span class="hljs-number">7.</span><span class="hljs-built_in">S_ISSOCK</span>(m)：判断是否为soket套接字;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sb;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">stat</span>(argv[<span class="hljs-number">0</span>],&amp;sb);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;stat error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">S_ISREG</span>(sb.st_mode))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It&#x27;s a regular\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：<strong>stat是不能够穿透符号链接，而lstat是能够穿透符号链接</strong>，也就是说当用stat对符号链接文件操作时，判断文件类型确是普通文件，而用lstat对符号链接文件操作时，判断文件类型确是符号链接</p>
</blockquote>
</li>
</ul>
<h3 id="link-unlink函数"><a href="#link-unlink函数" class="headerlink" title="link&#x2F;unlink函数"></a>link&#x2F;unlink函数</h3><p><strong>函数原型</strong>：</p>
<ul>
<li><code>int link(const char *oldpath,const char *newpath)</code>：<strong>可以为已经存在的文件创建目录项(硬链接)</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>oldpath:要创建硬链接文件路径;<br><br>newpath:硬链接文件保存的地址;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int unlink(const char *pathname)</code>：<strong>删除一个文件的目录项(硬链接)</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:要删除目录项的文件路径;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li>Linux删除文件的机制，是不断将inode中的st_nlink-1,直至减到为0为止。无目录项对应的文件，将会被操作系统择机释放</li>
<li><strong>unlink函数特征</strong>：<strong>清除文件时，如果文件的硬链接数到0了</strong>，没有dentry对应，则该文件仍不会马上被释放。<strong>要等到所有打开该文件的进程关闭该文件，系统才会择机将该文件释放掉</strong></li>
</ul>
</blockquote>
<p><strong>实现mv命令</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">link</span>(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">unlink</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>















<h3 id="隐式回收"><a href="#隐式回收" class="headerlink" title="隐式回收"></a>隐式回收</h3><p><strong>概念</strong>：<strong>当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空 间会被释放</strong>，这一特性称之为隐式回收系统资源</p>
<h3 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h3><p><strong>函数原型</strong>：</p>
<p><code>int symlink(const char *oldpath,const char *newpath)</code>：<strong>用于创建文件的软链接</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *target, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *linkpath)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>target:要创建软连接的文件目标地址;<br><br>linkpath:软连接文件保存地址;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

















<h3 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h3><p><strong>函数原型</strong>：</p>
<p><code>ssize_t readlink(const char *path,char *buf,size_t bufsiz)</code>：<strong>用于读取符号链接(软链接)文件内容，得到链接所指向的文件名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *restrict pathname, <span class="hljs-type">char</span> *restrict buf,<span class="hljs-type">size_t</span> bufsiz)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>pathname:要读取内容的软链接文件路径;<br><br>buf:将读入的内容保存的缓冲区;<br><br>bufsiz:缓冲区大小;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回实际读到的字节数;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>























<h3 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h3><p><strong>函数原型</strong>：</p>
<p><code>int rename(const char *oldpath,const char *newpath)</code>：<strong>为文件重命名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>oldpath:原来的文件名;<br><br>newpath:新的文件名;<br></code></pre></td></tr></table></figure>























<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h3><p><strong>函数原型</strong>:</p>
<p><code>char *getcwd(char *buf,size_t size)</code>：<strong>获取进程当前工作目录</strong>(man卷3)，相当于pwd命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>buf:将获取到的信息存入的缓冲区;<br><br>size:缓冲区大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:buf中保存当前进程工作目录位置;<br><br>失败:<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>























<h3 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h3><p><strong>函数原型</strong>:</p>
<p><code>int chdir(const char *path)</code>：<strong>改变当前进程的工作目录</strong>，其实就是cd命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>path:要进入的工作目录;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>





























<h3 id="opendir-closedir函数"><a href="#opendir-closedir函数" class="headerlink" title="opendir&#x2F;closedir函数"></a>opendir&#x2F;closedir函数</h3><p><strong>函数原型</strong>:</p>
<ul>
<li><code>DIR *opendir(const char *name)</code>：<strong>根据传入的目录名打开一个目录</strong>,DIR*类似于FILE*</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>name:目录名;<br><span class="hljs-comment">//参数支持相对路径、绝对路径</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回指向该目录结构体指针;<br><br>失败:返回<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int closedir(DIR *dirp)</code>：<strong>关闭指定打开的目录</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>





















<h3 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h3><p><strong>函数原型</strong>:</p>
<ul>
<li><code>struct dirent *readdir(DIR *dirp)</code>：<strong>读取指定目录</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dirp);<br><br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回目录项结构体指针;<br><br>失败:返回<span class="hljs-literal">NULL</span>,errno;<br><span class="hljs-comment">//注意：读取数据结束时也返回NULL值，所以需要借助errno进一步区分</span><br><br><br><span class="hljs-comment">//dirent结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> &#123;<br>    <span class="hljs-type">ino_t</span> d_ino;       <span class="hljs-comment">/* Inode number */</span><br>    <span class="hljs-type">off_t</span> d_off;       <span class="hljs-comment">/* Not an offset; see below */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> d_reclen;    <span class="hljs-comment">/* Length of this record */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;      <span class="hljs-comment">/* Type of file; not supported by all filesystem types */</span><br>    <span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* Null-terminated filename */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

























<h3 id="rewinddir函数"><a href="#rewinddir函数" class="headerlink" title="rewinddir函数"></a>rewinddir函数</h3><p><strong>函数原型</strong>:</p>
<p><code>void rewinddir(DIR *dirp)</code>：<strong>回卷目录读写位置至起始位置</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewinddir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br></code></pre></td></tr></table></figure>















<h3 id="telldir-seekdir函数"><a href="#telldir-seekdir函数" class="headerlink" title="telldir&#x2F;seekdir函数"></a>telldir&#x2F;seekdir函数</h3><p><strong>函数原型</strong>:</p>
<ul>
<li><code>long telldir(DIR *dirp)</code>：<strong>获取目录读写位置</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br><span class="hljs-comment">//返回值</span><br>成功:与dirp相关的目录当前读写位置;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>void seekdir(DIR *dirp,long loc)</code>：<strong>修改&#x2F;跳转目录指定的读写位置</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dirp, <span class="hljs-type">long</span> loc)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>dirp:目录名;<br><br>loc:一般telldir的返回值决定;<br></code></pre></td></tr></table></figure>



































<h3 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h3><p><strong>思路</strong>：</p>
<ol>
<li>判断命令行参数，获取用户要查询的目录名(argv[1])，还需要判断argc&#x3D;&#x3D;1-&gt;.&#x2F;目录</li>
<li>判断用户指定的是否是目录，使用stat S_ISDIR()</li>
<li>读目录，opendir()，readdir()，closedir()</li>
<li>递归读取目录文件，普通文件直接打印，目录就拼接出绝对路径，递归调用opendir()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH_LEN 256</span><br><br><span class="hljs-comment">//第二个参数为函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fetchdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir,<span class="hljs-type">void</span>(*fcn)(<span class="hljs-type">char</span> *))</span></span>&#123;<br>    <span class="hljs-type">char</span> name[PATH_LEN];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *sdp;<br>    DIR *dp;<br><br>    <span class="hljs-keyword">if</span>((dp=<span class="hljs-built_in">opendir</span>(dir))==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;fetchdir：can&#x27;t open %s\n&quot;</span>,dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>	<span class="hljs-comment">//读取目录项</span><br>    <span class="hljs-keyword">while</span> ((sdp=<span class="hljs-built_in">readdir</span>(dp))!=<span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(sdp-&gt;d_name,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span>||<span class="hljs-built_in">strcmp</span>(sdp-&gt;d_name,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(dir)+<span class="hljs-built_in">strlen</span>(sdp-&gt;d_name)+<span class="hljs-number">2</span>&gt;<span class="hljs-built_in">sizeof</span>(name))&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;fetchdir：name %s %s too long\n&quot;</span>,dir,sdp-&gt;d_name);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">sprintf</span>(name,<span class="hljs-string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);<br>            <span class="hljs-comment">//利用函数指针调用函数</span><br>            (*fcn)(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">closedir</span>(dp);<br>&#125;<br><br><span class="hljs-comment">//处理目录/文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isfile</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sbuf;<br><br>    <span class="hljs-comment">//文件名无效</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stat</span>(name,&amp;sbuf)==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;isfile：can&#x27;t access %s\n&quot;</span>,name);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//判断是否为目录</span><br>    <span class="hljs-keyword">if</span>((sbuf.st_mode&amp;S_IFMT)==S_IFDIR) <span class="hljs-built_in">fetchdir</span>(name,isfile); <br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%8ld %s\n&quot;</span>,sbuf.st_size,name);    <span class="hljs-comment">//不是目录，则是普通文件，直接打印文件名</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(argc==<span class="hljs-number">1</span>) <span class="hljs-built_in">isfile</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span> (--argc&gt;<span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//可一次查询多个目录</span><br>            <span class="hljs-built_in">isfile</span>(*++argv);    <span class="hljs-comment">//循环调用该函数处理各个命令行传入的目录</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>































<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><strong>函数原型</strong>：</p>
<ul>
<li><code>int dup(int oldfd)</code>：<strong>将已有的文件描述符文件里的内容复制到新建的文件描述符文件中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>oldfd:已有文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:新文件描述符;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int dup2(int oldfd,int newfd)</code>：<strong>将一个文件描述符newfd重定向到指定文件描述符oldfd的文件</strong>，重定向完，对newfd所指向文件操作也就是对oldfd所指向文件操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>oldfd:已有文件描述符;<br><br>newfd:要重定向的文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回newfd;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：对于dup2,如果oldfd不是有效的文件描述符，会报错，但是newfd文件描述符不会关闭</p>
</blockquote>
<p><strong>fcntl实现dup</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd1=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDWR);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd1 = %d\n&quot;</span>,fd1);<br>    <span class="hljs-type">int</span> newfd=<span class="hljs-built_in">fcntl</span>(fd1,F_DUPFD,<span class="hljs-number">0</span>);   <span class="hljs-comment">//0被占用，fcntl使用文件描述符表中可用的最小文件描述符返回</span><br>    <span class="hljs-comment">//也可以指定一个&lt;1024的文件描述符x，如果文件描述符没有被占用就可以直接使用，如果被占用系统自动找寻大于等于x没有被占用的文件描述符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;newfd = %d\n&quot;</span>,newfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>















<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p><strong>函数原型</strong>：</p>
<p><code>pid_t fork(void)</code>：<strong>创建一个子进程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:父进程接收到返回值新子进程<span class="hljs-built_in">ID</span>(PID),创建出来的子进程接收到返回值<span class="hljs-number">0</span>;<br><br>失败:父进程接收到<span class="hljs-number">-1</span>,errno，子进程没被创建成功;<br></code></pre></td></tr></table></figure>









<p><strong>创建子进程</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//用来检测子进程创建后是否是从头运行还是从fork()开始</span><br>    <span class="hljs-comment">//应该只打印一次，因为子进程会从fork()开始</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;before fork -1&quot;</span>&lt;&lt;std::endl;<br><br><br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-comment">//子进程创建失败</span><br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//说明当前进程是子进程</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;child is created&quot;</span>&lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//说明当前进程为父进程</span><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;parent process: my child is &quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>    &#125;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;end of file&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





























<h3 id="getpid-getppid函数"><a href="#getpid-getppid函数" class="headerlink" title="getpid&#x2F;getppid函数"></a>getpid&#x2F;getppid函数</h3><p><strong>函数原型</strong>:</p>
<ul>
<li><code>pid_t getpid(void)</code>：<strong>获取当前进程ID(PID)</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程PID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>pid_t getppid(void)</code>：<strong>获取当前子进程的父进程ID(PID)</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回当前子进程的父进程PID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>















<p><strong>循环创建子进程</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-type">pid_t</span> pid=fork();<br>        <span class="hljs-comment">//子进程创建失败</span><br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m parent \n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(i);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m child&quot;</span>&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





























<h3 id="getuid-getgid函数"><a href="#getuid-getgid函数" class="headerlink" title="getuid&#x2F;getgid函数"></a>getuid&#x2F;getgid函数</h3><p><strong>函数原型</strong>:</p>
<ul>
<li><code>uid_t getuid(void)</code>：<strong>获取当前进程实际用户ID</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uid_t</span> <span class="hljs-title">getuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程实际用户ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>uid_t geteuid(void)</code>：<strong>获取当前进程有效用户ID</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uid_t</span> <span class="hljs-title">geteuid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程有效用户ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>gid_t getgid(void)</code>：<strong>获取当前进程使用用户组ID</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">gid_t</span> <span class="hljs-title">getgid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:当前进程使用用户组ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>gid_t getegid(void)</code>：<strong>获取当前进程有效用户组ID</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">gid_t</span> <span class="hljs-title">getegid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><br>成功:当前进程有效用户组ID;<br><br>失败:无返回值，因为没有定义;<br></code></pre></td></tr></table></figure>



















<h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><p><strong>概念</strong>:</p>
<ul>
<li><p><strong>父子进程共享遵循读时共享写时复制</strong>，例如：有一个全局变量cnt&#x3D;100，当我父进程或者子进程读cnt时，将会共享这个cnt的值也就是100,但是当父进程或子进程要更改其值也就是写时，将会给当前进程copy一个cnt过来再改，因此当父进程或子进程修改cnt(只修改自己进程中的cnt),子进程或父进程读cnt得到的值还是cnt</p>
</li>
<li><p><strong>父子进程不会共享全局变量</strong></p>
</li>
<li><p>父子进程相同处：刚fork后，data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p>
</li>
<li><p>父子进程不同处：进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p>
</li>
<li><p><code>父子进程共享</code>：</p>
<blockquote>
<ol>
<li><strong>文件描述符</strong></li>
<li><strong>mmap映射区</strong></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>exec函数族</code>可以<strong>让子进程或父进程执行指定的某个可执行程序</strong></li>
<li><strong>当进程调用exec时，则进程中的代码段将会换成你要exec的可执行程序的代码段，以此来执行指定程序</strong>，但是进程ID没变</li>
<li><strong>exec不能返回的！</strong></li>
</ul>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p><code>int execl(const char *path,const char *arg,...)</code>：<strong>加载一个进程(可执行程序)，用于加载普通和系统的可执行程序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg,...)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>path:可执行文件路径;<br><br>arg:argv[<span class="hljs-number">0</span>],所以跟path一样;<br><br>...:用来传入执行可执行文件的参数，可变参数;<br><span class="hljs-comment">//注意：结尾得传入NULL来作为哨兵来结束参数输入</span><br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

























<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p><code>int execlp(const char *file,const char *arg,...)</code>：<strong>借助PATH环境变量加载一个进程</strong>，用于加载系统可执行程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg,...)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>file:可执行文件的文件名;<br><br>arg:argv[<span class="hljs-number">0</span>]，所以还是传入可执行文件名;<br><br>...:用来传入执行可执行文件的参数，可变参数;<br><span class="hljs-comment">//注意：结尾得传入NULL来作为哨兵来结束参数输入</span><br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>





<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;-h&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//因为只有报错时才会返回值，所以不需要判断返回值</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;exec error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m parent:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行结果：将会打印当前目录下文件信息</span><br></code></pre></td></tr></table></figure>

















<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p><code>int execvp(const char *file,const char *argv[])</code>：<strong>使用自定义环境变量env加载一个进程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>file:可执行文件的文件名;<br><br>argv[]:可变参数，类似于main函数中的argv[];<br><br><span class="hljs-comment">//返回值</span><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>











<h4 id="exec函数族特点"><a href="#exec函数族特点" class="headerlink" title="exec函数族特点"></a><strong>exec函数族特点</strong></h4><ul>
<li><p>exec函数一旦调用成功即执行新的程序，只有失败才返回！</p>
</li>
<li><p>函数名中的字母含义：</p>
<blockquote>
<ol>
<li>l (list)：命令行参数列表</li>
<li>p (path)：搜索file时使用path变量</li>
<li>v (vector)：使用命令行参数数组</li>
<li>e (environment)：使用环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量</li>
</ol>
</blockquote>
</li>
<li><p>只有exeve函数是系统调用函数</p>
</li>
</ul>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><p><strong>孤儿进程</strong>：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程</p>
<p><strong>僵尸进程</strong>：进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程</p>
<blockquote>
<p>注意：</p>
<ul>
<li>僵尸进程是不能使用kill命令清除掉的，因为kill命令只是用来终止进程的，而僵尸进程已经终止</li>
<li>需要使用kill命令将父进程kill掉，然后由init接收僵尸进程并回收</li>
</ul>
</blockquote>
<p><strong>概念</strong>：</p>
<ul>
<li><strong>一个进程在终止时</strong>会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在按其中保存了一些信息，<strong>如果是正常退出则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个</strong></li>
<li>这个进程的父进程<strong>可以调用wait或waitpid获取这些信息，彻底清除掉这个进程</strong></li>
<li><strong>wait、waitpid都只能够一次回收一个进程</strong></li>
</ul>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p><strong>函数原型</strong>：</p>
<p><code>pid_t wait(int *status)</code>：父进程调用wait函数可以回收子进程终止信息，有三个功能:</p>
<blockquote>
<ol>
<li>阻塞等待子进程退出(死亡)</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态(退出原因)</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>status:传出参数，子进程退出状态;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回被回收子进程的进程ID;<br><br>失败:<span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>









<p><strong>子进程退出信息</strong>：</p>
<p>要想进一步获取退出状态和原因需要借助一些宏函数</p>
<ul>
<li><p><code>WIFEXITED(status)</code>：判断子进程是否正常终止，为真则正常终止<code>WEXITSTATUS(status)</code>：只有当子进程是正常终止才调用查看子进程返回值</p>
</li>
<li><p><code>WIFSIGNALED(status)</code>：判断子进程是否是被信号终止的，为真为是</p>
<p><code>WTERMSIG(status)</code>：只有当子进程是被信号终止时，用来查看子进程是被哪个信号终止</p>
</li>
<li><p><code>WIFSTOPPED(status)</code>：判断子进程是否被信号阻塞，为真则是</p>
<p><code>WSTOPSIG(status)</code>：只有当子进程是被信号阻塞时，用来查看子进程被哪个信号阻塞的</p>
<p><code>WIFCONTINUED(status)</code>：查看子进程是否被恢复</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid,wpid;<br>    pid=fork();<br><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;---child,my id=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;<span class="hljs-string">&quot;,going to sleep 10s\n&quot;</span>;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;--------child die--------&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">73</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//wpid=wait(NULL);  //不关心子进程结束原因</span><br>        wpid=<span class="hljs-built_in">wait</span>(&amp;status);     <span class="hljs-comment">//如果子进程未终止，父进程阻塞在这个函数上</span><br>        <span class="hljs-keyword">if</span>(wpid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;wait error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFEXITED</span>(status))&#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;child exit with &quot;</span>&lt;&lt;<span class="hljs-built_in">WEXITSTATUS</span>(status)&lt;&lt;std::endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFSIGNALED</span>(status))&#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;child kill with signal &quot;</span>&lt;&lt;<span class="hljs-built_in">WTERMSIG</span>(status)&lt;&lt;std::endl;<br>        &#125;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I am parent,pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getgid</span>()&lt;&lt;<span class="hljs-string">&quot;,myson=&quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;被回收的进程ID=&quot;</span>&lt;&lt;wpid&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>















<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p><strong>函数原型</strong>：</p>
<p><code>pid_t waitpid(pid_t pid,int *status,int options)</code>：<strong>作用同wait一样</strong>(父进程调用wait函数可以回收子进程终止信息)，但<strong>可指定pid进程清理，可以不阻塞</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">int</span> *status,<span class="hljs-type">int</span> options)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pid:要被回收的子进程ID;<br><span class="hljs-comment">//参数列表：</span><br>&gt; <span class="hljs-number">0</span>:回收指定ID的子进程;<br><span class="hljs-number">-1</span>:回收任意子进程(相当于wait);<br><span class="hljs-number">0</span>:回收和当前调用waitpid一个组的所有子进程;<br>&lt; <span class="hljs-number">-1</span>:回收指定进程组内的任意子进程;<br><br>status:传出参数，子进程退出状态;<br><br>options:函数行为标志位参数;<br><span class="hljs-comment">//标志位参数有，可以看第二卷man手册:</span><br><span class="hljs-number">0</span>:阻塞;<br>WNOHANG:不阻塞;<br><br><br><br><br><br><span class="hljs-comment">//返回值</span><br>返回值&gt;<span class="hljs-number">0</span>:表示成功回收的子进程pid;<br><br>返回值=<span class="hljs-number">0</span>:函数调用时，参数三指定WNOHANG,并且没有子进程结束;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>















<p><strong>waitpid回收多个进程</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">pid_t</span> pid,wpid;<br>    pid=fork();<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i)&#123;<br>        <span class="hljs-comment">/* while((wpid=waitpid(-1,NULL,0)))&#123;    //使用阻塞方式回收子进程</span><br><span class="hljs-comment">            std::cout&lt;&lt;&quot;wait child &quot;&lt;&lt;wpid&lt;&lt;std::endl;</span><br><span class="hljs-comment">        &#125; */</span><br>        <span class="hljs-comment">//使用非阻塞</span><br>        <span class="hljs-keyword">while</span>((wpid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">NULL</span>,WNOHANG))!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(wpid&gt;<span class="hljs-number">0</span>)&#123;<br>                std::cout&lt;&lt;<span class="hljs-string">&quot;wait child &quot;</span>&lt;&lt;wpid&lt;&lt;std::endl;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wpid==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(i);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;I&#x27;m &quot;</span>&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;th child,pid=&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>











































<h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p><strong>概念</strong>：</p>
<ul>
<li><code>进程间通信(IPC)</code>：<strong>也就是进程与进程之间进行通信、共享和数据传递</strong> ，叫作进程间通信</li>
<li>进程间通信的<code>实质</code>就是<strong>在两个进程间放置一个缓冲区，让两个进程在缓冲区里进行读和写来进行通信。</strong></li>
</ul>
<p><strong>进程间通信方式</strong>：</p>
<ul>
<li>管道(使用最简单)</li>
<li>信号(开销最小)</li>
<li>mmap共享映射区(无血缘关系)</li>
<li>本地套接字socket(最稳定)</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p>
<ul>
<li><code>管道</code>是一种最基本的IPC机制，<strong>作用于有血缘关系的进程之间，完成数据传递。</strong></li>
<li>管道的<strong>本质是一个伪文件(实为内核缓冲区)</strong></li>
<li>由两个文件描述符引用的，一个表示读端，一个表写端</li>
<li>管道是内核使用环形队列机制，借助内核缓冲区实现的</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>数据<strong>不能自己写，自己读</strong></li>
<li><strong>管道中数据不可反复读取</strong>，一旦读走，管道中的相应内容不再存在</li>
<li><strong>采用半双工通信方式</strong>，数据只能在单方向上流动</li>
</ul>
<p><strong>特点</strong>：</p>
<ol>
<li>**它是半双工的(即数据只能在一个方向上流动)**，具有固定的读端和写端</li>
<li>它<code>只能用于具有亲缘关系的进程之间的通信</code>(父子进程或兄弟进程之间)</li>
<li><strong>它可以看成是一种特殊的文件(伪文件)<strong>，对于它的</strong>读写也可以使用普通的read、write等函数</strong>。但是它不是普通的文件，并不属于其他任何文件系统，并且<strong>只存在于内存中</strong></li>
</ol>
<h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int pipe(int pipefd[2])</code>：<strong>创建并打开管道</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pipefd[<span class="hljs-number">0</span>]:读端的文件描述符;<br><br>pipefd[<span class="hljs-number">1</span>]:写端的文件描述符;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>























<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">//父进程写，子进程读，则父进程需要关闭读端，子进程需要关闭写端</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret,fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> *str=<span class="hljs-string">&quot;hello pipe\n&quot;</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    ret=<span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//父进程关闭读端</span><br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>],str,<span class="hljs-built_in">strlen</span>(str));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写完数据就关闭</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//子进程关闭写端</span><br>        ret=<span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>],buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, ret);<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//读完数据就关闭读端</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>













<h4 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h4><ol>
<li><p><code>读管道</code>：</p>
<blockquote>
<ol>
<li>管道中有数据，read返回实际读到的字节数.</li>
<li>管道中无数据：<ul>
<li>管道写端被全部关闭，read返回0</li>
<li>写端没有全部关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p><code>写管道</code>：</p>
<blockquote>
<ol>
<li>管道读端全部被关闭，进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</li>
<li>管道读端没有全部关闭：<ul>
<li>管道已满，write阻塞</li>
<li>管道未满，write将数据写入，并返回实际写入的字节数</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>兄弟进程通信</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-comment">//父进程写，子进程读，则父进程需要关闭读端，子进程需要关闭写端</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret,fd[<span class="hljs-number">2</span>],i;<br>    <span class="hljs-type">pid_t</span> pid;<br>    ret=<span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)&#123;<br>        pid=fork();<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//关闭父进程的读端</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//关闭父进程的写端</span><br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//兄</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//关闭兄进程的读端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">1</span>],STDOUT_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp ls error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) &#123;   <span class="hljs-comment">//弟</span><br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//关闭弟进程的写端</span><br>        <span class="hljs-built_in">dup2</span>(fd[<span class="hljs-number">0</span>],STDIN_FILENO);<br>        <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;wc&quot;</span>,<span class="hljs-string">&quot;wc&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;execlp ls error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>









































<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p>
<ul>
<li><code>FIFO(命名管道)</code>：<strong>是Linux基础文件类型中的一种</strong>，<strong>各进程可以打开这个文件进行read&#x2F;write</strong>，实际上是在读写内核通道，这样就是实现了进程间通信</li>
<li>FIFO文件<strong>在磁盘上没有数据块，仅仅用来标识内核中的一条通道</strong>。</li>
<li>在Linux终端中可以使用mkfifo命令，进行创建FIFO文件</li>
</ul>
<p><strong>特点</strong>：</p>
<ol>
<li>FIFO<code>可以在无血缘关系的进程之间交换数据</code>，与pipe不同。</li>
<li>它以一种特殊设备文件形式存在于文件系统中，所以<strong>我们应该用对文件的操作对待它</strong></li>
</ol>
<h4 id="mkfifo函数"><a href="#mkfifo函数" class="headerlink" title="mkfifo函数"></a>mkfifo函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int mkfifo(const char *pathname,mode_t mode)</code>：<strong>用来创建FIFO文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pathname:fifo文件路径名;<br><br>mode:为创建新文件设置权限参数,权限受到umask影响(默认文件操作权限);<br><span class="hljs-comment">//例如：rw-r--r-- 0644</span><br><span class="hljs-comment">//文件权限=mode&amp;(~umask)</span><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

















<h4 id="FIFO进程通信"><a href="#FIFO进程通信" class="headerlink" title="FIFO进程通信"></a>FIFO进程通信</h4><p>先创建一个myfifo的fifo文件</p>
<p>写端：test.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd,i;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Enter like this: ./a.out fifoname\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//int fd=mkfifo(&quot;myfifo&quot;,0644);</span><br>    fd=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;hello itcast %d\n&quot;</span>,i++);<br>        <span class="hljs-built_in">write</span>(fd,buf,<span class="hljs-built_in">strlen</span>(buf));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>









<p>读端：testr.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd,len;<br>    <span class="hljs-type">char</span> buf[BUFSIZ];<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;./a.out fifoname\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    fd=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        len=<span class="hljs-built_in">read</span>(fd,buf,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO,buf,len);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);   <span class="hljs-comment">//多个读端时应增加睡眠秒数，放大效果</span><br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

































<h3 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h3><h4 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I&#x2F;O"></a>存储映射I&#x2F;O</h4><p><strong>概念</strong>：</p>
<ul>
<li><code>存储映射I/O</code><strong>使一个磁盘文件与存储空间中的一个缓冲区相映射</strong>，当从缓冲区取数据相当于读文件中相应字节，将数据存入缓冲区，则相应的字节就自动写入文件。</li>
<li><strong>存储映射可以</strong>在不适用read和write函数的情况下，<strong>使用地址(指针)完成I&#x2F;O操作</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016854.png" srcset="/img/loading.gif" lazyload alt="image-20240429083055810"></p>
<p><strong>使用注意事项</strong>：</p>
<ol>
<li>用于创建映射区的文件大小为0,实际指定非0大小创建映射区，出”总线错误(SIGBUS)”</li>
<li>用于创建映射区的文件大小为0,实际指定0大小创建映射区，出”无效参数”</li>
<li>用于创建映射区文件的读写属性为只读，映射区属性为读写，出”无效参数”</li>
<li>创建映射区需要读权限，当访问权限指定为MAP_SHARED时，mmap的读写权限应该&lt;&#x3D;文件的open权限</li>
<li>文件描述符fd,在mmap创建映射区完成即可关闭，后续访问文件，用地址访问</li>
<li>offset必须是4096的整数倍(MMU映射的最小单位为4k)</li>
<li>对申请的映射区内存，不能越界访问。</li>
<li>munmap用于释放的地址，必须是mmap申请返回的地址</li>
<li>映射区访问权限为MAP_PRIVATE，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上</li>
<li>映射区访问权限为MAP_PRIVATE，只需要open文件时，有读权限用于创建映射区即可</li>
</ol>
<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><p><strong>函数原型</strong>：</p>
<p><code>void *mmap(void *addr,size_t length,int prot,int flags,int fd,off_t offset)</code>：<strong>创建共享内侧映射区</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> off)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>addr:建立映射区的首地址，由Linux内核指定，使用时，直接传入<span class="hljs-literal">NULL</span>;<br><br>length:欲创建映射区的大小(小于等于文件实际大小);<br><br>prot:映射区权限;<br><span class="hljs-comment">//选择:</span><br>PROT_READ:读;<br>PROT_WRITE:写;<br>PROT_READ|PROT_WRITE:读写;<br>PROT_NONE:没有访问权限;<br>...:更多的看man手册第二卷的mmap函数;<br><br>flags:标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区);<br><span class="hljs-comment">//选择:</span><br>MAP_SHARED:会将映射区所做的操作反映到物理设备(磁盘)上;<br>MAP_PRIVATE:映射区所做的修改不会反映到物理设备;<br>...:更多的看man手册第二卷的mmap函数;<br><br><span class="hljs-comment">//需要先有文件</span><br>fd:用于创建共享内存映射区的那个文件的文件描述符;<br><br>offset:默认<span class="hljs-number">0</span>,表示映射文件全部。偏移位置,取值必须是<span class="hljs-number">4096</span>的整数倍;<br><br><span class="hljs-comment">//返回值</span><br>成功:共享内存映射区的首地址;<br><br>失败:返回<span class="hljs-built_in">MAP_FAILED</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>),errno;<br><span class="hljs-comment">//返回一个将-1强转成void*的宏</span><br></code></pre></td></tr></table></figure>









<p><strong>mmap函数保险调用方式</strong>：</p>
<ol>
<li>open(pathname,O_RDWR,0644);</li>
<li>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,fd,0);</li>
</ol>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int munmap(void *addr,size_t length)</code>：<strong>释放共享内存映射区</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>addr:要释放的映射区的首地址，也是mmap函数的返回值;<br><br>length:映射区大小;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>













<p><strong>使用示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> fd;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/* lseek(fd,10,SEEK_END);</span><br><span class="hljs-comment">    write(fd,&quot;\0&quot;,1); */</span><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-number">20</span>);   <span class="hljs-comment">//可以代替lseek操作来扩展文件</span><br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">lseek</span>(fd,<span class="hljs-number">0</span>,SEEK_END);<br>    p=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//使用p对文件进行读写操作</span><br>    <span class="hljs-built_in">strcpy</span>(p,<span class="hljs-string">&quot;hello mmap&quot;</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;-------&quot;</span>&lt;&lt;p&lt;&lt;std::endl;<br><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,len);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>	<span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



























<h4 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h4><p><strong>概念</strong>：</p>
<ul>
<li><p><strong>父子等有血缘关系的进程之间也可以通过mmap建立映射区来完成数据通信</strong>，但相应的要在创建映射区的时候指定对应的标志位参数flags：</p>
<blockquote>
<ul>
<li>MAP_PRIVATE:父子进程各自独占映射区(私有映射)</li>
<li>MAP_SHARED:父子进程共享映射区(共享映射)</li>
</ul>
</blockquote>
</li>
<li><p><strong>要想父子进程通信，则flags应该置于MAP_SHARED</strong></p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> var=<span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> *p;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> fd;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// unlink(&quot;testmap&quot;);     //删除临时文件目录项，使之具备被释放的条件</span><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-number">4</span>);<br>    p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// p=(int *)mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0);</span><br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        *p=<span class="hljs-number">2000</span>;    <span class="hljs-comment">//写共享内存,因为映射区为int*类型所以，只能写整形变量</span><br>        var=<span class="hljs-number">1000</span>;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;child,*p=&quot;</span>&lt;&lt;*p&lt;&lt;<span class="hljs-string">&quot;,var=&quot;</span>&lt;&lt;var&lt;&lt;std::endl;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;parent,*p=&quot;</span>&lt;&lt;*p&lt;&lt;<span class="hljs-string">&quot;,var=&quot;</span>&lt;&lt;var&lt;&lt;std::endl;<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p, <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//如果子进程和父进程输出的*p一致说明他们能通信</span><br><span class="hljs-comment">//使用私有权限不能够通信</span><br></code></pre></td></tr></table></figure>





































<h4 id="mmap无血缘关系进程通信"><a href="#mmap无血缘关系进程通信" class="headerlink" title="mmap无血缘关系进程通信"></a>mmap无血缘关系进程通信</h4><p>示例：</p>
<p>写端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    student stu=&#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">18</span>&#125;,*p;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">ftruncate</span>(fd,<span class="hljs-built_in">sizeof</span>(stu));<br>    p=(<span class="hljs-keyword">struct</span> student*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-built_in">sizeof</span>(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">memcpy</span>(p,&amp;stu,<span class="hljs-built_in">sizeof</span>(stu));<br>        stu.id++;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-built_in">sizeof</span>(stu));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<p>读端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    student stu,*p;<br>    fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;testmap&quot;</span>,O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    p=(<span class="hljs-keyword">struct</span> student*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-built_in">sizeof</span>(stu),PROT_READ,MAP_SHARED,fd,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;id=%d,name=%s,age=%d\n&quot;</span>,p-&gt;id,p-&gt;name,p-&gt;age);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-built_in">sizeof</span>(stu));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





































<h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p><strong>概念</strong>：</p>
<ul>
<li><code>匿名映射</code>：<strong>可以不需要创建文件来创建共享内存映射区</strong>，在mmap函数的<code>flags标志位参数添加上MAP_ANON或MAP_ANONYMOUS来实现,-1代替fd</code></li>
<li>之前使用mmap映射时，我们都是使用创建一个文件来创建共享内存映射区，但是我们也可以使用匿名映射，来避免需要创建文件来创建共享内存映射区</li>
<li><code>只能用于血缘关系进程间通信</code></li>
<li>也可以使用open(“&#x2F;dev&#x2F;zero”)来当作映射区，因为&#x2F;dev&#x2F;zero可以提供很大的空间，你想要多少他就给多少，这样就不需要扩展文件，直接创建映射区(虽然不是匿名映射)</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> var=<span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> *p;<br>    p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,<span class="hljs-number">40</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(p==MAP_FAILED)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        *p=<span class="hljs-number">7000</span>;<br>        var=<span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child,*p=%d,var=%d\n&quot;</span>,*p,var);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent,*p=%d,var=%d\n&quot;</span>,*p,var);<br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">munmap</span>(p,<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;munmap error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>









































<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><strong>概念</strong>：</p>
<ul>
<li><p><code>信号(SIGNAL)</code>：给我们提供了一个信息，表示某件事件发生。在我们生活中随处可见，如：古代战争摔杯为号;体育比赛中的信号枪</p>
</li>
<li><p>常用信号可以使用kill -l和man 7 signal来查看</p>
</li>
<li><p>特点：</p>
<blockquote>
<ol>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>信号的机制</strong>：</p>
<ul>
<li>A给B发送信号，B收到信号之前执行自己的代码，<strong>收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行</strong></li>
<li>由于信号是通过软件方法实现的，其实现手段导致信号有很强的延时性。但相对于用户来说，这个延迟时间非常短，不易察觉</li>
<li><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理</strong>。</li>
</ul>
<p><strong>与信号相关的事件和状态</strong>：</p>
<ul>
<li><p><strong>产生信号状态</strong>：</p>
<blockquote>
<ol>
<li>按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</li>
<li>系统调用产生，如：kill、raise、abort</li>
<li>软件条件产生，如：定时器alarm</li>
<li>硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</li>
<li>命令产生，如：kill命令</li>
</ol>
</blockquote>
</li>
<li><p><strong>递达状态</strong>：递达并且到达进程</p>
</li>
<li><p><strong>未决状态</strong>：产生和递达之间的状态，<strong>主要由于阻塞(屏蔽)导致该状态</strong></p>
</li>
<li><p><strong>信号的处理方式</strong>：</p>
<blockquote>
<ol>
<li>执行默认动作</li>
<li>忽略(丢弃)</li>
<li>捕捉(调用户处理函数)</li>
</ol>
</blockquote>
</li>
<li><p>**阻塞信号集(信号屏蔽字)<strong>：将某些信号加入集合，对他们设置屏蔽，</strong>当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)**，在解除屏蔽前，一直处于未决态</p>
</li>
<li><p><strong>未决信号集</strong>：</p>
<blockquote>
<ol>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为1,表信号处于未决状态。当信号被处理对应位翻转回为0。</li>
<li><strong>信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集</strong>。在屏蔽解除前，信号一直处于未决状态</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>信号四要素</strong>：</p>
<ol>
<li>信号编号</li>
<li>信号名称</li>
<li>信号对应事件</li>
<li>信号默认处理动作</li>
</ol>
<blockquote>
<p>注：信号使用之前，应先确定4要素，而后使用</p>
</blockquote>
<p><strong>默认处理动作</strong>：</p>
<ul>
<li><strong>Term</strong>：终止进程</li>
<li><strong>Ign</strong>：忽略信号(默认及时对该种信号忽略操作)</li>
<li><strong>Core</strong>：停止进程，生成Core文件。(查验进程死亡原因，用于gdb调试)</li>
<li><strong>Stop</strong>：停止(暂停)进程</li>
<li><strong>Cont</strong>：继续运行进程</li>
</ul>
<p><strong>常规信号一览表</strong>：</p>
<ol>
<li><strong>SIGHUP</strong>：本信号在用户终端结束时发出，通常是在终端的控制进程结束时，通知同一会话期内的各个作业，这时他们与控制终端不在关联。比如，登录Linux时，系统会自动分配给登录用户一个控制终端，在这个终端运行的所有程序，包括前台和后台进程组，一般都属于同一个会话。当用户退出时，所有进程组都将收到该信号，这个信号的默认操作是终止进程。此外对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</li>
<li><strong>SIGINT</strong>：程序终止信号。当用户按下CRTL+C时通知前台进程组终止进程。</li>
<li><strong>SIGQUIT</strong>：Ctrl+\控制，进程收到该信号退出时会产生core文件，类似于程序错误信号。</li>
<li>SIGILL：执行了非法指令。通常是因为可执行文件本身出现错误，或者数据段、堆栈溢出时也有可能产生这个信号。</li>
<li>SIGTRAP：由断点指令或其他陷进指令产生，由调试器使用。</li>
<li>SIGABRT：调用abort函数产生，将会使程序非正常结束。</li>
<li><strong>SIGBUS</strong>：非法地址。包括内存地址对齐出错。比如访问一个4个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法地址的非法访问触发。</li>
<li><strong>SIGFPE</strong>：发生致命的算术运算错误。</li>
<li><code>SIGKILL</code>：用来立即结束程序的运行。</li>
<li><strong>SIGUSR1</strong>：留给用户使用，用户可自定义。</li>
<li><strong>SIGSEGV</strong>：访问未分配给用户的内存区。或操作没有权限的区域。</li>
<li><strong>SIGUSR2</strong>：留给用户使用，用户可自定义。</li>
<li><strong>SIGPIPE</strong>：管道破裂信号。当对一个读进程已经运行结束的管道执行写操作时产生。</li>
<li><strong>SIGALRM</strong>：时钟定时信号。由alarm函数设定的时间终止时产生。</li>
<li><strong>SIGTERM</strong>：程序结束信号。shell使用kill产生该信号，当结束不了该进程，尝试使用SIGKILL信号。</li>
<li>SIGSTKFLT：堆栈错误。</li>
<li><strong>SIGCHLD</strong>：子进程结束，父进程会收到。如果子进程结束时父进程不等待或不处理该信号，子进程会变成僵尸进程。</li>
<li>SIGCONT：让一个停止的进程继续执行。</li>
<li><code>SIGSTOP</code>：停止进程执行。暂停执行。</li>
<li>SIGTSTP：停止运行，可以被忽略。Ctrl+z。</li>
<li>SIGTTIN：当后台进程需要从终端接收数据时，所有进程会收到该信号，暂停执行。</li>
<li>SIGTTOU：与SIGTTIN类似，但在写终端时产生。</li>
<li>SIGURG：套接字上出现紧急情况时产生。</li>
<li>SIGXCPU：超过CPU时间资源限制时产生的信号。</li>
<li>SIGXFSZ：当进程企图扩大文件以至于超过文件大小资源限制时产生。</li>
<li>SIGVTALRM：虚拟使用信号。计算的是进程占用CPU调用的时间。</li>
<li>SIGPROF：包括进程使用CPU的时间以及系统调用的时间。</li>
<li>SIGWINCH：窗口大小改变时。</li>
<li>SIGIO：文件描述符准备就绪，表示可以进行输入输出操作。</li>
<li>SIGPWR：电源失效信号。</li>
<li>SIGSYS：非法的系统调用。</li>
</ol>
<blockquote>
<p>注：<strong>9号和19号信号不允许忽略和捕捉，只能执行默认动作，甚至不能将其设置为阻塞</strong></p>
</blockquote>
<h4 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h4><h5 id="kill函数-命令"><a href="#kill函数-命令" class="headerlink" title="kill函数&#x2F;命令"></a>kill函数&#x2F;命令</h5><p><strong>kill命令产生信号</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -SIGKILL pid;<br>//pid为要kill的进程ID<br></code></pre></td></tr></table></figure>









<p><strong>kill函数</strong>：</p>
<p><code>int kill(pid_t pid,int sig)</code>：<strong>发送信号给指定进程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>pid:进程ID;<br>pid&gt; <span class="hljs-number">0</span>:发送信号给指定的进程;<br>pid=<span class="hljs-number">0</span>:发送信号给与调用kill函数进程属于同一进程的所有进程;<br>pid&lt; <span class="hljs-number">-1</span>:取|pid|(绝对值)发给对应进程组;<br>pid=<span class="hljs-number">-1</span>:发送给进程有权限发送的系统中所有进程;<br><br>sig:信号;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>







<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid=fork();<br>    <span class="hljs-keyword">if</span>(pid&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent,pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child pid=%d,ppid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">getppid</span>());<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">kill</span>(<span class="hljs-built_in">getppid</span>(), SIGKILL);   <span class="hljs-comment">//杀死进程</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>













<p><strong>其他几个发信号函数</strong>：</p>
<ul>
<li><code>int raise(int sig)</code>;</li>
<li><code>void abort(void)</code>;</li>
</ul>
<h5 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h5><p><strong>概念</strong>：</p>
<ul>
<li>alarm函数可以设置定时器，在指定seconds后，内核会给当前进程发送SIGALRM信号，进程收到该信号，默认动作终止</li>
<li><strong>每个进程都有且只有唯一个定时器</strong></li>
</ul>
<p><strong>函数原型</strong>：</p>
<p><code>unsigned int alarm(unsigned int seconds)</code>：<strong>设置定时器，在指定seconds后，内核会给当前进程发送SIGALRM信号，进程收到该信号，默认动作终止</strong>，使用自然计时法.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>seconds:闹钟时长(秒);<br><span class="hljs-comment">//alarm(0)等于取消闹钟;</span><br><br><br><span class="hljs-comment">//返回值</span><br>成功:返回<span class="hljs-number">0</span>或上次定时剩余的秒数;<br>返回<span class="hljs-number">0</span>就是没有用alarm定时;<br>无失败;<br></code></pre></td></tr></table></figure>













<p><strong>time命令</strong>：查看程序执行时间，实际时间&#x3D;用户时间+内核时间+等待时间</p>
<h5 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h5><p><strong>函数原型</strong>：</p>
<p><code>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value)</code>：<strong>设置定时器，精度可达微秒，可以实现周期定时</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_value,<span class="hljs-keyword">struct</span> itimerval *old_value)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>which:指定定时形式;<br><span class="hljs-comment">//选择</span><br>ITIMER_REAL:自然时间计时法(计算自然时间，也就是在这之间程序终止，时间一到依然发送信号);  -&gt;发送SIGALRM信号<br><span class="hljs-built_in">ITIMER_VIRTUAL</span>(用户空间):虚拟时间计时法(只计算进程占用cpu的时间);  -&gt;发送SIGTVALRM信号<br><span class="hljs-built_in">ITIMER_PROF</span>(用户+内核):运行时间计时法(计算占用cpu及执行系统调用的时间);   -&gt;发送SIGPROF信号<br><br>new_value:定时秒数;<br><br>old_value:传出参数，上次定时剩余时间;<br><br><br><span class="hljs-comment">//参数类型结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">itimerval</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_interval; <span class="hljs-comment">/* Interval for periodic timer */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> it_value;    <span class="hljs-comment">/* Time until next expiration */</span><br>&#125;;<br><br>it_interval:用来设定两次定时任务之间间隔的时间;<br>it_value:定时的时长;<br>两个参数都设置为<span class="hljs-number">0</span>,则清<span class="hljs-number">0</span>操作也就是取消闹钟;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br>    <span class="hljs-type">time_t</span>      tv_sec;         <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-type">suseconds_t</span> tv_usec;        <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br><br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>





























<h4 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h4><p><strong>概念</strong>：</p>
<ul>
<li>在Linux中阻塞信号集和未决信号集都是存在于PCB中，并且Linux不允许我们直接在上面操作，但是我们又想对阻塞信号集或未决信号集操作就得需要以下函数</li>
<li>我们可以通过自定义的信号集来跟阻塞信号集进行位运算来影响阻塞信号集的各个信号位的值，阻塞信号集受到影响也将影响未决信号集</li>
</ul>
<h5 id="信号集设定函数"><a href="#信号集设定函数" class="headerlink" title="信号集设定函数"></a>信号集设定函数</h5><ul>
<li><p><code>int sigemptyset(sigset_t *set)</code>：<strong>将某个信号集清0</strong></p>
</li>
<li><p><code>int sigfillset(sigset_t *set)</code>：<strong>将某个信号集全部置为1</strong></p>
</li>
<li><p><code>int sigaddset(sigset_t *set,int signum)</code>：<strong>把某一个信号(signum)加入到某个自定义的信号集(set)</strong></p>
</li>
<li><p><code>int sigdelset(sigset_t *set,int signum)</code>：<strong>把某一个信号(signum)从某个自定义信号集(set)中移出</strong></p>
</li>
<li><p><code>int sigismember(const sigset_t *set,int signum)</code>：<strong>查看某一个信号(signum)是否在某个自定义信号集(set)中</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">sigset_t</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set, <span class="hljs-type">int</span> signum)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>set:自定义信号集;<br><br>signum:信号;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br>sigismember返回值:<br><span class="hljs-number">0</span>:set没有signum;<br><span class="hljs-number">1</span>:set有signum;<br><span class="hljs-number">-1</span>,errno:失败;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

















<h5 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h5><p><strong>函数原型</strong>：</p>
<p><code>int sigprocmask(int how,const sigset_t *set,sigset_t *oldset)</code>：<strong>用来屏蔽信号和解除屏蔽</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>how:函数行为设置位，设置函数执行所需要做的行为;<br><span class="hljs-comment">//选择:</span><br>SIG_BLOCK:当how设置为此值，set表示需要屏蔽信号.相当于mask=mask|set;<br>SIG_UNBLOCK:当how设置为此值，set表示需要解除屏蔽的信号.相当于mask=mask&amp;~set;<br>SIG_SETMASK:当how设置为此值，set表示用于替代原始屏蔽集的新屏蔽集.相当于mask=set,若调用sigprocmask解除了对当前某个若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达;<br><br>set:传入参数，自定义信号集，是一个位图，set中哪位置为<span class="hljs-number">1</span>,就表示当前进程屏蔽哪个信号;<br><br>oldset:传出参数,保存旧的信号屏蔽集，不需要可以传<span class="hljs-literal">NULL</span>;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：屏蔽信号，只是将信号处理延后执行(延至解除屏蔽)，而忽略表示将信号丢弃处理</p>
</blockquote>
<h5 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h5><p><strong>函数原型</strong>：</p>
<p><code>int sigpending(sigset_t *set)</code>：<strong>读取当前进程的未决信号集</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>set:传出参数,当前进程的未决信号集;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

























<h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><p><strong>概念</strong>：</p>
<ul>
<li>信号捕捉使是提供给开发者使用信号捕捉的函数在程序中捕捉到递达到该进程下的信号，然后自定义其的处理方式或者其他操作</li>
</ul>
<h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><p><strong>函数原型</strong>：</p>
<p><code>sighandler_t signal(int signum,sighandler_t handler)</code>：<strong>注册一个信号捕捉函数</strong>，设定指定信号需要被捕捉，注册完后，由内核捕捉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>signum:信号;<br><br>handler:捕捉后行为参数，是一个函数指针也就是<span class="hljs-type">sighandler_t</span>定义的函数;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回指向前一个此信号的处理(回调)函数的指针;<br><br>失败:返回SIG_ERR;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：该函数由ANSI定义，在不同版本的Linux中可能有不同的行为，因此我们<code>推荐使用sigaction函数</code></p>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-comment">//捕捉后行为函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_cath</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;catch you! %d\n&quot;</span>,signo);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">signal</span>(SIGINT,sig_cath);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//./test运行</span><br>./test<br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^Ccatch you! <span class="hljs-number">2</span><br>^\zsh: <span class="hljs-built_in">quit</span> (core dumped)  ./test <br></code></pre></td></tr></table></figure>

















<p><strong>验证signal返回值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun1&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun2&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">void</span> (*res)(<span class="hljs-type">int</span>);<br>    <span class="hljs-keyword">if</span>( (res=<span class="hljs-built_in">signal</span>(SIGINT,fun1)) == SIG_ERR )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br><br>    <span class="hljs-keyword">if</span>( (res=<span class="hljs-built_in">signal</span>(SIGINT,fun2)) == SIG_ERR )&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    <span class="hljs-built_in">res</span>(SIGINT);<span class="hljs-comment">//signal返回 指向前一个处理SIGINT的函数 的指针,也就是指向fun1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//如果按照man手册所说，我们两次raise,一次raise打印fun1,一次raise打印fun2,则此时的返回值res会是fun1的函数指针，因此调用res就会打印fun1</span><br><span class="hljs-comment">//事实确实如此，运行结果如下：</span><br>&gt; ./test<br>fun1<br>fun2<br>fun1<br></code></pre></td></tr></table></figure>





















<h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p><strong>函数原型</strong>：</p>
<p><code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact)</code>：<strong>用来注册一个信号的捕捉函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> &#123;<br>    <span class="hljs-built_in">void</span> (*sa_handler)(<span class="hljs-type">int</span>);   <span class="hljs-comment">//捕捉后行为函数</span><br>    <span class="hljs-built_in">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);  <span class="hljs-comment">//一般不用，要想信号携带复杂数据或结构替数据需要用这个函数</span><br>    <span class="hljs-type">sigset_t</span> sa_mask;   <span class="hljs-comment">//只作用于信号捕捉函数执行期间，当我们执行信号捕捉函数时，如果相同的信号递达，则有可能产生异常，因此sa_mask可以设定进行屏蔽</span><br>    <span class="hljs-type">int</span> sa_flags;   <span class="hljs-comment">//传0,则默认本信号默认屏蔽，则sa_mask本信号位置为1,传1则不屏蔽。</span><br>    <span class="hljs-built_in">void</span> (*sa_restorer)(<span class="hljs-type">void</span>);    <span class="hljs-comment">//废弃了</span><br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act,<span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>signum:要捕捉的信号编号;<br><br>act:传入参数,指定新的信号处理方式;<br><br>oldact:传出参数,输出上一次的信号处理方式(不为<span class="hljs-number">0</span>的话)，不需要可以传入<span class="hljs-literal">NULL</span>;<br><br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>











<p><strong>特性</strong>：</p>
<ul>
<li>进程正常运行时，默认PCB中有一个信号屏蔽字mask，它决定了进程自动屏蔽哪些信号，当注册了某个信号捕捉函数，捕捉到该信号以后，要调用信号捕捉函数，而信号捕捉函数有可能执行很长时间，在这期间所屏蔽的信号不由mask来指定，而是用act中的sa_mask来指定，调用完信号处理函数后，再恢复为mask</li>
<li>当sa_flag&#x3D;0时，xxx信号捕捉函数执行期间，xxx信号会自动被该进程屏蔽</li>
<li>阻塞的常规信号不支持排队，多次产生只记录一次(也就是只处理一次)。(后32个实时信号支持排队)</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_catch</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(signo==SIGINT)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;catch you!! %d\n&quot;</span>,signo);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(signo==SIGQUIT)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----catch you!! %d\n&quot;</span>,signo);<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act,oldact;<br>    act.sa_handler=sig_catch;   <span class="hljs-comment">//设置回调函数</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);   <span class="hljs-comment">//将sa_mask屏蔽字清0,在sig_catch工作时有效</span><br>    act.sa_flags=<span class="hljs-number">0</span>;    <span class="hljs-comment">//默认处理动作</span><br><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);  <span class="hljs-comment">//注册信号捕捉函数</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">sigaction</span>(SIGQUIT,&amp;act,&amp;oldact);  <span class="hljs-comment">//注册信号捕捉函数</span><br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>











<p><strong>验证返回值</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun1&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;fun2&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act,oldact;<br>    act.sa_handler=fun1;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    act.sa_flags=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);<br>    <span class="hljs-keyword">if</span> (ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction error!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    act.sa_handler=fun2;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    ret=<span class="hljs-built_in">sigaction</span>(SIGINT,&amp;act,&amp;oldact);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">raise</span>(SIGINT);<span class="hljs-comment">// == ctrl+c</span><br>    oldact.<span class="hljs-built_in">sa_handler</span>(SIGINT);    <span class="hljs-comment">//sigaction传出参数oldact的sa_handler指向前一个处理SIGINT的函数的指针,也就是指向fun1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//跟signal结果一致</span><br>&gt; ./test<br>fun1<br>fun2<br>fun1<br></code></pre></td></tr></table></figure>





















<h5 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h5><p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405312016855.png" srcset="/img/loading.gif" lazyload alt="image-20240501211733359"></p>
<h4 id="子进程回收"><a href="#子进程回收" class="headerlink" title="子进程回收"></a>子进程回收</h4><h5 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h5><p><strong>产生条件</strong></p>
<ul>
<li><strong>当子进程状态发生变化，就会产生SIGCHLD信号</strong>(例如子进程终止)</li>
</ul>
<h5 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/types/sigset_t.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">catch_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span></span>&#123;<br>    <span class="hljs-type">pid_t</span> wpid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">// while((wpid=wait(NULL))!=-1)&#123;</span><br>    <span class="hljs-comment">//循环回收多个子进程，防止多个子进程一起终止导致sa_mask屏蔽只回收一个，出现僵尸进程</span><br>    <span class="hljs-keyword">while</span>((wpid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,&amp;status,<span class="hljs-number">0</span>))!=<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WIFEXITED</span>(status))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------catch child id %d,ret=%d\n&quot;</span>,wpid,<span class="hljs-built_in">WEXITSTATUS</span>(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//使用阻塞屏蔽字来避免注册信号捕捉函数之前子进程终止</span><br>    <span class="hljs-type">sigset_t</span> mask;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;mask);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;mask,SIGCHLD);<br>    <span class="hljs-built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-keyword">if</span> ((pid=fork())==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span>==i)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>        act.sa_handler=catch_child;<br>        <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>        act.sa_flags=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sigaction</span>(SIGCHLD,&amp;act,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//解除阻塞</span><br>        <span class="hljs-built_in">sigprocmask</span>(SIG_UNBLOCK,&amp;mask,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m parent,pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-comment">/* while (1) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        &#125; */</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m child pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>































<h4 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h4><p><strong>概念</strong>：</p>
<ul>
<li>系统调用分为两类：慢速系统调用和其他系统调用</li>
<li><code>慢速系统调用</code>：<strong>可能会使进程永远阻塞的一类系统调用</strong>，如果在阻塞期间收到一个信号，<strong>该系统调用就被中断，不再继续执行</strong>。这一类系统调用有read、write、pause、wait…</li>
</ul>
<p><strong>慢速系统调用中断问题</strong>：</p>
<ul>
<li>慢速系统调用被信号中断后将不会再被执行，而我们可以<strong>利用</strong>注册信号捕捉函数的<strong>sa_flags参数来设置被信号中断后系统调用是否重启。</strong></li>
<li><strong>不重启(默认)<strong>：<code>SA_INTERRURT</code>，</strong>重启</strong>：<code>SA_RESTART</code></li>
</ul>
<p><strong>扩展</strong>：</p>
<ul>
<li>sa_flags还有很多可选参数，如:捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可以将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号</li>
<li>如果<strong>想要信号传递复杂信息(例如结构体)<strong>，需要</strong>将sa_flags设置为SA_SIGINFO</strong>,然后使用void (*sa_sigaction)(int, siginfo_t *, void *); 这个函数来进行传递</li>
</ul>
<h2 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>进程组</code>，也称之为作业，<strong>代表一个或多个进程的集合，每个进程都有属于的一个进程组</strong>，是为了简化对多个进程的管理</li>
<li>当<strong>父进程创建子进程的时候，默认子进程与父进程属于同一进程组</strong>。**进程组ID(PGID)&#x3D;&#x3D;第一个进程ID(组长进程)**。所以组长进程标识，其进程组ID&#x3D;&#x3D;其进程ID</li>
<li>可以使用kill -SIGKILL -进程组ID(取负值)来将整个进程组内的进程全部杀死</li>
<li>一个进程可以为自己或子进程设置进程组ID</li>
</ul>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>概念</strong>：</p>
<ul>
<li><strong>在Linux中，会话（Session）是指用户与操作系统交互的一段时间</strong></li>
<li><strong>我们常见的Linux session一般是指shell session</strong>。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。这表明<strong>会话是我们和shell交互的一个过程。</strong></li>
<li>tty:文字终端，只能输入命令无图形化</li>
<li>pts:虚拟终端，有图形化界面</li>
</ul>
<p><strong>创建会话注意事项</strong>：</p>
<ol>
<li><strong>调用进程不能是进程组组长</strong>，该进程变成新会话首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要root权限(ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>该调用进程是组长进程，则出错返回</li>
<li><strong>建立新会话时，先调用fork，父进程终止，子进程调用setsid()-创建新会话</strong></li>
</ol>
<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><p><strong>函数原型</strong>：</p>
<p><code>pid_t getsid(pid_t pid)</code>：<strong>获取进程所属的会话ID</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getsid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>pid:进程ID;<br><span class="hljs-comment">//pid=0表示查看当前进程session ID</span><br><br><span class="hljs-comment">//返回值</span><br>成功:返回调用进程的会话ID;<br><br>失败:<span class="hljs-number">-1.</span>errno;<br></code></pre></td></tr></table></figure>



























<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><p><strong>函数原型</strong>：</p>
<p><code>pid_t setsid(void)</code>：<strong>创建一个会话，并以自己的进程ID设置进程组ID，同时也是新会话的ID</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">setsid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:返回调用进程的会话ID;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li>调用了setsid函数的进程，既是新的会长，也是新的组长</li>
<li>调用进程不能是组长进程</li>
</ul>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> ((pid=fork())&lt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process PID is %d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Group ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getpgid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Session ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getsid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">setsid</span>();   <span class="hljs-comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程，该进程组id即为会话进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Changed:\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process PID is %d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Group ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getpgid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Session ID of child is %d\n&quot;</span>,<span class="hljs-built_in">getsid</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//示例输出，每个人的输出结果都不一样</span><br>./test<br>child process PID is <span class="hljs-number">18261</span><br>Group ID of child is <span class="hljs-number">18260</span><br>Session ID of child is <span class="hljs-number">16952</span><br><br>~/test<br>&gt; Changed:<br>child process PID is <span class="hljs-number">18261</span><br>Group ID of child is <span class="hljs-number">18261</span><br>Session ID of child is <span class="hljs-number">18261</span><br></code></pre></td></tr></table></figure>







































<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><strong>概念</strong>：</p>
<ul>
<li><code>守护进程</code>：叫做<strong>Daemon(精灵)进程</strong>，<strong>是Linux中的后台服务进程，通常独立于(脱离)控制终端并且周期性地执行某种人物或等待处理某些发生的事情</strong>，一般采用以d结尾的名字</li>
<li>Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互，<strong>不受用户登陆、注销的影响</strong>，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现、ftp服务器、nfs服务器等</li>
<li>创建守护进程，最关键一步是调用setsid函数创建一个新的Session,并成为Session Leader</li>
</ul>
<p><strong>创建守护进程模型</strong>：</p>
<ol>
<li><strong>创建子进程，父进程退出</strong>。所有工作在子进程中进行形式上脱离了控制终端</li>
<li><strong>在子进程中创建新会话，使用setsid()函数</strong>，使子进程完全独立出来，脱离控制</li>
<li>**根据需要，改变守护进程工作目录，使用chdir()函数，防止占用可卸载的文件系统(例如U盘)**，防止放在可卸载的文件系统，使得守护进程服务无法执行</li>
<li><strong>重设文件权限掩码，使用umask()函数，防止继承的文件创建屏蔽字拒绝某些权限</strong>，增加守护进程灵活性</li>
<li>**关闭或重定向文件描述符，继承的打开文件不会用到(针对012默认文件描述符)**，重定向的话将012重定向到&#x2F;dev&#x2F;null这个空洞文件下，浪费系统资源，无法卸载</li>
<li>开始执行守护进程核心工作守护进程退出处理程序模型</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid=fork();<br>    <span class="hljs-comment">//父进程终止</span><br>    <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//创建新会话</span><br>    pid=<span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;setsid error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//改变工作目录位置</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">chdir</span>(<span class="hljs-string">&quot;/home/moon/test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;chdir error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">umask</span>(<span class="hljs-number">0022</span>);  <span class="hljs-comment">//改变文件访问权限掩码</span><br>    <span class="hljs-built_in">close</span>(STDIN_FILENO);   <span class="hljs-comment">//关闭文件描述符0</span><br>    <span class="hljs-type">int</span> fd=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>,O_RDWR);   <span class="hljs-comment">//fd --&gt;0</span><br>    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">dup2</span>(fd, STDOUT_FILENO);   <span class="hljs-comment">//重定向 stdout和stderr </span><br>    <span class="hljs-built_in">dup2</span>(fd, STDERR_FILENO);<br>    <span class="hljs-comment">//模拟守护进程业务</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行</span><br>./test<br><span class="hljs-comment">//直接结束，是因为放到后台运行了，使用ps aux或者ps ajx查看</span><br>    <br><span class="hljs-comment">//终止命令</span><br>kill <span class="hljs-number">-9</span> test的进程ID<br></code></pre></td></tr></table></figure>









































<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p><strong>概念</strong>：</p>
<ul>
<li><p><code>线程</code>：<strong>可以看作是轻量级进程(LWP)，有独立的PCB，没有独立的进程地址空间(共享)</strong></p>
</li>
<li><p>在Linux下：</p>
<blockquote>
<p>线程：最小的执行单位</p>
<p>进程：最小分配资源单位，可看成是只有一个线程的进程</p>
</blockquote>
</li>
<li><p><code>ps -Lf 进程ID</code>：**可以查看线程号(LWP)**，CPU执行的最小单位</p>
</li>
<li><p>轻量级进程(LWP)，也有PCB，创建线程使用的底层函数和进程一样，都是克隆clone</p>
</li>
<li><p>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</p>
</li>
<li><p><strong>进程可以蜕变成线程</strong></p>
</li>
<li><p>线程可看作寄存器和栈的集合</p>
</li>
</ul>
<blockquote>
<p>注：线程ID和线程号是两个东西</p>
<ul>
<li><strong>线程ID：用来标识线程的</strong></li>
<li><strong>线程号：标识线程身份交给CPU使用分配执行时间</strong></li>
</ul>
</blockquote>
<p><strong>线程共享资源</strong>：</p>
<ol>
<li>文件描述符表</li>
<li>每种信号的处理方式</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
<li>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</li>
</ol>
<p><strong>线程非共享资源</strong>：</p>
<ol>
<li>线程ID</li>
<li>处理器现场(寄存器值)和栈指针(内核栈)</li>
<li>独立的栈空间(用户空间栈)</li>
<li>errno变量</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ol>
<p><strong>线程优缺点</strong>：</p>
<ul>
<li><p>优点：</p>
<blockquote>
<ol>
<li>提高程序并发性</li>
<li>开销小</li>
<li>数据通信、共享数据方便</li>
</ol>
</blockquote>
</li>
<li><p>缺点：</p>
<blockquote>
<ol>
<li>库函数，不稳定</li>
<li>调试、编写困难、gdb不支持</li>
<li>对信号支持不好</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<p>注：优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大</p>
</blockquote>
<h3 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h3><p><strong>注</strong>：</p>
<ul>
<li><strong>在Linux环境中，所有线程特点，失败均直接返回错误号！</strong></li>
<li>所以得到的ret就是错误号，<code>需要通过strerror来对错误号进行解读，说明错误原因</code></li>
</ul>
<h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><p><strong>函数原型</strong>：</p>
<p><code>pthread_t pthread_self(void)</code>：<strong>获取线程ID</strong>，其作用对应进程中getpid()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">//pthread_t 类型，在Linux下本质是无符号整数(%lu)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//返回值</span><br>成功:获取当前线程ID;<br></code></pre></td></tr></table></figure>























<h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg)</code>：<strong>创建一个新线程</strong>，其作用对应进程中fork()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">//pthread_t 类型，在Linux下本质是无符号整数(%lu)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> detachstate;  <span class="hljs-comment">//线程的分离状态</span><br>    <span class="hljs-type">int</span> schedpolicy;  <span class="hljs-comment">//线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;  <span class="hljs-comment">//线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;  <span class="hljs-comment">//线程的继承性</span><br>    <span class="hljs-type">int</span> scope;  <span class="hljs-comment">//线程的作用域</span><br>    <span class="hljs-type">size_t</span> guardsize;  <span class="hljs-comment">//线程栈末尾的警戒缓冲区大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;  <span class="hljs-comment">//线程的栈设置</span><br>    <span class="hljs-type">void</span>* stackaddr;  <span class="hljs-comment">//线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;  <span class="hljs-comment">//线程栈的大小</span><br>&#125;<span class="hljs-type">pthread_attr_t</span>;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread,<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>thread:传出参数，新创建的子线程ID;<br><br>attr:线程属性参数，通常传<span class="hljs-literal">NULL</span>，表示使用线程默认属性;<br><br>start_routine:函数指针，子线程回调函数。创建成功，pthread_create函数返回时，该函数会被自动调用;<br><br>arg:线程主函数执行期间所使用的参数(参数<span class="hljs-number">3</span>函数的参数，没有传<span class="hljs-literal">NULL</span>);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>















<p><strong>设置线程属性</strong></p>
<ul>
<li><code>pthread_attr_t</code>：线程属性结构体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> detachstate;  <span class="hljs-comment">//线程的分离状态</span><br>    <span class="hljs-type">int</span> schedpolicy;  <span class="hljs-comment">//线程调度策略</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sched_param</span> schedparam;  <span class="hljs-comment">//线程的调度参数</span><br>    <span class="hljs-type">int</span> inheritsched;  <span class="hljs-comment">//线程的继承性</span><br>    <span class="hljs-type">int</span> scope;  <span class="hljs-comment">//线程的作用域</span><br>    <span class="hljs-type">size_t</span> guardsize;  <span class="hljs-comment">//线程栈末尾的警戒缓冲区大小</span><br>    <span class="hljs-type">int</span> stackaddr_set;  <span class="hljs-comment">//线程的栈设置</span><br>    <span class="hljs-type">void</span>* stackaddr;  <span class="hljs-comment">//线程栈的位置</span><br>    <span class="hljs-type">size_t</span> stacksize;  <span class="hljs-comment">//线程栈的大小</span><br>&#125;<span class="hljs-type">pthread_attr_t</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_attr_init(pthread_attr_t *attr)</code>：<strong>初始化线程属性结构体</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>attr:传出参数,要初始化的线程属性结构体;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_attr_destroy(pthread_attr_t *attr)</code>：<strong>销毁线程属性所占用的资源</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>attr:要销毁的线程属性结构体;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate)</code>：<strong>设置线程属性是分离还是非分离状态</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>attr:线程属性结构体;<br><br>detachstate:分离状态;<br><span class="hljs-comment">//取值：</span><br>PTHREAD_CREATE_DETACHED:分离状态;<br>PTHREAD_CREATE_JOINABLE:非分离状态;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>















<p><strong>pthread_create()示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">//子线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//主线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),tid);<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：因为线程是不共享errno变量，所以直接返回的就是errno，<strong>所以得到的ret就是errno编号，需要通过strerror来对errno说明错误原因</strong></p>
</blockquote>
<p><strong>创建多个子线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-built_in">sleep</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--I&#x27;m %dth thread:pid=%d,tid=%lu\n&quot;</span>,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-comment">//因为线程共享i变量，而线程创建和启动可能会有延迟，可能会直到i改变了才开始运行，所以得定义一个局部变量，但是也有另一个方法</span><br>        <span class="hljs-type">int</span> *arg=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(i);<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,arg);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-comment">// sleep(i);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--I&#x27;m %dth thread:pid=%d,tid=%lu\n&quot;</span>,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,(<span class="hljs-type">void</span> *)&amp;i);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">sleep</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





















<p><strong>设置线程属性示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread：pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">pthread_attr_t</span> attr;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_init error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置线程分离</span><br>    <span class="hljs-built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);<br>    <span class="hljs-comment">//设置线程非分离</span><br>    <span class="hljs-comment">// pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_JOINABLE);</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_setdetachstate error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,&amp;attr,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_attr_destroy</span>(&amp;attr);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_attr_destroy error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



















<h4 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h4><p><strong>函数原型</strong>：</p>
<p><code>void pthread_exit(void *retval)</code>：<strong>退出当前线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>retval:表示线程退出状态(退出值)，无退出值，传<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li><strong>exit函数是退出进程的函数，所以不能使用exit退出线程</strong>，要不然会将这个进程杀死导致其他线程也被删除！</li>
<li>return是返回到调用者，也不是退出的意思，但是你也可以返回</li>
<li>pthread_exit是将调用该函数的线程退出</li>
</ul>
</blockquote>
<h4 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int pthread_join(pthread_t thread,void **retval)</code>：<strong>阻塞等待线程退出(回收指定线程)，获取线程退出状态</strong>。其作用对应进程中waitpid()函数，线程不回收跟进程一样会产生僵尸</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>thread:线程ID;<br><br>retval:传出参数，存储线程结束状态。因为线程结束回调函数返回值为<span class="hljs-type">void</span>*,所以接受返回值就需要<span class="hljs-type">void</span>**;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>











<p><strong>示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>&#123;<br>    <span class="hljs-type">int</span> var;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *tval;<br>    tval=(thrd *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> thrd));<br>    tval-&gt;var=<span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">strcpy</span>(tval-&gt;str,<span class="hljs-string">&quot;hello thread&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)tval;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *retval;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,(<span class="hljs-type">void</span> **)&amp;retval);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,retval-&gt;var,retval-&gt;str);<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>&#123;<br>    <span class="hljs-type">int</span> var;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-comment">/* struct thrd *tval;</span><br><span class="hljs-comment">    tval=(thrd *)malloc(sizeof(struct thrd)); */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span>* tval=(thrd *)arg;<br>    tval-&gt;var=<span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">strcpy</span>(tval-&gt;str,<span class="hljs-string">&quot;hello thread&quot;</span>);<br>    <span class="hljs-comment">//返回的是主线程的arg地址，所以我在回收后直接使用arg也可以的到返回值</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)tval;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> arg;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thrd</span> *retval;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,(<span class="hljs-type">void</span> *)&amp;arg);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,(<span class="hljs-type">void</span> **)&amp;retval);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,retval-&gt;var,retval-&gt;str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread exit with var=%d,str=%s\n&quot;</span>,arg.var,arg.str);<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>























<h4 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int pthread_detach(pthread_t thread)</code>：<strong>实现线程分离，可以将指定线程分离出线程组自立门户，线程结束后自动释放资源，不会残留资源在内核中</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>thread:待分离线程ID;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li><code>线程分离状态</code>：指定该状态，<strong>线程主动与主控线程断开关系，线程结束后，其退出状态不由其他线程获取，而直接自己自动释放</strong>。网络、多线程服务器常用！</li>
<li>进程若有该分离机制，将不会产生僵尸进程。</li>
<li><strong>也可以使用pthread_create函数参2(线程属性)来设置线程分离。</strong></li>
</ul>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> i,ret;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置线程分离,线程终止会自动清理pcb,无需回收</span><br>    ret=<span class="hljs-built_in">pthread_detach</span>(tid);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_detach error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;join ret=%d\n&quot;</span>,ret);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:I&#x27;m Main,pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//运行</span><br>&gt; ./test<br>thread:pid=<span class="hljs-number">12954</span>,tid=<span class="hljs-number">139659550131904</span><br>join ret=<span class="hljs-number">22</span><br>pthread_join error：Invalid argument  <span class="hljs-comment">//发现找不到这个线程，说明线程被pthread_detach分离了</span><br></code></pre></td></tr></table></figure>





















<h4 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h4><p><strong>函数原型</strong>：</p>
<p><code>int pthread_cancel(pthread_t thread)</code>：<strong>杀死(取消)线程</strong>，对应进程中的kill()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>thread:要杀死(取消)的线程ID;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li><strong>杀死(取消)一个线程，并不是立即杀死(取消)，而是得等到到达了一个取消点，再进行取消</strong></li>
<li><code>取消点</code>：<strong>是线程检查是否被取消，并按请求进行动作的一个位置，通常是一些系统调用的位置</strong>，可以用man 7 pthreads 查看具备这些取消点的系统调用列表</li>
<li><strong>被pthread_cancel()杀死的线程，将会返回-1，使用pthread_join()函数回收</strong></li>
</ul>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread：pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>    ret=<span class="hljs-built_in">pthread_cancel</span>(tid); <span class="hljs-comment">//终止线程</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_cancel error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>    <br>    <br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">//运行</span><br>&gt; ./test<br>main:pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482618086656</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br>thread：pid=<span class="hljs-number">17152</span>,tid=<span class="hljs-number">133482611214016</span><br><span class="hljs-comment">//将会打印5次thread就阻塞在主线程的while中则tid线程被终止了</span><br></code></pre></td></tr></table></figure>

























<h4 id="pthread-testcancel函数"><a href="#pthread-testcancel函数" class="headerlink" title="pthread_testcancel函数"></a>pthread_testcancel函数</h4><p><strong>函数原型</strong>：</p>
<p><code>void pthread_testcancel(void)</code>：<strong>为pthread_cancel函数自定义添加取消点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_testcancel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure>















<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//将以下两句注释则无法取消这个线程因为没有取消点</span><br>        <span class="hljs-comment">/* printf(&quot;thread：pid=%d,tid=%lu\n&quot;,getpid(),pthread_self());</span><br><span class="hljs-comment">        sleep(1); */</span><br>        <span class="hljs-built_in">pthread_testcancel</span>();  <span class="hljs-comment">//自定义取消点，添加取消点则线程可以被杀死</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main:pid=%d,tid=%lu\n&quot;</span>,<span class="hljs-built_in">getpid</span>(),<span class="hljs-built_in">pthread_self</span>());<br>    ret=<span class="hljs-built_in">pthread_cancel</span>(tid); <span class="hljs-comment">//终止线程</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_cancel error：%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//如果没有取消点，则将会一直阻塞在子线程的while(1)循环中</span><br></code></pre></td></tr></table></figure>

























<h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul>
<li><strong>malloc和mmap申请的内存可以被其他线程释放(因为线程共享内存)</strong></li>
<li><strong>应避免在多线程模型中调用fork，除非马上exec</strong>，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</li>
<li>信号的复杂语义很难和多线程共存，<strong>应避免在多线程引入信号机制</strong></li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>同步</code>：即协同步调，<strong>按预定的先后次序运行</strong></li>
<li><code>线程同步</code>：<strong>指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能</strong></li>
<li><strong>同步目的：为了避免数据混乱，解决与时间有关的错误</strong>。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制</li>
<li><strong>所有”多个控制流，共同操作一个共享资源”的情况，都需要同步</strong></li>
</ul>
<p><strong>数据混乱原因</strong>：</p>
<ol>
<li>资源共享</li>
<li>调度随机(意味着数据访问会出现竞争)</li>
<li>线程间缺乏必要的同步机制</li>
</ol>
<h3 id="互斥量-锁-mutex"><a href="#互斥量-锁-mutex" class="headerlink" title="互斥量(锁)mutex"></a>互斥量(锁)mutex</h3><p><strong>函数原型</strong>：</p>
<ul>
<li><code>pthread_mutex_t lock</code>：<strong>定义锁(创建锁)</strong></li>
</ul>
<blockquote>
<p>注：<strong>pthread_mutex_t类型</strong>，其本质是一个结构体，为简化理解，应用时可忽略其实现细节，<strong>简单当成整数看待</strong></p>
</blockquote>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr)</code>：<strong>初始化互斥</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex,<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:要初始化的互斥量(锁);<br><br>mutexattr:锁属性参数，通常传入<span class="hljs-literal">NULL</span>,表示默认属性;<br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_lock(pthread_mutex_t *mutex)</code>：<strong>加锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex)</code>：<strong>解锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code>：<strong>尝试加锁(非阻塞)，成功就加锁，失败则返回</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号 如：EBUSY;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code>：<strong>销毁互斥锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>mutex:互斥量(锁);<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>







<blockquote>
<p>注：</p>
<ul>
<li>互斥锁mutex变量的取值为0或1</li>
<li>尽量保证锁的粒度，越小越好**(访问贡献数据前加锁，访问结束立即解锁)**</li>
</ul>
</blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-comment">//定义一把互斥锁(需要全局变量)</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">tfn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">//加锁</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello &quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;world\n&quot;</span>);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_mutex_init error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid,<span class="hljs-literal">NULL</span>,tfn,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//初始化互斥锁,可以认为锁的值为1</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">//加锁,mutex--,阻塞线程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HELLO &quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WORLD\n&quot;</span>);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">//解锁，mutex++，唤醒阻塞在锁上的进程</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_join</span>(tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);   <span class="hljs-comment">//销毁互斥锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_mutex_destroy error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>















<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念</strong>：</p>
<ul>
<li>死锁是一种使用锁不恰当导致的现象，并不是一把锁</li>
</ul>
<p><strong>产生情况</strong>:</p>
<ol>
<li>对一个锁反复lock</li>
<li>两个线程，线程1持有A锁，请求B锁，线程2持有B锁，请求A锁，导致死循环</li>
</ol>
<h3 id="读写锁rwlock"><a href="#读写锁rwlock" class="headerlink" title="读写锁rwlock"></a>读写锁rwlock</h3><p><strong>概念</strong>：</p>
<ul>
<li>与互斥量类似，但<strong>读写锁</strong>允许更高的并行性。其特性为:<code>写独占，读共享</code></li>
<li><strong>以读方式给数据加锁 称之为读锁</strong></li>
<li><strong>以写方式给数据加锁 称之为写锁</strong></li>
</ul>
<p><strong>特性</strong>：</p>
<ul>
<li><strong>锁只有一把</strong></li>
<li><strong>写锁优先级高</strong></li>
<li><strong>写独占，读共享</strong></li>
</ul>
<p><strong>读写锁使用特性</strong>：</p>
<ol>
<li><strong>读写锁是”写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</strong></li>
<li><strong>读写锁是”读模式加锁”时，如果线程以读模式对其加锁会成功;如果线程以写模式对其加锁会阻塞</strong></li>
<li>读写锁是”读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程，那么读写锁会阻塞随后的读模式加锁请求。优先满足写模式锁。<code>读锁、写锁并行阻塞，写锁优先级高</code>。</li>
<li><strong>读写锁非常适合对于数据结构读的次数大于写的情况</strong></li>
</ol>
<p><strong>函数原型</strong>：</p>
<ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *rwlock,const pthread_rwlockattr_t attr)</code>：<strong>初始化读写锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock,<span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> attr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br>attr:读写锁属性参数，默认属性传<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_RWLOCK_INITIALIZER;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)</code>：<strong>读模式加锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)</code>：<strong>尝试以读模式加锁，成功就加锁，失败则返回</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)</code>：<strong>以写模式加锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)</code>：<strong>尝试以写模式加锁，成功就加锁，失败则返回</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)</code>：<strong>解锁</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)</code>：<strong>销毁读写锁属性所占用资源</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>rwlock:读写锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>



















<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> counter;<br><span class="hljs-comment">//定义一把读写锁(需要全局变量)</span><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">th_write</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span>*)arg;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        t=counter;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;======write %d: %lu:counter=%d ++counter=%d\n&quot;</span>,i,<span class="hljs-built_in">pthread_self</span>(),t,++counter);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">th_read</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-type">int</span> *)arg;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------read %d: %lu: %d\n&quot;</span>,i,<span class="hljs-built_in">pthread_self</span>(),counter);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">2000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> tid[<span class="hljs-number">8</span>];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//初始化读写锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_rwlock_init error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;++i)&#123;<br>        <span class="hljs-comment">// int *arg=new int(i);</span><br>        <span class="hljs-comment">// ret=pthread_create(&amp;tid[i],NULL,th_write,(void *)arg);   //以写模式加锁</span><br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid[i],<span class="hljs-literal">NULL</span>,th_write,(<span class="hljs-type">void</span> *)&amp;i);   <span class="hljs-comment">//以写模式加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>        <span class="hljs-comment">// int *arg=new int(i);</span><br>        <span class="hljs-comment">// ret=pthread_create(&amp;tid[i+3],NULL,th_read,(void *)arg);   //以读模式加锁</span><br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;tid[i+<span class="hljs-number">3</span>],<span class="hljs-literal">NULL</span>,th_read,(<span class="hljs-type">void</span> *)&amp;i);   <span class="hljs-comment">//以读模式加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_create error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;++i)&#123;<br>        ret=<span class="hljs-built_in">pthread_join</span>(tid[i], <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_join error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    ret=<span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);   <span class="hljs-comment">//销毁读写锁</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;pthread_rwlock_destroy error:%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>























<h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><ul>
<li><strong>条件变量本身不是锁，但是通常需要结合互斥锁来使用</strong></li>
</ul>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><ul>
<li><code>int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr)</code>：<strong>初始化条件变量</strong>，一般是动态初始化，在函数体用到再初始化，但是也可以使用静态初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *attr)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>attr:条件变量属性参数，默认属性传<span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex)</code>：</p>
<blockquote>
<p>函数作用：</p>
<ol>
<li><strong>阻塞等待一个条件cond满足</strong></li>
<li><strong>释放已掌握的互斥锁mutex(解锁)</strong></li>
<li><strong>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁(加锁)</strong></li>
</ol>
<p>1、2步是一个原子操作</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>mutex:已掌握的互斥锁;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_cond_timedwait(pthread_cond_t *cond,pthread_cond_mutex_t *mutex,const struct timespec *abstime)</code>：<strong>定时等待一个条件满足</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond,<span class="hljs-type">pthread_cond_mutex_t</span> *mutex,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abstime)</span></span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span>&#123;<br>    <span class="hljs-type">time_t</span> tv_sec;  <span class="hljs-comment">//秒</span><br>    <span class="hljs-type">long</span> tv_nsec;   <span class="hljs-comment">//纳秒</span><br>&#125;;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br>mutex:互斥锁;<br><br>abstime:定时时长,需要传绝对时间;<br>绝对时间:这里的绝对时间是从unix元年也就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>开始，假设abs_timeout=<span class="hljs-number">3</span>就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>日的<span class="hljs-number">0</span>点<span class="hljs-number">0</span>分<span class="hljs-number">3</span>秒;<br><br><span class="hljs-comment">//定时1秒示例</span><br><span class="hljs-type">time_t</span> cur=<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//获取当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> t; <span class="hljs-comment">//定义timespec结构体变量</span><br>t.tv_sec=cur+<span class="hljs-number">1</span>;   <span class="hljs-comment">//定时1秒</span><br>t.tv_nsec=t.tv_sec+<span class="hljs-number">100</span>;<br><span class="hljs-built_in">sem_timedwait</span>(&amp;sem,&amp;t);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_cond_signal(pthread_cond_t *cond)</code>：<strong>通知函数，一次通知至少一个线程</strong>，也可以唤醒多个线程，但是<strong>通常用于通知一个线程</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>pthread_cond_broadcast()</code>：<strong>广播函数，一次通知多个线程</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int pthread_cond_destroy(pthread_cond_t *cond)</code>：<strong>销毁条件变量属性所占用资源</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>cond:条件变量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:错误号;<br></code></pre></td></tr></table></figure>



















<h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p><strong>概念</strong>：</p>
<ul>
<li><code>生产者消费者模型</code>:<strong>由生产者进行生产数据，生产者生产的数据将会放置到一个公共区域，由消费者从公共区域拿取消费</strong></li>
</ul>
<p><strong>生产者模型工作流程</strong>：</p>
<ol>
<li>生产数据</li>
<li>加锁 pthread_mutex_lock</li>
<li>将数据放置到公共区域</li>
<li>解锁 pthread_mutex_unlock</li>
<li>通知阻塞在条件变量上的线程 pthread_cond_signal或pthread_cond_broadcast</li>
<li>循环生产后续数据</li>
</ol>
<p><strong>消费者模型工作流程</strong>：</p>
<ol>
<li>创建锁 mutex</li>
<li>初始化 pthread_mutex_init</li>
<li>加锁 pthread_mutex_lock</li>
<li>等待条件满足：pthread_cond_wait<ol>
<li>阻塞等条件变量</li>
<li>解锁 unlock</li>
<li>加锁 lock</li>
</ol>
</li>
<li>访问共享数据</li>
<li>解锁、释放条件变量，释放锁</li>
</ol>
<p><strong>实现示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *head;<br><br><span class="hljs-comment">//定义并初始化互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-comment">//定义并初始化条件变量</span><br><span class="hljs-type">pthread_cond_t</span> has_data=PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp=(msg *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> msg));<br>        mp-&gt;num=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;   <span class="hljs-comment">//模拟生产数据</span><br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,mp-&gt;num);<br><br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//头插法，写公共区域，将数据放置到公共区域</span><br>        mp-&gt;next=head;<br>        head=mp;<br>        ret=<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-comment">//通知消费者,唤醒阻塞在条件变量has_data上的线程</span><br>        ret=<span class="hljs-built_in">pthread_cond_signal</span>(&amp;has_data);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_signal error&quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            ret=<span class="hljs-built_in">pthread_cond_wait</span>(&amp;has_data,&amp;mutex);    <span class="hljs-comment">//阻塞等待条件变量,返回时会重新加锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_wait error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//消费数据，读数据</span><br>        <span class="hljs-comment">//头删法，取数据</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp;<br>        mp=head;<br>        head=mp-&gt;next;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer:%d\n&quot;</span>,mp-&gt;num);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁互斥量</span><br><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-built_in">free</span>(mp);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>多个消费者示例</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *head;<br><br><span class="hljs-comment">//定义并初始化互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-comment">//定义并初始化条件变量</span><br><span class="hljs-type">pthread_cond_t</span> has_data=PTHREAD_COND_INITIALIZER;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp=(msg *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> msg));<br>        mp-&gt;num=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;   <span class="hljs-comment">//模拟生产数据</span><br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,mp-&gt;num);<br><br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//头插法，写公共区域，将数据放置到公共区域</span><br>        mp-&gt;next=head;<br>        head=mp;<br>        ret=<span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-comment">//通知消费者,唤醒阻塞在条件变量has_data上的线程</span><br>        ret=<span class="hljs-built_in">pthread_cond_signal</span>(&amp;has_data);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_signal error&quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);   <span class="hljs-comment">//加锁</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_lock error&quot;</span>);<br>        <span class="hljs-comment">//循环等待，防止虚假唤醒</span><br>        <span class="hljs-keyword">while</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>            ret=<span class="hljs-built_in">pthread_cond_wait</span>(&amp;has_data,&amp;mutex);    <span class="hljs-comment">//阻塞等待条件变量,返回时会重新加锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_cond_wait error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//消费数据，读数据</span><br>        <span class="hljs-comment">//头删法，取数据</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *mp;<br>        mp=head;<br>        head=mp-&gt;next;<br>        <br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);   <span class="hljs-comment">//解锁互斥量</span><br><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_mutex_unlock error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),mp-&gt;num);<br>        <span class="hljs-built_in">free</span>(mp);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br><br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li><code>虚假唤醒</code>：因为pthread_cond_wait会进行解锁操作，多个消费者同时阻塞在一个锁上，<strong>容易导致一个线程消费数据解锁后，另一线程拿到锁，但是公共区域没有数据所导致的虚假唤醒</strong></li>
</ul>
</blockquote>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><ul>
<li><code>信号量</code>：是一个既能保证同步、数据不混乱，又能提高线程并发，<strong>可以用来实现多线程间对共享资源进行共享，相当于初始化为n的互斥量，n值表示可以同时访问共享数据区的线程数</strong></li>
<li><strong>可以应用于线程、进程间同步</strong></li>
</ul>
<h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><ul>
<li><code>int sem_init(sem_t *sem,int pshared,unsigned int value)</code>：<strong>初始化信号量</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量变量;<br><br>pshared:指定是否在线程、进程间共享;<br><span class="hljs-comment">//选择</span><br><span class="hljs-number">0</span>:表示线程间同步;<br><span class="hljs-number">1</span>(非<span class="hljs-number">0</span>):表示进程间同步;<br><br>value:N值，指定同时访问的线程数;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int sem_wait(sem_t *sem)</code>：<strong>相当于加锁，信号量值大于0，则信号量值-1；信号量等于0，则造成阻塞</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int sem_trywait(sem_t *sem)</code>：<strong>尝试加锁，成功则信号量-1，失败则返回，非阻塞的sem_wait</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int sem_timedwait(sem_t *sem,const struct timespec *abs_timeout)</code>：<strong>设置定时加锁，定时的sem_wait</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_timedwait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span></span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span>&#123;<br>    <span class="hljs-type">time_t</span> tv_sec;  <span class="hljs-comment">//秒</span><br>    <span class="hljs-type">long</span> tv_nsec;   <span class="hljs-comment">//纳秒</span><br>&#125;;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br>abs_timeout:定时时长，需要传绝对时间;<br>绝对时间:这里的绝对时间是从unix元年也就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>开始，假设abs_timeout=<span class="hljs-number">3</span>就是<span class="hljs-number">1970.1</span><span class="hljs-number">.1</span>日的<span class="hljs-number">0</span>点<span class="hljs-number">0</span>分<span class="hljs-number">3</span>秒;<br><br><span class="hljs-comment">//定时1秒示例</span><br><span class="hljs-type">time_t</span> cur=<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//获取当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> t; <span class="hljs-comment">//定义timespec结构体变量</span><br>t.tv_sec=cur+<span class="hljs-number">1</span>;   <span class="hljs-comment">//定时1秒</span><br>t.tv_nsec=t.tv_sec+<span class="hljs-number">100</span>;<br><span class="hljs-built_in">sem_timedwait</span>(&amp;sem,&amp;t);<br><br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int sem_post(sem_t *sem)</code>：<strong>相当于解锁，当信号量&lt;N，则信号量++；当信号量&#x3D;&#x3D;N时，则造成阻塞</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int sem_destroy(sem_t *sem)</code>：<strong>释放信号量属性所占用资源</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h可以应用于线程、进程间同步&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span></span>;<br><br><br><span class="hljs-comment">//参数</span><br>sem:信号量;<br><br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br><br>失败:<span class="hljs-number">-1</span>,errno;<br></code></pre></td></tr></table></figure>





















<h4 id="生产者消费者模型-1"><a href="#生产者消费者模型-1" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><p><strong>实现示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 5</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> queue[NUM];     <span class="hljs-comment">//全局数组实现环形队列</span><br><span class="hljs-type">sem_t</span> blank_num,prod_num;  <span class="hljs-comment">//共享区空余信号量，生产产品信号量</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">produser</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;blank_num);  <span class="hljs-comment">//要生产产品得减少空余信号量</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        queue[i]=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--produce:%d\n&quot;</span>,queue[i]);<br>        <span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">//生产成功产品，则产品信号量增加</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br><br>        i=(i+<span class="hljs-number">1</span>)%NUM;   <span class="hljs-comment">//借助下标实现环形</span><br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num);   <span class="hljs-comment">//消费产品，则产品信号量--(产品&gt;0)，否则阻塞</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),queue[i]);<br>        queue[i]=<span class="hljs-number">0</span>;<br>        ret=<span class="hljs-built_in">sem_post</span>(&amp;blank_num);  <span class="hljs-comment">//消费了产品，则产品信号量--</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid,cid;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    ret=<span class="hljs-built_in">sem_init</span>(&amp;blank_num,<span class="hljs-number">0</span>,NUM);  <span class="hljs-comment">//初始化空余信号量为5，线程间共享</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init blank_num error&quot;</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;prod_num,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//初始化产品信号量为0</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init prod_num error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;pid,<span class="hljs-literal">NULL</span>,produser,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create produser error&quot;</span>);<br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;cid,<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    <br>   <br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join produser error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_join</span>(cid,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<p><strong>多个消费者单个生产者示例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_CONSUMERS 3 <span class="hljs-comment">// 设置消费者数量</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">err_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> ret,std::string str)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s:%s\n&quot;</span>,str.<span class="hljs-built_in">c_str</span>(),<span class="hljs-built_in">strerror</span>(ret));<br>        <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> queue[NUM];     <span class="hljs-comment">//全局数组实现环形队列</span><br><span class="hljs-type">sem_t</span> blank_num,prod_num;  <span class="hljs-comment">//共享区空余信号量，生产产品信号量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;blank_num);  <span class="hljs-comment">//要生产产品得减少空余信号量</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        queue[i]=<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1000</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--producer:%d\n&quot;</span>,queue[i]);<br>        <span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">//生产成功产品，则产品信号量增加</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;   <span class="hljs-comment">//借助下标实现环形</span><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num);   <span class="hljs-comment">//消费产品，则产品信号量--(产品&gt;0)，否则阻塞</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        <br>        <span class="hljs-comment">// 循环等待直到读取到非零值</span><br>        <span class="hljs-keyword">while</span>(queue[i] == <span class="hljs-number">0</span>) &#123;<br>            ret=<span class="hljs-built_in">sem_post</span>(&amp;prod_num);  <span class="hljs-comment">// 恢复生产者信号量以防止死锁</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 小睡一会儿以防止忙等</span><br>            ret=<span class="hljs-built_in">sem_wait</span>(&amp;prod_num); <span class="hljs-comment">// 重新等待</span><br>            <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_wait error&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----consumer id:%lu :%d\n&quot;</span>,<span class="hljs-built_in">pthread_self</span>(),queue[i]);<br>        queue[i]=<span class="hljs-number">0</span>;<br>        ret=<span class="hljs-built_in">sem_post</span>(&amp;blank_num);  <span class="hljs-comment">//消费了产品，则产品信号量--</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_post error&quot;</span>);<br>        i=(i+<span class="hljs-number">1</span>)%NUM;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> producer_tid;<br>    <span class="hljs-type">pthread_t</span> consumer_tids[NUM_CONSUMERS];<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br>    ret=<span class="hljs-built_in">sem_init</span>(&amp;blank_num,<span class="hljs-number">0</span>,NUM);  <span class="hljs-comment">//初始化空余信号量为5，线程间共享</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init blank_num error&quot;</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;prod_num,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);   <span class="hljs-comment">//初始化产品信号量为0</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;sem_init prod_num error&quot;</span>);<br><br>    ret=<span class="hljs-built_in">pthread_create</span>(&amp;producer_tid,<span class="hljs-literal">NULL</span>,producer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create producer error&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; ++i) &#123;<br>        ret=<span class="hljs-built_in">pthread_create</span>(&amp;consumer_tids[i],<span class="hljs-literal">NULL</span>,consumer,<span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//消费者</span><br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_create consumer error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//回收生产者和消费者线程</span><br>    ret=<span class="hljs-built_in">pthread_join</span>(producer_tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join producer error&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CONSUMERS; ++i) &#123;<br>        ret=<span class="hljs-built_in">pthread_join</span>(consumer_tids[i],<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret!=<span class="hljs-number">0</span>) <span class="hljs-built_in">err_thread</span>(ret,<span class="hljs-string">&quot;pthread_join consumer error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>






                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux/" class="category-chain-item">Linux</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/" class="print-no-link">#后台开发</a>
      
        <a href="/tags/Linux/" class="print-no-link">#Linux</a>
      
        <a href="/tags/C-C/" class="print-no-link">#C/C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux系统编程</div>
      <div>https://moonfordream.github.io/posts/Linux系统编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Moon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构与算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/arch%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" title="arch安装与配置">
                        <span class="hidden-mobile">arch安装与配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://moon-twikoo.netlify.app/.netlify/functions/twikoo","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              Fluid.utils.listenDOMLoaded(function() {
                var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
                Fluid.plugins.imageCaption(imgSelector);
                Fluid.plugins.fancyBox(imgSelector);
              });
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/MoonforDream" target="_blank" rel="nofollow noopener"><span>Moon</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
