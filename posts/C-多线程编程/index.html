

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190208396.jpg">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190208396.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta name="google-site-verification" content="AjiazagGb4CIlb9bWWd66wgpHJ5-hhpbR58p3yYikbE" />
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Moon">
  <meta name="keywords" content="">
  
    <meta name="description" content="讲解C++中的多线程编程，并利用学到的技术实现线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="C++多线程编程">
<meta property="og:url" content="https://moonfordream.github.io/posts/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Moon&#39;s Blog">
<meta property="og:description" content="讲解C++中的多线程编程，并利用学到的技术实现线程池">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202407261638017.png">
<meta property="article:published_time" content="2024-07-26T08:36:30.000Z">
<meta property="article:modified_time" content="2024-07-26T08:39:06.081Z">
<meta property="article:author" content="Moon">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202407261638017.png">
  
  
  
  <title>C++多线程编程 - Moon&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/scrollAnimation.css">
<link rel="stylesheet" href="/css/selection.css">
<link rel="stylesheet" href="/css/mk.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"moonfordream.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Moon&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202405190159278.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++多线程编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-26 16:36" pubdate>
          2024年7月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          113 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="C++"
        id="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9" role="tab" data-toggle="collapse" href="#collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9"
        aria-expanded="true"
      >
        C++
        <span class="list-group-count">(7)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9"
           role="tabpanel" aria-labelledby="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/posts/C-Lambda%E5%87%BD%E6%95%B0/" title="C++Lambda函数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++Lambda函数</span>
        </a>
      
    
      
      
        <a href="/posts/C-RAII%E6%9C%BA%E5%88%B6/" title="C++RAII机制"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++RAII机制</span>
        </a>
      
    
      
      
        <a href="/posts/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="C++多线程编程"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">C++多线程编程</span>
        </a>
      
    
      
      
        <a href="/posts/C-%E5%AD%A6%E4%B9%A0/" title="C++学习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++学习</span>
        </a>
      
    
      
      
        <a href="/posts/C-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/" title="C++完美转发"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++完美转发</span>
        </a>
      
    
      
      
        <a href="/posts/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="C++智能指针"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C++智能指针</span>
        </a>
      
    
      
      
        <a href="/posts/%E5%85%B3%E4%BA%8Estd-ref%E5%87%BD%E6%95%B0/" title="关于std::ref函数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">关于std::ref函数</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++多线程编程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-多线程编程"><a href="#C-多线程编程" class="headerlink" title="C++多线程编程"></a>C++多线程编程</h1><h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h2><p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::thread threadname(_Callable&amp;&amp; __f,_Args&amp;&amp;... __args)</code>：<strong>创建一个线程类对象</strong>，传入线程执行函数作为thread类构造，threadname是自定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><br><span class="hljs-function">std::thread <span class="hljs-title">threadname</span><span class="hljs-params">(_Callable&amp;&amp; __f,_Args&amp;&amp;... __args)</span></span>;<br><br><span class="hljs-comment">//注意：threadname是你要创建的线程对象名，自定义的</span><br><br><span class="hljs-comment">//参数</span><br>__f:新线程的执行函数;<br><br>__args:新线程执行函数所需的参数;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void thread::join()</code>：线程类对象的成员方法，<strong>阻塞等待调用该函数的thread对象所绑定的子线程退出</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> __e = EINVAL;<br><br>    <span class="hljs-keyword">if</span> (_M_id != <span class="hljs-built_in">id</span>())<br>      __e = __gthread_join(_M_id._M_thread, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (__e)<br>      __throw_system_error(__e);<br><br>    _M_id = <span class="hljs-built_in">id</span>();<br>&#125;<br><br><br><br><span class="hljs-comment">//使用示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><br><span class="hljs-comment">//使用方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::string msg)</span></span>&#123;<br>    std::cout&lt;&lt;msg&lt;&lt;std::endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print,<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();   <span class="hljs-comment">//等待子线程t执行结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void thread::detach()</code>：线程类对象的成员方法，<strong>将调用该函数的thread对象所绑定的线程与主线程分离</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">thread::detach</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> __e = EINVAL;<br><br>    <span class="hljs-keyword">if</span> (_M_id != <span class="hljs-built_in">id</span>())<br>      __e = __gthread_detach(_M_id._M_thread);<br><br>    <span class="hljs-keyword">if</span> (__e)<br>      __throw_system_error(__e);<br><br>    _M_id = <span class="hljs-built_in">id</span>();<br>&#125;<br><br><br><span class="hljs-comment">//使用示例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::string msg)</span></span>&#123;<br>    std::cout&lt;&lt;msg&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-comment">//使用方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print,<span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">detach</span>();   <span class="hljs-comment">//将线程t与主线程分离，这样主线程结束，子线程t依然执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool thread::joinable()</code>：线程类对象的成员方法，<strong>判断线程是否可以join或者detach方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">joinable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> !(_M_id == <span class="hljs-built_in">id</span>()); &#125;<br><br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-number">0</span>:不可以调用;<br><span class="hljs-number">1</span>:可以调用;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>std::thread::id thread::get_id()</code>：线程类对象的成员方法，<strong>返回该线程对象的线程ID</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-function">id <span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> _M_id; &#125;<br><br><span class="hljs-keyword">using</span> native_handle_type=<span class="hljs-type">__gthread_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">pthread_t</span> <span class="hljs-type">__gthread_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">id</span>&#123;<br>    native_handle_type _M_thread;<br>&#125;<br><br><span class="hljs-comment">//id是thread类中的成员类，实际上就是pthread_t也就是unsigned long int类型</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>std::thread::id std::this_thread::get_id()</code>：<strong>可以直接调用这个用来获thread::id取当前线程ID</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> thread::id</span><br><span class="hljs-function"><span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLIBCXX_HAS_GTHREADS</span><br>  <span class="hljs-keyword">return</span> thread::<span class="hljs-built_in">id</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined _GLIBCXX_NATIVE_THREAD_ID</span><br>  <span class="hljs-keyword">return</span> thread::<span class="hljs-built_in">id</span>(_GLIBCXX_NATIVE_THREAD_ID);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-keyword">return</span> thread::<span class="hljs-built_in">id</span>(__gthread_self());<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void std::this_thread::sleep_for(time)</code>：<strong>用来让线程睡眠的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">sleep_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (__rtime &lt;= __rtime.<span class="hljs-built_in">zero</span>())<br>      <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">auto</span> __s = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::seconds&gt;(__rtime);<br>    <span class="hljs-keyword">auto</span> __ns = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(__rtime - __s);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _GLIBCXX_USE_NANOSLEEP</span><br>    <span class="hljs-keyword">struct</span> ::timespec __ts =<br>      &#123;<br>        <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">time_t</span>&gt;(__s.<span class="hljs-built_in">count</span>()),<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt;(__ns.<span class="hljs-built_in">count</span>())<br>      &#125;;<br>    <span class="hljs-keyword">while</span> (::<span class="hljs-built_in">nanosleep</span>(&amp;__ts, &amp;__ts) == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR)<br>      &#123; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	__sleep_for(__s, __ns);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><br><span class="hljs-comment">//参数列表：</span><br>__rtime:要设定的睡眠时间，是一个chrono对象，可以通过chrono中的nanoseconds设置纳秒，milliseconds设置毫秒，seconds设置秒数，minutes设置分钟，hours设置小时数;<br><br>注意：c++<span class="hljs-number">14</span>可以直接带上单位表示要设定的睡眠时间单位<br><br><br><br><span class="hljs-comment">//使用示例：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;线程函数foo执行&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-comment">//睡眠10s</span><br>    <span class="hljs-comment">//c++11</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>    <span class="hljs-comment">//c++14</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">10</span>s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th</span><span class="hljs-params">(foo)</span></span>;<br>    <span class="hljs-keyword">if</span>(th.<span class="hljs-built_in">joinable</span>())&#123;<br>        th.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据未定义错误"><a href="#数据未定义错误" class="headerlink" title="数据未定义错误"></a>数据未定义错误</h2><ol>
<li><p><code>传递临时变量问题</code>：</p>
<blockquote>
<ul>
<li><code>问题</code>：当我们在创建线程对象时，<strong>将临时变量作为线程函数参数传入，而我们的线程函数又需要的是引用类型对参数进行操作</strong>时，这将会导致<strong>线程函数执行时因临时变量被销毁，从而导致未定义行为</strong></li>
<li><code>解决方案</code>：<strong>将临时变量复制到一个持久的对象中，再将变量的引用传递给线程函数，这里需要对变量执行std::ref操作</strong>，涉及的问题就是thread的构造函数是一个模板函数，作为一个中转站而造成的数据推导不正确的错误，具体请见<a href="https://moonfordream.github.io/posts/%E5%85%B3%E4%BA%8Estd-ref%E5%87%BD%E6%95%B0/">关于std::ref函数</a></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//问题示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 传递临时变量</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//解决方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//因为主线程比子线程晚退出，所以当前局部变量x可以是一个持久对象</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 将变量复制到一个持久的对象中，但是是一个局部变量！</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(x))</span></span>; <span class="hljs-comment">// 将变量的引用传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>传递指针或引用指向局部变量问题</code>：</p>
<blockquote>
<ul>
<li><code>问题</code>：当我们进行创建线程对象时，<strong>将指针或引用指向的局部变量作为线程函数参数传入时，会导致线程函数执行时，指针或引用指向的局部变量被销毁</strong>，从而导致未定义错误</li>
<li><code>解决方案</code>：<strong>将指针或引用指向堆上的变量，或使用std::shared_ptr等智能指针来管理对象的生命周期</strong></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//问题示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 访问已经被销毁的指针</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, &amp;x)</span></span>; <span class="hljs-comment">// 传递指向局部变量的指针</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//解决方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* ptr)</span> </span>&#123;<br>    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 在使用完指针后，需要手动释放内存</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在堆上分配一个整数变量</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, ptr)</span></span>; <span class="hljs-comment">// 将指针传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>传递指针或引用指向已释放的内存问题</code>：</p>
<blockquote>
<ul>
<li><code>问题</code>：当我们进行创建线程对象时，<strong>将指针或引用指向已释放或即将释放的内存的变量作为参数传入到线程函数中，会导致线程函数执行时，访问不到参数指向的内存</strong>，从而导致未定义错误。</li>
<li><code>解决方案</code>：这个问题其实包含了以上两种问题，根据以上两种问题解决方法，可以总结出的解决方案就是<strong>将传入参数变量的被销毁或释放时间比线程函数的生命周期结束时晚即可</strong>，例如下面代码案例</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//问题示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 访问已经被释放的内存</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, *ptr)</span></span>; <span class="hljs-comment">// 传递已经释放的内存</span><br>    <span class="hljs-keyword">delete</span> ptr;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解决方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;    <span class="hljs-comment">//主线程比子线程晚退出，就间接让变量x的释放或销毁事件晚于子线程被销毁时间</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(foo, std::ref(x))</span></span>; <span class="hljs-comment">// 将变量的引用传递给线程</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>类成员方法作为入口函数，类对象被提前释放问题</code>：</p>
<blockquote>
<ul>
<li><code>问题</code>：当我们创建线程对象时，<strong>将类成员方法作为线程函数，而类对象在线程函数执行完被释放，这会导致程序崩溃或者产生未定义的行为</strong></li>
<li><code>解决方案</code>：<strong>可以使用std::shared_ptr来管理类对象的生命周期，确保在线程函数执行期间对象不会被销毁</strong></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//问题示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// do some work</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;MyClass::func, &amp;obj)</span></span>;<br>    <span class="hljs-comment">// obj 被提前销毁了，会导致未定义的行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//解决方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// do some work</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() <br>        &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;MyClass::func, obj)</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>类的私有成员方法作为入口函数问题</code>：</p>
<blockquote>
<ul>
<li><code>问题</code>：当我们创建线程对象时，<strong>将类的私有成员方法作为线程函数，因为私有的问题，将会导致线程无法访问线程函数</strong>，从而导致未定义错误</li>
<li><code>解决方案</code>：<strong>将类的私有成员方法定义为类的友元函数</strong></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//问题示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateFunc</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> <br>        &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; privateFunc&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myThreadFunc</span><span class="hljs-params">(MyClass* obj)</span> </span>&#123;<br>    obj-&gt;<span class="hljs-built_in">privateFunc</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(myThreadFunc, &amp;obj)</span></span>;<br>    thread_1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解决方案</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">myThreadFunc</span><span class="hljs-params">(MyClass* obj)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateFunc</span><span class="hljs-params">()</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> <br>        &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; privateFunc&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myThreadFunc</span><span class="hljs-params">(MyClass* obj)</span> </span>&#123;<br>    obj-&gt;<span class="hljs-built_in">privateFunc</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-function">std::thread <span class="hljs-title">thread_1</span><span class="hljs-params">(myThreadFunc, &amp;obj)</span></span>;<br>    thread_1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥锁-互斥量"><a href="#互斥锁-互斥量" class="headerlink" title="互斥锁(互斥量)"></a>互斥锁(互斥量)</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>互斥锁mutex</code>：<strong>用于解决多线程中数据共享问题以及实现线程同步</strong>，具体可见<a href="https://moonfordream.github.io/posts/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">Linux系统编程-线程同步</a></li>
<li>当<strong>多个线程都共享并且访问操作一个公共资源</strong>时，可能<strong>会发生多线程同时访问操作，导致数据的不正确性或者混乱</strong></li>
</ul>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::mutex mutex_name</code>：**定义锁(创建锁)**，mutex_name是自定义锁名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><br>std::mutex mx;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void mutex::lock() </code>：mutex类成员方法，<strong>用于加锁，阻塞等待锁资源</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//加锁</span><br>    mx.<span class="hljs-built_in">lock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void mutex::unlock()</code>：mutex类成员方法，<strong>用于解锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::mutex mx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//加锁</span><br>    mx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//do some things</span><br>    <span class="hljs-comment">//解锁</span><br>    mx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool mutex::try_lock()</code>：<strong>尝试加锁，加锁成功返回true,反之返回false</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br>std::mutex mx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!mx.<span class="hljs-built_in">try_lock</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;加锁失败&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;加锁成功&quot;</span>&lt;&lt;std::endl;<br>    mx.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>互斥锁的一些坑</strong>：</p>
<p><code>问题</code>：当我们<strong>需要多线程不断地按顺序抢占并使用公共资源</strong>时，我们会<strong>为公共资源进行加锁</strong>，但是<strong>因为一个线程在解锁之后通过循环又自己加锁的时间过于短暂</strong>，并且<strong>操作系统并非实时更新没有立刻将资源释放掉</strong>，<em>导致出现有一个线程一直占据公共资源的情况。</em></p>
<p>出现问题代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br>std::mutex mx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        mx.<span class="hljs-built_in">lock</span>();<br>        std::cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;[in]&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        mx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i)&#123;<br>        <span class="hljs-function">std::thread <span class="hljs-title">th</span><span class="hljs-params">(foo,i)</span></span>;<br>        th.<span class="hljs-built_in">detach</span>();<br>    &#125;<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>|| <span class="hljs-number">3</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br></code></pre></td></tr></table></figure>



<blockquote>
<p><code>解决方案</code>：</p>
<p>导致这种情况的发生是因为<strong>我们并没有给操作系统留够时间</strong>，让它更新释放资源，所以<strong>我们只需要在解锁之后加个休眠即可</strong></p>
</blockquote>
<p>解决代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br>std::mutex mx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        mx.<span class="hljs-built_in">lock</span>();<br>        std::cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;[in]&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        mx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;++i)&#123;<br>        <span class="hljs-function">std::thread <span class="hljs-title">th</span><span class="hljs-params">(foo,i)</span></span>;<br>        th.<span class="hljs-built_in">detach</span>();<br>    &#125;<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//运行结果</span><br>|| <span class="hljs-number">1</span>[in]<br>|| <span class="hljs-number">2</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br>|| <span class="hljs-number">1</span>[in]<br>|| <span class="hljs-number">2</span>[in]<br>|| <span class="hljs-number">3</span>[in]<br></code></pre></td></tr></table></figure>









<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念</strong>：</p>
<ul>
<li>死锁是一种使用锁不恰当导致的现象，并不是一把锁</li>
</ul>
<p><strong>产生情况</strong>:</p>
<ol>
<li>对一个锁反复lock</li>
<li>两个线程，线程1持有A锁，请求B锁，线程2持有B锁，请求A锁，导致死循环</li>
</ol>
<h3 id="超时锁"><a href="#超时锁" class="headerlink" title="超时锁"></a>超时锁</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>超时锁(timed_mutex)</code>：<strong>是一个可以设置时间的互斥锁</strong></li>
<li><strong>超时锁拥有互斥锁的所有成员函数</strong></li>
<li>超时锁可以<strong>适用于调试代码</strong>，查看线程竞争状态</li>
</ul>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::timed_mutex mutexname</code>：<strong>定义&#x2F;创建一把超时锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//tmx为锁名</span><br>std::timed_mutex tmx;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool timed_mutex::try_lock_for(time)</code>：<strong>为尝试加锁设置一个时间，当在时间之内加锁成功返回true,反之则返回false表示尝试加锁超时(失败)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;<br><span class="hljs-type">bool</span><br>_M_try_lock_for(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK</span><br>	<span class="hljs-keyword">using</span> __clock = chrono::steady_clock;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>	<span class="hljs-keyword">using</span> __clock = chrono::system_clock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">auto</span> __rt = chrono::<span class="hljs-built_in">duration_cast</span>&lt;__clock::duration&gt;(__rtime);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ratio_greater</span>&lt;__clock::period, _Period&gt;())<br>    	++__rt;<br>    <span class="hljs-keyword">return</span> _M_try_lock_until(__clock::<span class="hljs-built_in">now</span>() + __rt);<br>&#125;<br><br><span class="hljs-comment">//参数列表：</span><br>__rtime:要设定的睡眠时间，是一个chrono对象，可以通过chrono中的nanoseconds设置纳秒，milliseconds设置毫秒，seconds设置秒数，minutes设置分钟，hours设置小时数;<br><br><span class="hljs-comment">//使用示例</span><br>std::timed_mutex tmx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-keyword">if</span>(!tmx.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        std::cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;[in]&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        tmx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool timed_mutex::try_lock_until(time)</code>：<strong>为尝试加锁设置一个期限(也就是一个起始时间+等待时间等于目标时间)，当在期限之内加锁成功返回true(也就是加锁成功时间小于目标时间)，反之则返回false表示尝试加锁超时(失败)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Duration&gt;<br><span class="hljs-type">bool</span><br>_M_try_lock_until(<span class="hljs-type">const</span> chrono::time_point&lt;chrono::system_clock,<br>                   _Duration&gt;&amp; __atime)<br>&#123;<br>    <span class="hljs-keyword">auto</span> __s = chrono::<span class="hljs-built_in">time_point_cast</span>&lt;chrono::seconds&gt;(__atime);<br>    <span class="hljs-keyword">auto</span> __ns = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(__atime - __s);<br><br>    <span class="hljs-type">__gthread_time_t</span> __ts = &#123;<br>    <span class="hljs-built_in">static_cast</span>&lt;std::<span class="hljs-type">time_t</span>&gt;(__s.<span class="hljs-built_in">time_since_epoch</span>().<span class="hljs-built_in">count</span>()),<br>    <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt;(__ns.<span class="hljs-built_in">count</span>())<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Derived*&gt;(<span class="hljs-keyword">this</span>)-&gt;_M_timedlock(__ts);<br>&#125;<br><br><br><span class="hljs-comment">//参数列表</span><br>__atime:目标时间，使用;<br><br><br><span class="hljs-comment">//使用示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-keyword">if</span>(!tmx.<span class="hljs-built_in">try_lock_until</span>(std::chrono::system_clock::<span class="hljs-built_in">now</span>()+std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        //等价于</span><br><span class="hljs-comment">        if(!tmx.try_lock_for(std::chrono::seconds(1)))&#123;</span><br><span class="hljs-comment">            continue;</span><br><span class="hljs-comment">        &#125;*/</span><br>        std::cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;[in]&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        tmx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>注意</strong>：超时锁拥有互斥锁的所有成员函数，上面只展示互斥锁没有的成员函数</p>
</blockquote>
<h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>递归锁(recursive_mutex)</code>：是一种<strong>在锁已被持有的情况下，允许同一线程对该锁进行多次加锁的机制，也叫可重入锁</strong></li>
<li>在一些业务场景下，<strong>线程需要在获取锁后还会多次获取该锁，为了避免出现死锁或者程序崩溃异常，可以使用递归锁来解决</strong></li>
<li><strong>递归锁适用于组合业务</strong>(用到同一个锁)</li>
</ul>
<p><code>与互斥锁区别</code>：唯一的区别就是<strong>递归锁可重入，实质就是计数器，lock()计数器+1,unlock()计数器-1</strong></p>
<p><code>补充</code>：还有一个<code>递归超时锁recursive_timed_mutex</code>，在<strong>递归锁的机制加上了超时机制，跟超时锁的成员方法一样，只是具体实现不同</strong></p>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::recursive_mutex rmx</code>：<strong>定义&#x2F;创建递归锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//rmx为自己定义的递归锁名</span><br>std::recursive_mutex rmx;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void recursive_mutex::lock() </code>：<strong>用于加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::recursive_mutex rmx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//加锁</span><br>    rmx.<span class="hljs-built_in">lock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void recursive_mutex::unlock()</code>：<strong>用于解锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::recursive_mutex rmx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//加锁</span><br>    rmx.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">//do some things</span><br>    <span class="hljs-comment">//解锁</span><br>    rmx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool recursive_mutex::try_lock()</code>：<strong>尝试加锁，加锁成功返回true,反之返回false</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br>std::recursive_mutex rmx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!rmx.<span class="hljs-built_in">try_lock</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;加锁失败&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;加锁成功&quot;</span>&lt;&lt;std::endl;<br>    rmx.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：<strong>互斥锁和递归锁拥有同样的成员方法</strong>，唯一不同就是递归锁的成员方法实现与互斥锁不同</p>
</blockquote>
<h3 id="共享锁-读写锁"><a href="#共享锁-读写锁" class="headerlink" title="共享锁(读写锁)"></a>共享锁(读写锁)</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>共享锁</code>：<strong>是一把读时共享资源，写时互斥(独占)机制的锁</strong>，也叫做<a href="https://moonfordream.github.io/posts/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/#%E8%AF%BB%E5%86%99%E9%94%81rwlock">读写锁</a></li>
<li><strong>以读方式给数据加锁 称之为读锁</strong></li>
<li><strong>以写方式给数据加锁 称之为写锁</strong></li>
</ul>
<p><code>特性</code>：</p>
<ul>
<li><strong>锁只有一把</strong></li>
<li><strong>写锁优先级高</strong></li>
<li><strong>写独占，读共享</strong></li>
</ul>
<p><code>读写锁使用特性</code>：</p>
<ol>
<li><strong>读写锁是”写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</strong></li>
<li><strong>读写锁是”读模式加锁”时，如果线程以读模式对其加锁会成功;如果线程以写模式对其加锁会阻塞</strong></li>
<li>读写锁是”读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程，那么读写锁会阻塞随后的读模式加锁请求。优先满足写模式锁。<code>读锁、写锁并行阻塞，写锁优先级高</code>。</li>
<li><strong>读写锁非常适合对于数据结构读的次数大于写的情况</strong></li>
</ol>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::shared_mutex smx</code>：<strong>定义&#x2F;创建共享锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br><span class="hljs-comment">//smx是自己定义的共享锁名</span><br>std::shared_mutex smx;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void shared_mutex::lock_shared()</code>：<strong>阻塞等待获取读锁(共享锁)并进行加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    smx.<span class="hljs-built_in">lock_shared</span>();  <span class="hljs-comment">//读锁加锁</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;读锁(共享锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock_shared</span>();    <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void shared_mutex::unlock_shared()</code>：<strong>用于读锁(共享锁)解锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    smx.<span class="hljs-built_in">lock_shared</span>();  <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;读锁(共享锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock_shared</span>();    <span class="hljs-comment">//读锁解锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void shared_mutex::lock()</code>：<strong>用于阻塞等待获取写锁(互斥锁)并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    smx.<span class="hljs-built_in">lock</span>();    <span class="hljs-comment">//写锁加锁  </span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;写锁(互斥锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock</span>();    <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void shared_mutex::unlock()</code>：<strong>用于写锁(互斥锁)解锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    smx.<span class="hljs-built_in">lock</span>();    <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;写锁(互斥锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock</span>();    <span class="hljs-comment">//写锁解锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool shared_mutex::try_lock_shared()</code>：<strong>尝试获取读锁(共享锁)并加锁，成功返回true，否则返回false</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!smx.<span class="hljs-built_in">try_lock_shared</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;读锁(共享锁)尝试加锁失败&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;读锁(共享锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock_shared</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool shared_mutex::try_lock()</code>：<strong>尝试获取写锁(互斥锁)并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::shared_mutex smx;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!smx.<span class="hljs-built_in">try_lock</span>())&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;写锁(互斥锁)尝试加锁失败&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;写锁(互斥锁)加锁成功&quot;</span>&lt;&lt;std::endl;<br>    smx.<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="lock-guard类"><a href="#lock-guard类" class="headerlink" title="lock_guard类"></a>lock_guard类</h3><p><strong>概念</strong>：</p>
<ul>
<li><p><code>std::lock_guard</code> 是 C++ 标准库中的一种<strong>互斥量封装类</strong>，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题，<strong>自动对绑定的锁进行自动加解锁操作</strong></p>
</li>
<li><p><code>特性</code>：</p>
<blockquote>
<ul>
<li><strong>当lock_guard类的构造函数被调用时，绑定的互斥锁锁定</strong></li>
<li><strong>当lock_guard类的析构函数被调用时，绑定的互斥锁解锁</strong></li>
<li><code>std::lock_guard对象不能复制或移动</code>，因此它<strong>只能在局部作用域中使用</strong></li>
<li><code>不支持临时解锁</code>，也就是<strong>当未出栈区也就是类对象生命未结束之前，我们不能手动解锁</strong></li>
<li><code>禁止隐式转换</code></li>
</ul>
</blockquote>
</li>
<li><p>因为lock_guard利用的类对象生命周期结束调用析构函数进行解锁的，我们可以使用<code>&#123;&#125;</code>来<strong>进行控制临界区以及lock_guard的释放</strong></p>
</li>
</ul>
<p><strong>源码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Mutex&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Mutex mutex_type;<br>	<span class="hljs-comment">//lock_guard构造函数，explicit关键字是禁止隐式转换也就是需要传入参数的类型与我们传入的变量类型一致</span><br>    <span class="hljs-comment">//将传入的锁赋值给类成员_M_device,然后进行加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_type&amp; __m)</span> : _M_device(__m)</span><br><span class="hljs-function">    &#123;</span> _M_device.<span class="hljs-built_in">lock</span>(); &#125;<br>	<br>    <span class="hljs-comment">//重载的lock_guard构造函数，需多传入一个std::adopt_lock变量</span><br>    <span class="hljs-comment">//认定已经对锁加过锁，所以不做操作</span><br>    <span class="hljs-built_in">lock_guard</span>(mutex_type&amp; __m, <span class="hljs-type">adopt_lock_t</span>) <span class="hljs-keyword">noexcept</span> : _M_device(__m)<br>    &#123; &#125; <span class="hljs-comment">// calling thread owns mutex</span><br>	<br>    <span class="hljs-comment">//析构函数，用于对锁进行解锁操作</span><br>    ~<span class="hljs-built_in">lock_guard</span>()<br>    &#123; _M_device.<span class="hljs-built_in">unlock</span>(); &#125;<br>	<br>    <span class="hljs-comment">//对拷贝构造函数、赋值运算符进行禁用</span><br>    <span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>    lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>    mutex_type&amp;  _M_device;<br>&#125;;<br></code></pre></td></tr></table></figure>











<p><strong>使用案例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><br><span class="hljs-type">int</span> share=<span class="hljs-number">0</span>;<br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;++i)&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        m.lock();</span><br><span class="hljs-comment">        //已经加过锁，传入std::adopt_lock变量，不锁定，退出解锁</span><br><span class="hljs-comment">        std::lock_guard&lt;std::mutex&gt; lg(m,std::adopt_lock);</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        share++;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(foo)</span></span>;`禁止隐式转换`<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    std::cout&lt;&lt;share&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



























<h3 id="unique-lock类"><a href="#unique-lock类" class="headerlink" title="unique_lock类"></a>unique_lock类</h3><p><strong>概念</strong>：</p>
<ul>
<li><p><code>std::unique_lock</code> 是 C++11 标准库中的一种<strong>互斥量封装类</strong>，<strong>以独占模式管理锁资源</strong>，提供的方法比较多，<strong>能够比lock_guard更灵活地管理锁</strong>，同样的<strong>也拥有自动加解锁的功能</strong></p>
</li>
<li><p><code>特性</code>：</p>
<blockquote>
<ul>
<li><strong>std::unique_lock正常自动加锁以及解锁</strong></li>
<li><code>std::unique_lock对象是可移动的，能够移动构造以及赋值</code></li>
<li><code>支持多种构造函数</code>，例如延迟加锁，尝试加锁等</li>
<li><code>支持临时释放锁</code>，在unique_lock对象生命周期结束前，可以手动释放锁，释放后也可以重新加锁</li>
<li><code>禁止隐式转换</code></li>
<li><strong>提供多种成员方法</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>源码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Mutex&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> _Mutex mutex_type;<br>	<br>    <span class="hljs-comment">//默认构造函数，创建一个未关联任何互斥量的unique_lock对象</span><br>    <span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span><br>    : _M_device(<span class="hljs-number">0</span>), _M_owns(<span class="hljs-literal">false</span>)<br>    &#123; &#125;<br>	<span class="hljs-comment">//unique_lock构造函数，explicit关键字是禁止隐式转换也就是需要传入参数的类型与我们传入的变量类型一致</span><br>    <span class="hljs-comment">//将传入的锁赋值给类成员_M_device,_M_owns默认赋值为false,然后进行加锁，_M_owns变为true</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span><span class="hljs-params">(mutex_type&amp; __m)</span></span><br><span class="hljs-function">    : _M_device(std::__addressof(__m)), _M_owns(false)</span><br><span class="hljs-function">    &#123;</span><br>    	<span class="hljs-built_in">lock</span>();<br>    	_M_owns = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>	<span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个defer_lock变量</span><br>    <span class="hljs-comment">//可以延迟加锁，也就是可以先不加锁，在后面手动加锁，当类对象出栈区也就是类对象生命周期结束时，加锁了则释放锁，没加锁则不释放</span><br>    <span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">defer_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>    : _M_device(std::__addressof(__m)), _M_owns(<span class="hljs-literal">false</span>)<br>    &#123; &#125;<br>	<br>    <span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个try_to_lock变量</span><br>    <span class="hljs-comment">//不阻塞地尝试加锁，_M_owns根据try_lock()的返回结果决定，成功则拥有锁，出栈区释放锁，不成功则出栈区不进行释放锁</span><br>    <span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">try_to_lock_t</span>)<br>    : _M_device(std::__addressof(__m)), _M_owns(_M_device-&gt;<span class="hljs-built_in">try_lock</span>())<br>    &#123; &#125;<br>	<br>    <span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个adopt_lock变量</span><br>    <span class="hljs-comment">//默认已经拥有锁，所以不加锁，出栈区则释放锁</span><br>    <span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">adopt_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>    : _M_device(std::__addressof(__m)), _M_owns(<span class="hljs-literal">true</span>)<br>    &#123;<br>    	<span class="hljs-comment">// XXX calling thread owns mutex</span><br>    &#125;<br>	<br>    <span class="hljs-comment">//unique_lock的一个模板构造函数，需要传入互斥量对象的引用，以及一个时间点</span><br>    <span class="hljs-comment">//阻塞地尝试在传入的时间点之前进行获取锁，获取成功后，则出栈区后释放锁，获取失败，出栈区不释放</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">    <span class="hljs-title">unique_lock</span><span class="hljs-params">(mutex_type&amp; __m,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span></span><br><span class="hljs-function">    : _M_device(std::__addressof(__m)),</span><br><span class="hljs-function">    _M_owns(_M_device-&gt;try_lock_until(__atime))</span><br><span class="hljs-function">    &#123;</span> &#125;<br>	<br>    <span class="hljs-comment">//unique_lock的一个模板构造函数，需要传入互斥量对象的引用，以及一个持续时间(超时时间)</span><br>    <span class="hljs-comment">//阻塞地尝试在指定持续时间内(超时时间)内获取锁，获取成功后，则出栈区后释放锁，获取失败，出栈区不释放</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">    <span class="hljs-title">unique_lock</span><span class="hljs-params">(mutex_type&amp; __m,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function">    : _M_device(std::__addressof(__m)),</span><br><span class="hljs-function">    _M_owns(_M_device-&gt;try_lock_for(__rtime))</span><br><span class="hljs-function">    &#123;</span> &#125;<br><br>    <span class="hljs-comment">//unique_lock的析构函数，判断是否拥有锁，拥有则释放，没有则不释放</span><br>    ~<span class="hljs-built_in">unique_lock</span>()<br>    &#123;<br>    	<span class="hljs-keyword">if</span> (_M_owns)<br>    	    <span class="hljs-built_in">unlock</span>();<br>    &#125;<br>	<br>    <span class="hljs-comment">//禁用拷贝构造函数，以及拷贝赋值运算符</span><br>    <span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>	<br>    <span class="hljs-comment">//重载移动构造函数，转移对象使用权</span><br>    <span class="hljs-comment">//用来将临时对象和右值引用移动构造</span><br>    <span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; __u) <span class="hljs-keyword">noexcept</span><br>    : _M_device(__u._M_device), _M_owns(__u._M_owns)<br>    &#123;<br>   		__u._M_device = <span class="hljs-number">0</span>;<br>    	__u._M_owns = <span class="hljs-literal">false</span>;<br>    &#125;<br>	<br>    <span class="hljs-comment">//重载移动赋值运算符</span><br>    <span class="hljs-comment">//用来将临时对象和右值引用移动赋值给当前对象，并且转移了资源使用权</span><br>    unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; __u) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(_M_owns)<br>            <span class="hljs-built_in">unlock</span>();<br><br>        <span class="hljs-built_in">unique_lock</span>(std::<span class="hljs-built_in">move</span>(__u)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br><br>        __u._M_device = <span class="hljs-number">0</span>;<br>        __u._M_owns = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//加锁操作</span><br>    <span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行加锁</span><br>    <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">    <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!_M_device)<br>            __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>            __throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _M_device-&gt;<span class="hljs-built_in">lock</span>();<br>            _M_owns = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//尝试加锁操作</span><br>    <span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行尝试加锁</span><br>    <span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!_M_device)<br>            __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>            __throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock</span>();<br>            <span class="hljs-keyword">return</span> _M_owns;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞地尝试在指定时间点之前加锁操作</span><br>    <span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行try_lock_until</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">    _GLIBCXX_NODISCARD</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!_M_device)<br>        	__throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        	__throw_system_errodui <span class="hljs-built_in">xaingr</span>(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock_until</span>(__atime);<br>          <span class="hljs-keyword">return</span> _M_owns;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞地尝试在指定持续时间内加锁操作</span><br>    <span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行try_lock_for</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">    _GLIBCXX_NODISCARD</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">try_lock_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!_M_device)<br>        	__throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        	__throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock_for</span>(__rtime);<br>          <span class="hljs-keyword">return</span> _M_owns;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//解锁操作</span><br>    <span class="hljs-comment">//判断是否拥有锁，拥有则释放锁，没有则不释放</span><br>    <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">    <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!_M_owns)<br>            __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_device)<br>        &#123;<br>            _M_device-&gt;<span class="hljs-built_in">unlock</span>();<br>            _M_owns = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//重载交换操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">    <span class="hljs-title">swap</span><span class="hljs-params">(unique_lock&amp; __u)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(_M_device, __u._M_device);<br>        std::<span class="hljs-built_in">swap</span>(_M_owns, __u._M_owns);<br>    &#125;<br><br>    <span class="hljs-comment">//释放互斥锁关联，但不解锁</span><br>    <span class="hljs-function">mutex_type*</span><br><span class="hljs-function">    <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123;<br>        mutex_type* __ret = _M_device;<br>        _M_device = <span class="hljs-number">0</span>;<br>        _M_owns = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> __ret;<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否拥有锁</span><br>    <span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function">    <span class="hljs-type">bool</span></span><br><span class="hljs-function">    <span class="hljs-title">owns_lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> _M_owns; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">owns_lock</span>(); &#125;<br><br>    <span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function">    mutex_type*</span><br><span class="hljs-function">    <span class="hljs-title">mutex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> _M_device; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    mutex_type*	_M_device;	<span class="hljs-comment">//unique_lock管理的锁对象</span><br>    <span class="hljs-type">bool</span>		_M_owns;	<span class="hljs-comment">//锁资源的拥有权，true代表拥有，false代表没有</span><br>&#125;;<br><br><span class="hljs-comment">/// Swap overload for unique_lock objects.</span><br><span class="hljs-comment">/// @relates unique_lock</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Mutex&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">swap</span><span class="hljs-params">(unique_lock&lt;_Mutex&gt;&amp; __x, unique_lock&lt;_Mutex&gt;&amp; __y)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123; __x.<span class="hljs-built_in">swap</span>(__y); &#125;<br><br></code></pre></td></tr></table></figure>







<p><strong>常用函数和方法</strong>：</p>
<ul>
<li><p><code>explicit unique_lock(mutex_type&amp; __m)</code>：构造函数，<strong>使用给定的互斥量 __m 进行初始化，并对该互斥量进行加锁操作，出栈调用析构函数进行释放锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//unique_lock构造函数，explicit关键字是禁止隐式转换也就是需要传入参数的类型与我们传入的变量类型一致</span><br><span class="hljs-comment">//将传入的锁赋值给类成员_M_device,_M_owns默认赋值为false,然后进行加锁，_M_owns变为true</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span><span class="hljs-params">(mutex_type&amp; __m)</span></span><br><span class="hljs-function">: _M_device(std::__addressof(__m)), _M_owns(false)</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-built_in">lock</span>();<br>    _M_owns = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>unique_lock(mutex_type&amp; __m, defer_lock_t) noexcept</code>：构造函数，<strong>延迟加锁构造，使用给定的互斥量 __m 进行初始化，不进行加锁操作，手动进行加锁，出栈判断是否加锁来判断是否释放锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个defer_lock变量</span><br><span class="hljs-comment">//可以延迟加锁，也就是可以先不加锁，在后面手动加锁，当类对象出栈区也就是类对象生命周期结束时，加锁了则释放锁，没加锁则不释放</span><br><span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">defer_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>: _M_device(std::__addressof(__m)), _M_owns(<span class="hljs-literal">false</span>)<br>&#123; &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>unique_lock(mutex_type&amp; __m, try_to_lock_t) noexcept</code>：构造函数，<strong>不阻塞地尝试加锁构造，使用给定的互斥量 __m 进行初始化，并尝试对该互斥量进行加锁操作。如果加锁失败，则创建的unique_lock对象不与任何互斥量关联</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个try_to_lock变量</span><br><span class="hljs-comment">//不阻塞地尝试加锁，_M_owns根据try_lock()的返回结果决定，成功则拥有锁，出栈区释放锁，不成功则unique_lock对象没有与互斥量关联，出栈区不进行释放锁</span><br><span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">try_to_lock_t</span>)<br>: _M_device(std::__addressof(__m)), _M_owns(_M_device-&gt;<span class="hljs-built_in">try_lock</span>())<br>&#123; &#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>unique_lock(mutex_type&amp; __m, adopt_lock_t) noexcept</code>：构造函数，<strong>使用给定的互斥量 __m 进行初始化，默认已经拥有锁则不进行加锁操作，出栈释放锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//重载的unique_lock构造函数,需多传入一个adopt_lock变量</span><br><span class="hljs-comment">//默认已经拥有锁，所以不加锁，出栈区则释放锁</span><br><span class="hljs-built_in">unique_lock</span>(mutex_type&amp; __m, <span class="hljs-type">adopt_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>: _M_device(std::__addressof(__m)), _M_owns(<span class="hljs-literal">true</span>)<br>&#123;<br>    <span class="hljs-comment">// XXX calling thread owns mutex</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void lock()</code>：<strong>加锁操作，阻塞等待锁资源</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//加锁操作</span><br><span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行加锁</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_device)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        _M_device-&gt;<span class="hljs-built_in">lock</span>();<br>        _M_owns = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool try_lock()</code>：<strong>尝试加锁，加锁成功返回true,反之返回false</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//尝试加锁操作</span><br><span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行尝试加锁</span><br><span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_device)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock</span>();<br>        <span class="hljs-keyword">return</span> _M_owns;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool try_lock_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</code>：<strong>为尝试加锁设置一个时间，当在时间之内加锁成功返回true,反之则返回false表示尝试加锁超时(失败)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//阻塞地尝试在指定持续时间内加锁操作</span><br><span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行try_lock_for</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">try_lock_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_device)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock_for</span>(__rtime);<br>      <span class="hljs-keyword">return</span> _M_owns;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//参数</span><br>chrono对象:持续时间;<br>_Rep 和 _Period：分别表示持续时间的数值类型和时间单位;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool try_lock_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</code>：<strong>为尝试加锁设置一个期限(也就是一个起始时间+等待时间等于目标时间)，当在期限之内加锁成功返回true(也就是加锁成功时间小于目标时间)，反之则返回false表示尝试加锁超时(失败)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//阻塞地尝试在指定时间点之前加锁操作</span><br><span class="hljs-comment">//判断锁是否存在，判断是否拥有锁，存在则抛出错误，拥有则抛出异常，都没有就进行try_lock_until</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_device)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_owns)<br>        __throw_system_errodui <span class="hljs-built_in">xaingr</span>(<span class="hljs-built_in">int</span>(errc::resource_deadlock_would_occur));<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      _M_owns = _M_device-&gt;<span class="hljs-built_in">try_lock_until</span>(__atime);<br>      <span class="hljs-keyword">return</span> _M_owns;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//参数</span><br>chrono对象:时间点;<br>_Clock 和 _Duration：分别表示时间点类型和持续时间类型;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void unlock()</code>：<strong>解锁操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//解锁操作</span><br><span class="hljs-comment">//判断是否拥有锁，拥有则释放锁，没有则不释放</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_M_owns)<br>        __throw_system_error(<span class="hljs-built_in">int</span>(errc::operation_not_permitted));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_M_device)<br>    &#123;<br>        _M_device-&gt;<span class="hljs-built_in">unlock</span>();<br>        _M_owns = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="lock函数与scoped-lock类"><a href="#lock函数与scoped-lock类" class="headerlink" title="lock函数与scoped_lock类"></a>lock函数与scoped_lock类</h3><p><strong>概念</strong>：</p>
<ul>
<li>为了<code>避免死锁</code>，在<strong>c++11和c++17都推出一种解决方案，分别为lock函数和scoped_lock类</strong></li>
<li><code>lock函数</code>：<strong>可以同时锁住传入的多个锁</strong></li>
<li><code>scoped_lock类</code>：<strong>用于多个互斥体的免死锁RAII封装类</strong></li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><code>lock函数</code>：<strong>只完成加锁动作，并不会自动释放锁</strong></li>
<li><code>scoped_lock类</code>：相比较lock函数，<strong>scoped_lock类对象会在出栈时调用析构函数，对加的所有锁进行释放</strong></li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li><p><code>void lock(_L1&amp; __l1,_L2&amp; __l2,_L3&amp;... __l3)</code>：<strong>对多个传入的锁进行加锁，阻塞等待所有的锁都加锁成功</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">//函数原型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _L1, <span class="hljs-keyword">typename</span> _L2, <span class="hljs-keyword">typename</span>... _L3&gt;<br><span class="hljs-comment">//在函数体内对传入的锁进行循环加锁</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">lock</span><span class="hljs-params">(_L1&amp; __l1, _L2&amp; __l2, _L3&amp;... __l3)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201703L</span><br>	<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_same_v&lt;_L1, _L2&gt; &amp;&amp; (is_same_v&lt;_L1, _L3&gt; &amp;&amp; ...))</span></span><br><span class="hljs-function">	</span>&#123;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> _Np = <span class="hljs-number">2</span> + <span class="hljs-keyword">sizeof</span>...(_L3);<br>        unique_lock&lt;_L1&gt; __locks[] = &#123;<br>          &#123;__l1, defer_lock&#125;, &#123;__l2, defer_lock&#125;, &#123;__l3, defer_lock&#125;...<br>        &#125;;<br>        <span class="hljs-type">int</span> __first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            __locks[__first].<span class="hljs-built_in">lock</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> __j = <span class="hljs-number">1</span>; __j &lt; _Np; ++__j)<br>            &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> __idx = (__first + __j) % _Np;<br>                <span class="hljs-keyword">if</span> (!__locks[__idx].<span class="hljs-built_in">try_lock</span>())<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> __k = __j; __k != <span class="hljs-number">0</span>; --__k)<br>                        __locks[(__first + __k - <span class="hljs-number">1</span>) % _Np].<span class="hljs-built_in">unlock</span>();<br>                    __first = __idx;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> (!__locks[__first].<span class="hljs-built_in">owns_lock</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; __l : __locks)<br>            __l.<span class="hljs-built_in">release</span>();<br>	&#125;<br>	<span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#123;<br>      <span class="hljs-type">int</span> __i = <span class="hljs-number">0</span>;<br>      __detail::__lock_impl(__i, <span class="hljs-number">0</span>, __l1, __l2, __l3...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>scoped_lock(_MutexTypes&amp;... __m)</code>：<strong>对传入的锁全部加锁，阻塞等待所有的锁都加锁成功，当出栈时调用析构函数将所有锁释放掉</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数原型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _MutexTypes&gt;<br><span class="hljs-comment">//实质上调用了lock函数，释放则遍历释放</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_lock</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_lock</span><span class="hljs-params">(_MutexTypes&amp;... __m)</span> : _M_devices(std::tie(__m...))</span><br><span class="hljs-function">  &#123;</span> std::<span class="hljs-built_in">lock</span>(__m...); &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_lock</span><span class="hljs-params">(<span class="hljs-type">adopt_lock_t</span>, _MutexTypes&amp;... __m)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  : _M_devices(std::tie(__m...))</span><br><span class="hljs-function">  &#123;</span> &#125; <span class="hljs-comment">// calling thread owns mutex</span><br><br>  ~<span class="hljs-built_in">scoped_lock</span>()<br>  &#123; std::<span class="hljs-built_in">apply</span>([](<span class="hljs-keyword">auto</span>&amp;... __m) &#123; (__m.<span class="hljs-built_in">unlock</span>(), ...); &#125;, _M_devices); &#125;<br><br>  <span class="hljs-built_in">scoped_lock</span>(<span class="hljs-type">const</span> scoped_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>  scoped_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> scoped_lock&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>  tuple&lt;_MutexTypes&amp;...&gt; _M_devices;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>条件变量condition_variable</code>：能够<strong>使线程阻塞等待特定条件发生后，执行操作</strong>，利用”等待-&gt;唤醒”的机制，使得多线程同步</li>
<li><strong>相比较线程循环等待条件发生，阻塞等待条件的发生将线程唤醒，能够避免占用cpu资源</strong></li>
<li><code>条件变量通常需要结合互斥锁使用</code>来达到线程同步</li>
<li><code>使用场景</code>：条件变量也被常用于<a href="https://moonfordream.github.io/posts/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">生产者与消费者模型</a>中</li>
</ul>
<blockquote>
<p>注意：在condition_variable中，我们<strong>传入的锁参数都需要是一个unique_lock对象</strong>才行</p>
</blockquote>
<p><strong>条件变量使用步骤</strong>：</p>
<ol>
<li>创建一个condition_variable对象</li>
<li>创建一个mutex对象，用于保护临界区</li>
<li>用unique_lock对象管理创建的mutex对象</li>
<li>在需要等待特定条件实现的地方，使用wait()、wait_for()或wait_until()进行等待被唤醒</li>
<li>在特定条件实现的地方，使用notify_one()或notify_all()唤醒一个或全部阻塞在该条件变量的线程</li>
</ol>
<p><strong>函数原型</strong></p>
<ul>
<li><p><code>condition_variable cv</code>：构造函数，<strong>声明一个条件变量cv</strong></p>
</li>
<li><p><code>void wait(unique_lock&lt;mutex&gt;&amp; __lock)</code>：<strong>阻塞等待特定条件发生，并且会先释放拥有的锁，当被唤醒时，解除阻塞重新加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><br>std::condition_variable p;<br>std::mutex mx;<br><br><span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(mx)</span></span>;<br>    <span class="hljs-comment">//阻塞等待唤醒</span><br>    p.<span class="hljs-built_in">wait</span>(ul);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x);<br>    x++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(mx)</span></span>;<br>    <span class="hljs-keyword">while</span> (x--) &#123;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<br>            p.<span class="hljs-built_in">notify_one</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(foo2)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void wait(unique_lock&lt;mutex&gt;&amp; __lock,_Predicate __p)</code>：wait的重载版本，<strong>支持根据传入的函数__p的返回值来判断是否执行wait()阻塞，返回值为true则执行wait()阻塞，反之则不执行，当被唤醒时当且仅当函数__p为true时才解除阻塞</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Predicate&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; __lock, _Predicate __p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span> (!__p())<br>		<span class="hljs-built_in">wait</span>(__lock);<br>&#125;<br><br><span class="hljs-comment">//支持传入匿名函数</span><br>p.<span class="hljs-built_in">wait</span>(ul,[]&#123;<span class="hljs-keyword">return</span> x==<span class="hljs-number">0</span>;&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>cv_status wait_for(unique_lock&lt;mutex&gt;&amp; __lock,const chrono::duration&lt;_Rep,_Period&gt;&amp; __rtime)</code>：<strong>为wait操作设置一个期限，阻塞期间自动解锁，当在指定时间内被唤醒则返回no_timeout，当超时都未被唤醒返回timeout，wait_for返回后，解除阻塞并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">cv_status</span> &#123; no_timeout, timeout &#125;;<br><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">cv_status</span><br><span class="hljs-function"><span class="hljs-title">wait_for</span><span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; __lock,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">using</span> __dur = <span class="hljs-keyword">typename</span> steady_clock::duration;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_until</span>(__lock,steady_clock::<span class="hljs-built_in">now</span>() +<br>      chrono::__detail::<span class="hljs-built_in">ceil</span>&lt;__dur&gt;(__rtime));<br>&#125;<br><br><br><br><span class="hljs-comment">//参数</span><br>__lock:unqiue_lock对象;<br><br>__rtime:持续时间，使用std::chrono对象;<br><br><span class="hljs-comment">//返回值</span><br>成功:no_timeout;<br>失败:timeout;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool wait_for(unique_lock&lt;mutex&gt;&amp; __lock,const chrono::duration&lt;_Rep,_Period&gt;&amp; __rtime,_Predicate __p)</code>：<strong>重载的wait_for版本，阻塞时间自动解锁，当在指定时间内被其他线程唤醒并且__p的结果为true或__p为true直接唤醒则函数返回true，当在指定时间内被唤醒，但是__p结果为false则继续阻塞，当超时自动唤醒返回false，wait_for返回后解除阻塞并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period, <span class="hljs-keyword">typename</span> _Predicate&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">wait_for</span><span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; __lock,</span></span><br><span class="hljs-params"><span class="hljs-function">   <span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime,</span></span><br><span class="hljs-params"><span class="hljs-function">   _Predicate __p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> __dur = <span class="hljs-keyword">typename</span> steady_clock::duration;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">wait_until</span>(__lock,<br>          steady_clock::<span class="hljs-built_in">now</span>() +<br>          chrono::__detail::<span class="hljs-built_in">ceil</span>&lt;__dur&gt;(__rtime),<br>          std::<span class="hljs-built_in">move</span>(__p));<br>&#125;<br><br><br><span class="hljs-comment">//参数</span><br>__lock:unqiue_lock对象;<br><br>__rtime:持续时间，使用std::chrono对象;<br><br>__p:传入一个函数作为判断参数;<br><br><span class="hljs-comment">//返回值</span><br>成功:<span class="hljs-number">0</span>;<br>失败:<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>cv_status wait_until(unique_lock&lt;mutex&gt;&amp; __lock,const chrono::time_point&lt;_Clock,_Duration&gt;&amp; __atime)</code>：<strong>为wait操作设置一个时间点，阻塞期间自动解锁，当在时间点之前被唤醒则返回no_timeout，当超过时间点都未被唤醒返回timeout，wait_until返回后，解除阻塞并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>注:wait_until的_Clock可以直接使用steady_clock和system_clock<br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">cv_status</span><br><span class="hljs-function"><span class="hljs-title">wait_until</span><span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; __lock,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt; 201703L</span><br>	<span class="hljs-built_in">static_assert</span>(chrono::is_clock_v&lt;_Clock&gt;);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">using</span> __s_dur = <span class="hljs-keyword">typename</span> <span class="hljs-type">__clock_t</span>::duration;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> _Clock::time_point __c_entry = _Clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">__clock_t</span>::time_point __s_entry = <span class="hljs-type">__clock_t</span>::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> __delta = __atime - __c_entry;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> __s_atime = __s_entry +<br>    chrono::__detail::<span class="hljs-built_in">ceil</span>&lt;__s_dur&gt;(__delta);<br><br>	<span class="hljs-keyword">if</span> (__wait_until_impl(__lock, __s_atime) == cv_status::no_timeout)<br>		<span class="hljs-keyword">return</span> cv_status::no_timeout;<br><span class="hljs-comment">// We got a timeout when measured against __clock_t but</span><br><span class="hljs-comment">// we need to check against the caller-supplied clock</span><br><span class="hljs-comment">// to tell whether we should return a timeout.</span><br>	<span class="hljs-keyword">if</span> (_Clock::<span class="hljs-built_in">now</span>() &lt; __atime)<br>		<span class="hljs-keyword">return</span> cv_status::no_timeout;<br>	<span class="hljs-keyword">return</span> cv_status::timeout;<br>&#125;<br><br><span class="hljs-comment">//实质上调用了__wait_until_impl转换__Clock类型为steady_clock或system_clock然后再调用wait_until</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool wait_until(unique_lock&lt;mutex&gt;&amp; __lock,const chrono::time_point&lt;_Clock,_Duration&gt;&amp; __atime,_Predicate __P)</code>：<strong>重载的wait_until版本，阻塞时间自动解锁，当在指定时间点之前被其他线程唤醒并且__p的结果为true或__p为true直接唤醒则函数返回true，当在指定时间点之前被唤醒，但是__p结果为false则继续阻塞，当超时自动唤醒返回false，wait_until返回后解除阻塞并加锁</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration, <span class="hljs-keyword">typename</span> _Predicate&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">wait_until</span><span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; __lock,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime,</span></span><br><span class="hljs-params"><span class="hljs-function"> _Predicate __p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span> (!__p())<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">wait_until</span>(__lock, __atime) == cv_status::timeout)<br>			<span class="hljs-keyword">return</span> __p();<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void notify_one()</code>：是condition_variable类成员方法，<strong>唤醒阻塞在调用该方法的条件变量的线程中的一个线程</strong></p>
</li>
<li><p><code>void notify_all()</code>：是condition_variable类成员方法，<strong>唤醒阻塞在调用该方法的条件变量的所有线程</strong></p>
</li>
</ul>
<blockquote>
<p>注意：以上函数皆是condition_variable类成员函数</p>
</blockquote>
<h2 id="线程异步"><a href="#线程异步" class="headerlink" title="线程异步"></a>线程异步</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>概念</strong>：</p>
<ul>
<li><strong>多线程是实现异步的手段</strong></li>
<li><code>异步</code>：当<strong>需要执行一个任务时，会立即返回，但是不会立即得到结果，当任务执行完后会通知或者以回调函数方式返回结果</strong>。</li>
<li>例子：当我们网购了一个东西的时候，我们并不会就在那里干等看着快递信息，而是该干嘛干嘛，等待快递到了，快递员通知我们的时候，我们就可以去拿快递并处理</li>
<li>应用于长时间执行的任务，避免阻碍主线程执行其他任务。</li>
</ul>
<p><code>区别</code>：</p>
<ul>
<li><strong>同步</strong>：是只有一条时间线，当我开始执行任务时，<strong>需要等待该任务执行完返回结果后才会进行下一个任务</strong></li>
<li><strong>异步</strong>：开始执行任务时，<strong>并不会阻塞等待该任务执行完，而是会继续执行后续任务</strong>，当任务结果返回时通知执行者处理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/MoonforDream/photohouse/hexo/202407261638017.png" srcset="/img/loading.gif" lazyload alt="image-20240722175411234"></p>
<p><code>C++异步操作的三种方式</code>：</p>
<ol>
<li><strong>std::promise</strong>：</li>
<li><strong>std::packaged_task</strong></li>
<li><strong>std::async</strong></li>
</ol>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>std::future</code>：是一个类，<strong>用来存储异步操作的返回值，提供了获取&#x2F;访问异步操作结果的机制</strong></li>
<li><strong>C++异步操作三种方式都需要future对象进行存储异步操作结果</strong></li>
</ul>
<p><strong>问题</strong>：</p>
<ol>
<li><p><code>当future对象作为参数传入线程时，一定需要使用move语句</code></p>
<blockquote>
<p>原因：因为<strong>thread的构造函数是接受一个右值参数</strong>，因此<strong>需要使用move将左值转为右值</strong>，并且不使用move会复制一份</p>
</blockquote>
</li>
<li><p><code>当future对象以引用方式作为参数传入线程时,使用ref语句传入引用</code></p>
<blockquote>
<p>原因：<strong>避免因为泛型编程的原因导致类型推导偏差</strong>，所以需要使用ref传入引用，具体可见<a href="https://moonfordream.github.io/posts/%E5%85%B3%E4%BA%8Estd-ref%E5%87%BD%E6%95%B0/">关于std::ref函数</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>注意：<strong>建议使用第一种方式，因为使用move是会转移资源使用权，这样就避免出现多个future对象，然后避免误操作多次调用get方法报错</strong></p>
</blockquote>
<p><strong>函数原型</strong>：</p>
<ul>
<li><p><code>std::future&lt;_Res&gt; __f</code>：<strong>future类的构造函数</strong>，继承__basic_future类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Res&gt;<br><span class="hljs-keyword">typedef</span> __basic_future&lt;_Res&gt; _Base_type;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">future</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> : _Base_type() &#123;</span> &#125;<br><br><span class="hljs-comment">//使用</span><br><span class="hljs-comment">//定义一个返回值为int型的future对象</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; __f;<br><br><br><span class="hljs-comment">//特性</span><br><br><span class="hljs-comment">// 支持移动构造</span><br><span class="hljs-built_in">future</span>(future&amp;&amp; __uf) <span class="hljs-keyword">noexcept</span> : _Base_type(std::<span class="hljs-built_in">move</span>(__uf)) &#123; &#125;<br><br><span class="hljs-comment">//禁用拷贝构造和拷贝赋值</span><br><span class="hljs-built_in">future</span>(<span class="hljs-type">const</span> future&amp;) = <span class="hljs-keyword">delete</span>;<br>future&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> future&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">//支持移动赋值</span><br>future&amp; <span class="hljs-keyword">operator</span>=(future&amp;&amp; __fut) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-built_in">future</span>(std::<span class="hljs-built_in">move</span>(__fut))._M_swap(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>_Res get()</code>：future类的成员函数，<strong>阻塞等待获取异步操作的返回值，将结果返回</strong>(每个异步操作类都在内部实现存储了一个future对象，只需将其取出即可调用get获取返回值)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Res&gt;<br><span class="hljs-keyword">typedef</span> __basic_future&lt;_Res&gt; _Base_type;<br><span class="hljs-function">_Res</span><br><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">typename</span> _Base_type::_Reset __reset(*<span class="hljs-keyword">this</span>);<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">this</span>-&gt;_M_get_result()._M_value());<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; __f;<br><span class="hljs-type">int</span> a=__f.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：<strong>get方法一旦调用一次后，std::future对象的状态就会变为已获取（ready），即不再关联任何异步操作的结果，再次调用则会抛出异常</strong></p>
</blockquote>
</li>
<li><p><code>void wait()</code>：<strong>等待结果成功返回</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    _State_base::_S_check(_M_state);<br>    _M_state-&gt;<span class="hljs-built_in">wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>future_status wait_for(const chrono::duration&lt;_Rep,_Period&gt;&amp; __rel)</code>：<strong>设定一个超时时间(持续时间)，在持续时间内异步结果返回则函数返回ready，超时还未获得结果则返回timeout</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">future_status</span><br>&#123;<br>    ready,<br>    timeout,<br>    deferred<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Rep, <span class="hljs-keyword">typename</span> _Period&gt;</span><br><span class="hljs-function">future_status</span><br><span class="hljs-function"><span class="hljs-title">wait_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rel)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  _State_base::_S_check(_M_state);<br>  <span class="hljs-keyword">return</span> _M_state-&gt;<span class="hljs-built_in">wait_for</span>(__rel);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>future_status wait_until(const chrono::time_point&lt;_Clock,_Duration&gt;&amp; __abs)</code>：<strong>设定一个时间点，在时间点之前异步结果返回则函数返回ready，超过时间点还未获得结果则返回timeout</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;future?</span><br><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">future_status</span><br>&#123;<br>    ready,<br>    timeout,<br>    deferred<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Clock, <span class="hljs-keyword">typename</span> _Duration&gt;</span><br><span class="hljs-function">future_status</span><br><span class="hljs-function"><span class="hljs-title">wait_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __abs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  _State_base::_S_check(_M_state);<br>  <span class="hljs-keyword">return</span> _M_state-&gt;<span class="hljs-built_in">wait_until</span>(__abs);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>std::promise</code>：异步操作中自由度最高，<strong>用于异步传输变量</strong>，<code>可以在任务执行的任意时候都能拿到返回值</code>，不是将任务结果返回，而是<strong>自定义选择传输结果</strong>，<strong>std::promise提供存储异步通信的值，再通过其对象创建的std::future异步获得结果</strong></li>
<li><code>void传输</code>：既然是自定义传输，我们也可以选择void也就是不传输，那么<strong>std::promise就只起到一个通知作用，不需要关心返回值类型</strong></li>
</ul>
<blockquote>
<p>注：</p>
<ul>
<li><strong>每一个promise对象只能设置一次值，也就是调用一次set_value()</strong></li>
<li><strong>可以提前拿出future对象</strong></li>
</ul>
</blockquote>
<p><strong>问题</strong>：</p>
<ol>
<li><p><code>当promise对象作为参数传入线程时，一定需要使用move语句</code></p>
<blockquote>
<p>原因：因为<strong>thread的构造函数是接受一个右值参数</strong>，因此<strong>需要使用move将左值转为右值</strong>，并且不使用move会复制一份</p>
</blockquote>
</li>
<li><p><code>当promise对象以引用方式作为参数传入线程时,使用ref语句传入引用</code></p>
<blockquote>
<p>原因：<strong>避免因为泛型编程的原因导致类型推导偏差</strong>，所以需要使用ref传入引用，具体可见<a href="https://moonfordream.github.io/posts/%E5%85%B3%E4%BA%8Estd-ref%E5%87%BD%E6%95%B0/">关于std::ref函数</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>注意：<strong>建议使用第一种方式，因为使用move是会转移资源使用权，这样就避免出现多个promise对象，然后避免误操作多次调用set_value方法报错</strong></p>
</blockquote>
<p><strong>常用函数以及原型</strong>：</p>
<ul>
<li><p><code>std::promise&lt;_Res&gt; ps</code>：std::promise构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Res&gt;<br><span class="hljs-keyword">typedef</span> __future_base::_State_base 	_State;<br><span class="hljs-keyword">typedef</span> __future_base::_Result&lt;_Res&gt;	_Res_type;<br><br><br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">promise</span>()<br>: _M_future(std::<span class="hljs-built_in">make_shared</span>&lt;_State&gt;()),<br>_M_storage(<span class="hljs-keyword">new</span> _Res_type())<br>&#123; &#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">promise</span>()<br>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(_M_future) &amp;&amp; !_M_future.<span class="hljs-built_in">unique</span>())<br>  	_M_future-&gt;_M_break_promise(std::<span class="hljs-built_in">move</span>(_M_storage));<br>&#125;<br><br><br><br><span class="hljs-comment">//特性</span><br><span class="hljs-comment">//支持移动构造和移动赋值</span><br><span class="hljs-built_in">promise</span>(promise&amp;&amp; __rhs) <span class="hljs-keyword">noexcept</span><br>: _M_future(std::<span class="hljs-built_in">move</span>(__rhs._M_future)),<br>_M_storage(std::<span class="hljs-built_in">move</span>(__rhs._M_storage))<br>&#123; &#125;<br><br>promise&amp;<br><span class="hljs-keyword">operator</span>=(promise&amp;&amp; __rhs) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-built_in">promise</span>(std::<span class="hljs-built_in">move</span>(__rhs)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//禁用拷贝构造和拷贝赋值</span><br><span class="hljs-built_in">promise</span>(<span class="hljs-type">const</span> promise&amp;) = <span class="hljs-keyword">delete</span>;<br>promise&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> promise&amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>future&lt;_Res&gt; get_future()</code>：<strong>获取promise对象内部的future对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数原型</span><br><span class="hljs-function">future&lt;_Res&gt;</span><br><span class="hljs-function"><span class="hljs-title">get_future</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">future</span>&lt;_Res&gt;(_M_future); &#125;<br><br><span class="hljs-comment">//使用</span><br>std::promise&lt;<span class="hljs-type">int</span>&gt; ps;<br><span class="hljs-keyword">auto</span> f=ps.<span class="hljs-built_in">get_future</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void set_value(_Res&amp;&amp; __r)</code>：<strong>设置异步传输值，并存储到内部future对象中</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-comment">//左值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">const</span> _Res&amp; __r)</span></span><br><span class="hljs-function"></span>&#123; _M_state()._M_set_result(_State::__setter(<span class="hljs-keyword">this</span>, __r)); &#125;<br><br><span class="hljs-comment">//右值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">set_value</span><span class="hljs-params">(_Res&amp;&amp; __r)</span></span><br><span class="hljs-function"></span>&#123; _M_state()._M_set_result(_State::__setter(<span class="hljs-keyword">this</span>, std::<span class="hljs-built_in">move</span>(__r))); &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//传入引用则需要使用ref语句</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;ps)</span></span>&#123;<br>    ps.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//传入对象则需要move语句</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">int</span>&gt; f)</span></span>&#123;<br>    <span class="hljs-type">int</span> x=f.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; p;<br>    <span class="hljs-keyword">auto</span> f=p.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo,std::ref(p))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(foo2,std::move(f))</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>















<h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><p><strong>概念</strong>：</p>
<ul>
<li><code>std::packaged_task</code>：是一个包装器，<strong>用来将函数包装称packaged_task对象，用于异步调用，函数返回值存储在内部future对象中</strong>,<code>必须等到任务执行完毕，才能从future对象拿到返回值</code></li>
<li><strong>特性</strong>：不能自主调用包装的函数(后台运行)，<strong>需要手动启动包装的函数</strong></li>
</ul>
<p><strong>问题</strong>：</p>
<ol>
<li><p><code>当packaged_task对象作为参数传入线程时，一定需要使用move语句</code></p>
<blockquote>
<p>原因：因为<strong>thread的构造函数是接受一个右值参数</strong>，因此<strong>需要使用move将左值转为右值</strong>，并且不使用move会复制一份</p>
</blockquote>
</li>
<li><p><code>当packaged_task对象以引用方式作为参数传入线程时,使用ref语句传入引用</code></p>
<blockquote>
<p>原因：<strong>避免因为泛型编程的原因导致类型推导偏差</strong>，所以需要使用ref传入引用，具体可见<a href="https://moonfordream.github.io/posts/%E5%85%B3%E4%BA%8Estd-ref%E5%87%BD%E6%95%B0/">关于std::ref函数</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>注意：<strong>建议使用第一种方式，因为使用move是会转移资源使用权，这样就避免出现多个packaged_task对象，然后避免误操作多次启动函数，导致future对象get方法不知道取哪个对象的返回值而报错</strong></p>
</blockquote>
<p><strong>常用函数以及原型</strong>：</p>
<ul>
<li><p><code>std::packaged_task&lt;_Res(_ArgTypes...)&gt; task(_Fn&amp;&amp; __fn)</code>：packaged_task构造函数，<strong>传入要包装的函数，以及指定函数返回值类型以及参数类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Res, <span class="hljs-keyword">typename</span>... _ArgTypes&gt;<br><br><span class="hljs-keyword">typedef</span> __future_base::_Task_state_base&lt;_Res(_ArgTypes...)&gt; _State_type;<br>shared_ptr&lt;_State_type&gt;                   _M_state;<br><br><span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Fn, <span class="hljs-keyword">typename</span> = __not_same&lt;_Fn&gt;&gt;<br><span class="hljs-keyword">explicit</span><br><span class="hljs-built_in">packaged_task</span>(_Fn&amp;&amp; __fn)<br>: _M_state(__create_task_state&lt;_Res(_ArgTypes...)&gt;(std::forward&lt;_Fn&gt;(__fn)))<br>&#123; &#125;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Signature, <span class="hljs-keyword">typename</span> _Fn,<br><span class="hljs-keyword">typename</span> _Alloc = std::allocator&lt;<span class="hljs-type">int</span>&gt;&gt;<br><span class="hljs-type">static</span> shared_ptr&lt;__future_base::_Task_state_base&lt;_Signature&gt;&gt;<br>__create_task_state(_Fn&amp;&amp; __fn, <span class="hljs-type">const</span> _Alloc&amp; __a = _Alloc())<br>&#123;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> decay&lt;_Fn&gt;::type _Fn2;<br>    <span class="hljs-keyword">typedef</span> __future_base::_Task_state&lt;_Fn2, _Alloc, _Signature&gt; _State;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">allocate_shared</span>&lt;_State&gt;(__a, std::forward&lt;_Fn&gt;(__fn), __a);<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">packaged_task</span>()<br>&#123;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(_M_state) &amp;&amp; !_M_state.<span class="hljs-built_in">unique</span>())<br>		_M_state-&gt;_M_break_promise(std::<span class="hljs-built_in">move</span>(_M_state-&gt;_M_result));<br>&#125;<br><br><span class="hljs-comment">//特性</span><br><span class="hljs-comment">//禁用拷贝构造以及拷贝赋值</span><br><span class="hljs-built_in">packaged_task</span>(<span class="hljs-type">const</span> packaged_task&amp;) = <span class="hljs-keyword">delete</span>;<br>packaged_task&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> packaged_task&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">//支持移动构造以及移动赋值</span><br><span class="hljs-built_in">packaged_task</span>(packaged_task&amp;&amp; __other) <span class="hljs-keyword">noexcept</span><br>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">swap</span>(__other); &#125;<br><br>packaged_task&amp; <span class="hljs-keyword">operator</span>=(packaged_task&amp;&amp; __other) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-built_in">packaged_task</span>(std::<span class="hljs-built_in">move</span>(__other)).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(foo)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>future&lt;_Res&gt; get_future()</code>：<strong>获取packaged_task对象内部的future对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">并且不使用move会复制一份<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function">future&lt;_Res&gt;</span><br><span class="hljs-function"><span class="hljs-title">get_future</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">future</span>&lt;_Res&gt;(_M_state); &#125;<br><br><span class="hljs-comment">//使用</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(foo)</span></span>;<br><span class="hljs-keyword">auto</span> f=task.<span class="hljs-built_in">get_future</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>operator()(_ArgTypes... __args)</code>：<strong>重载()运算符，用于启动包装的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(_ArgTypes... __args)</span></span><br><span class="hljs-function"></span>&#123;<br>	__future_base::_State_base::_S_check(_M_state);<br>	_M_state-&gt;_M_run(std::forward&lt;_ArgTypes&gt;(__args)...);<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(foo)</span></span>;<br><span class="hljs-built_in">task</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">int</span>&gt; f)</span></span>&#123;<br>    <span class="hljs-type">int</span> x=f.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(std::packaged_task&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; task)</span></span>&#123;<br>    <span class="hljs-built_in">task</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(foo)</span></span>;<br>    <span class="hljs-keyword">auto</span> f=task.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(Foo,std::move(task))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(foo2,std::move(f))</span></span>;<br>    t.<span class="hljs-built_in">join</span>();<br>    t1.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>























<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><strong>概念</strong>:</p>
<ul>
<li><p><code>std::async</code>：<strong>c++11中异步运行函数，并返回保有其结果的future对象</strong>，<code>必须等到任务执行完毕，才能从future对象拿到返回值</code></p>
</li>
<li><p><code>特性</code>：</p>
<blockquote>
<ol>
<li><code>立即执行</code>：<strong>使用launch::async参数</strong>调用，async会<code>默认创建线程</code>来<strong>运行函数</strong></li>
<li><code>延后执行</code>：<strong>使用launch::deferred参数</strong>，调用async会<strong>延迟执行，直到调用future的get()或者wait()方法时</strong>，<code>不会创建线程</code>来执行，而是<strong>在当前任务线程阻塞执行</strong></li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>常用函数以及原型</strong>：</p>
<ul>
<li><p><code>future&lt;__async_result_of&lt;_Fn,_Args...&gt; std::async(launch __policy,_Fn&amp;&amp; __fn,_Args&amp;&amp;... __args)</code>：<strong>异步运行函数，支持立即执行以及延后执行</strong>(创建线程&#x2F;不创建线程执行)，<strong>返回保存函数结果的future对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Fn, <span class="hljs-keyword">typename</span>... _Args&gt;<br>_GLIBCXX_NODISCARD future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;<br><span class="hljs-built_in">async</span>(launch __policy, _Fn&amp;&amp; __fn, _Args&amp;&amp;... __args)<br>&#123;<br>    <span class="hljs-keyword">using</span> _Wr = std::thread::_Call_wrapper&lt;_Fn, _Args...&gt;;<br>    <span class="hljs-keyword">using</span> _As = __future_base::_Async_state_impl&lt;_Wr&gt;;<br>    <span class="hljs-keyword">using</span> _Ds = __future_base::_Deferred_state&lt;_Wr&gt;;<br><br>    std::shared_ptr&lt;__future_base::_State_base&gt; __state;<br>    <span class="hljs-keyword">if</span> ((__policy &amp; launch::async) == launch::async)<br>    &#123;<br>        __try<br>        &#123;<br>            __state = std::<span class="hljs-built_in">make_shared</span>&lt;_As&gt;(std::forward&lt;_Fn&gt;(__fn),std::forward&lt;_Args&gt;(__args)...);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cpp_exceptions</span><br>        <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> system_error&amp; __e)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (__e.<span class="hljs-built_in">code</span>() != errc::resource_unavailable_try_again<br>                || (__policy &amp; launch::deferred) != launch::deferred)<br>                    <span class="hljs-keyword">throw</span>;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (!__state)<br>    &#123;<br>        __state = std::<span class="hljs-built_in">make_shared</span>&lt;_Ds&gt;(std::forward&lt;_Fn&gt;(__fn),<br>              std::forward&lt;_Args&gt;(__args)...);<br>    &#125;<br>    <span class="hljs-keyword">return</span> future&lt;__async_result_of&lt;_Fn, _Args...&gt;&gt;(std::<span class="hljs-built_in">move</span>(__state));<br>&#125;<br><br><br><span class="hljs-comment">//参数</span><br>__async_result_of:函数返回值类型;<br><br>__policy:函数行为控制参数，取值为std::launch::async和std::launch::deffered,分别表示立即执行/延后执行;<br><br>__fn:异步调用的函数;<br><br>__args:函数参数;<br><br><span class="hljs-comment">//返回值</span><br>future对象;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-comment">//不创建线程启动异步任务</span><br>    <span class="hljs-keyword">auto</span> _f=std::<span class="hljs-built_in">async</span>(std::launch::deferred,foo,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不创建线程的异步取值:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,_f.<span class="hljs-built_in">get</span>());<br><br>    <span class="hljs-comment">//立即执行,创建线程启动异步任务,std::launch::async是默认的，可以不传</span><br>    <span class="hljs-keyword">auto</span> f=std::<span class="hljs-built_in">async</span>(std::launch::async,foo,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建线程的异步取值:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-comment">//等价于</span><br>    <span class="hljs-comment">// auto f=std::async(foo,3);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//执行结果</span><br>不创建线程的异步取值:<br>x=<span class="hljs-number">2</span><br><span class="hljs-number">2</span><br>x=<span class="hljs-number">3</span><br>创建线程的异步取值:<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>



























<h2 id="原子操作atomic"><a href="#原子操作atomic" class="headerlink" title="原子操作atomic"></a>原子操作atomic</h2><p><strong>概念</strong>：</p>
<ul>
<li><p><code>std::atomic</code>：是C++11的一个模板类，<strong>用于实现多线程环境下的原子操作，提供一种线程安全的方式来访问和修改共享变量</strong>，避免多线程中的数据竞争问题</p>
</li>
<li><p><code>原子操作</code>：不可被线程调度机制中断的一个或一系列操作，所以原子操作是一种线程安全的操作</p>
</li>
<li><p><code>特性</code>：</p>
<blockquote>
<ol>
<li>std::atomic相比较普通变量，它的<strong>操作是原子性</strong>的</li>
<li><strong>对原子对象的访问可以做到线程同步，避免了使用锁的复杂性</strong></li>
<li><strong>禁止复制、移动</strong></li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>常用函数以及原型</strong>：</p>
<ul>
<li><p><code>std::atomic&lt;_ITp&gt; data</code>：<strong>创建一个原子对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ITp&gt;<br><br><span class="hljs-comment">//继承了__atomic_base模板类，atomic又对各类型特化进行实现</span><br><span class="hljs-built_in">atomic</span>() <span class="hljs-keyword">noexcept</span> = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-comment">//禁止复制以及移动</span><br><span class="hljs-built_in">atomic</span>(<span class="hljs-type">const</span> atomic&amp;) = <span class="hljs-keyword">delete</span>;<br>atomic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> atomic&amp;) = <span class="hljs-keyword">delete</span>;<br>atomic&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> atomic&amp;) <span class="hljs-keyword">volatile</span> = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>__int_type load()</code>：<strong>将原子变量的值加载到当前线程的本地缓存中，并将这个值返回</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ITp&gt;<br><span class="hljs-keyword">typedef</span> _ITp 	__int_type;<br><br><span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function"><span class="hljs-title">load</span><span class="hljs-params">(memory_order __m = memory_order_seq_cst)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_order __b __attribute__ ((__unused__))<br>    = __m &amp; __memory_order_mask;<br>    __glibcxx_assert(__b != memory_order_release);<br>    __glibcxx_assert(__b != memory_order_acq_rel);<br><br>	<span class="hljs-keyword">return</span> __atomic_load_n(&amp;_M_i, <span class="hljs-built_in">int</span>(__m));<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; data=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> x=data.<span class="hljs-built_in">load</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x);<br><span class="hljs-comment">//打印结果为0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void store(__int_type __i)</code>：<strong>将__i值存储到atomic变量中，是原子性操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><br><span class="hljs-comment">//函数原型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ITp&gt;<br><span class="hljs-keyword">typedef</span> _ITp 	__int_type;<br><br><span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">store</span><span class="hljs-params">(__int_type __i, memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    memory_order __b __attribute__ ((__unused__))<br>    = __m &amp; __memory_order_mask;<br>    __glibcxx_assert(__b != memory_order_acquire);<br>    __glibcxx_assert(__b != memory_order_acq_rel);<br>    __glibcxx_assert(__b != memory_order_consume);<br><br>    __atomic_store_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; x=<span class="hljs-number">0</span>;<br>x.<span class="hljs-built_in">store</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x.<span class="hljs-built_in">load</span>());<br><span class="hljs-comment">//打印结果为1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>__int_type exchange(__int_type __i)</code>：<strong>将__i值替换atomic变量旧值，将旧值返回</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ITp&gt;<br><span class="hljs-keyword">typedef</span> _ITp 	__int_type;<br><br><span class="hljs-function">_GLIBCXX_ALWAYS_INLINE __int_type</span><br><span class="hljs-function"><span class="hljs-title">exchange</span><span class="hljs-params">(__int_type __i,</span></span><br><span class="hljs-params"><span class="hljs-function">   memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> __atomic_exchange_n(&amp;_M_i, __i, <span class="hljs-built_in">int</span>(__m));<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; x=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> y=x.<span class="hljs-built_in">exchange</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y=%d\n&quot;</span>,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x.<span class="hljs-built_in">load</span>());<br><span class="hljs-comment">//打印结果为y=0,x=1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>bool compare_exchange_weak(__int_type&amp; __i1,__int_type __i2)</code>：<strong>比较atomic变量的值与__i1的值，如果相同，则将__i2的值存储到atomic变量中，并返回true，如果不相同，则将atomic的值存储到__i1中，并返回false</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-comment">//函数源码</span><br><span class="hljs-function">_GLIBCXX_ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">compare_exchange_weak</span><span class="hljs-params">(__int_type&amp; __i1, __int_type __i2,</span></span><br><span class="hljs-params"><span class="hljs-function">        memory_order __m = memory_order_seq_cst)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_exchange_weak</span>(__i1, __i2, __m,<br>             __cmpexch_failure_order(__m));<br>&#125;<br><br><br><span class="hljs-comment">//使用</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; x=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> y=<span class="hljs-number">1</span>;<br>x.<span class="hljs-built_in">compare_exchange_weak</span>(y,<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不相等:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y=%d\n&quot;</span>,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x.<span class="hljs-built_in">load</span>());<br>x.<span class="hljs-built_in">compare_exchange_weak</span>(y,<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;相等:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y=%d\n&quot;</span>,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x.<span class="hljs-built_in">load</span>());<br><span class="hljs-comment">//打印结果：</span><br>不相等:<br>y=<span class="hljs-number">0</span><br>x=<span class="hljs-number">0</span><br>相等:<br>y=<span class="hljs-number">0</span><br>x=<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>概念</strong>：</p>
<ul>
<li><code>线程池</code>：顾名思义就是一个放线程的池子(线程聚集的地方)，里面有很多线程，<strong>用于管理程序的线程创建与销毁回收的</strong>，会在程序开始时创建一堆线程</li>
<li><strong>线程池是一个符合生产者消费者模型的一个应用</strong>，因此我们实现时就按照这种架构思想实现</li>
<li>具体线程池概念可见<a href="https://moonfordream.github.io/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#%E7%BA%BF%E7%A8%8B%E6%B1%A0">Linux网络编程—线程池</a></li>
</ul>
<p><strong>Threadpool.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _THREADPOOL_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _THREADPOOL_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_TIME 10</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Threadpool</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Threadpool</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">threads</span>(std::<span class="hljs-built_in">vector</span>&lt;std::thread&gt;(num)),<span class="hljs-built_in">min_thr_num</span>(num),<span class="hljs-built_in">live_num</span>(num)&#123;<br>        <span class="hljs-built_in">init</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">Threadpool</span>()&#123;<br>        <span class="hljs-built_in">t_shutdown</span>();<br>    &#125;<br>    <span class="hljs-comment">//初始化线程池</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//销毁线程池并释放资源</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">t_shutdown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//各任务线程入口函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">t_task</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//管理线程入口函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust_task</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//添加任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Fn,<span class="hljs-keyword">typename</span>... _Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">add_task</span><span class="hljs-params">(_Fn&amp;&amp; fn,_Args&amp;&amp;... args)</span></span>&#123;<br>        &#123;<br>            <span class="hljs-keyword">auto</span> f=std::<span class="hljs-built_in">bind</span>(std::forward&lt;_Fn&gt;(fn),std::forward&lt;_Args&gt;(args)...);<br>            &#123;<br>                <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mx)</span></span>;<br>                <span class="hljs-keyword">if</span>(shutdown) <span class="hljs-keyword">return</span>;<br>                tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(f));<br>            &#125;<br>            task_cv.<span class="hljs-built_in">notify_one</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::thread adjust_thr;     <span class="hljs-comment">//管理线程</span><br>    std::vector&lt;std::thread&gt; threads;   <span class="hljs-comment">//线程数组</span><br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;    <span class="hljs-comment">//任务队列</span><br>    std::mutex mx;  <span class="hljs-comment">//线程池锁</span><br>    std::condition_variable task_cv;    <span class="hljs-comment">//任务通知条件变量</span><br>    <span class="hljs-type">int</span> min_thr_num=<span class="hljs-number">0</span>;    <span class="hljs-comment">//线程池最小线程数</span><br>    <span class="hljs-type">int</span> max_thr_num=<span class="hljs-number">37</span>;     <span class="hljs-comment">//cpu核数的2n+1</span><br>    std::atomic&lt;<span class="hljs-type">int</span>&gt; run_num=<span class="hljs-number">0</span>; <span class="hljs-comment">//线程池中正在执行任务的线程数</span><br>    std::atomic&lt;<span class="hljs-type">int</span>&gt; live_num=<span class="hljs-number">0</span>; <span class="hljs-comment">//线程池空闲线程数</span><br>    std::atomic&lt;<span class="hljs-type">int</span>&gt; exit_num=<span class="hljs-number">0</span>; <span class="hljs-comment">//线程池要销毁线程数</span><br>    <span class="hljs-type">bool</span> shutdown=<span class="hljs-literal">false</span>;  <span class="hljs-comment">//线程池状态，true为运行，false为关闭</span><br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>







<p><strong>Threadpool.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Threadpool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threadpool::init</span><span class="hljs-params">()</span></span>&#123;<br>    adjust_thr=std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>]&#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">adjust_task</span>();<br>    &#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;min_thr_num;++i)&#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]&#123;<br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">t_task</span>();<br>        &#125;);<br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threadpool::t_task</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mx)</span></span>;<br>        task_cv.<span class="hljs-built_in">wait</span>(lock,[<span class="hljs-keyword">this</span>]&#123;<br>            <span class="hljs-keyword">return</span> !tasks.<span class="hljs-built_in">empty</span>()||shutdown||exit_num&gt;<span class="hljs-number">0</span>;<br>        &#125;);<br>        <span class="hljs-keyword">if</span>(exit_num&gt;<span class="hljs-number">0</span>)&#123;<br>            exit_num--;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(shutdown&amp;&amp;tasks.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> task=tasks.<span class="hljs-built_in">front</span>();<br>        tasks.<span class="hljs-built_in">pop</span>();<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        ++run_num;<br>        --live_num;<br>        <span class="hljs-built_in">task</span>();<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threadpool::t_shutdown</span><span class="hljs-params">()</span></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mx)</span></span>;<br>        shutdown=<span class="hljs-literal">true</span>;<br>    &#125;<br>    adjust_thr.<span class="hljs-built_in">detach</span>();<br>    task_cv.<span class="hljs-built_in">notify_all</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t:threads)&#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>()) t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threadpool::adjust_task</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (!shutdown) &#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(DEFAULT_TIME));<br>        &#123;<br>            <span class="hljs-type">int</span> size=threads.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span> (tasks.<span class="hljs-built_in">size</span>() &gt; live_num &amp;&amp; live_num &lt; max_thr_num&amp;&amp;size&lt;max_thr_num) &#123;<br>                <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;<br>                <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mx)</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; max_thr_num &amp;&amp; add &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>                    threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123;<br>                        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">t_task</span>();<br>                    &#125;);<br>                    add++;<br>                    live_num++;<br>                &#125;<br>                lock.<span class="hljs-built_in">unlock</span>();<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;线程池扩容成功!&quot;</span> &lt;&lt; std::endl;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (run_num * <span class="hljs-number">2</span> &lt; live_num &amp;&amp; live_num &gt; min_thr_num) &#123;<br>                exit_num=live_num-min_thr_num&gt;=<span class="hljs-number">10</span>?<span class="hljs-number">10</span>:live_num-min_thr_num;<br>                <span class="hljs-type">int</span> x=exit_num;<br>                <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mx)</span></span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i) &#123;<br>                    task_cv.<span class="hljs-built_in">notify_one</span>();<br>                    live_num--;<br>                &#125;<br>                lock.<span class="hljs-built_in">unlock</span>();<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;线程池瘦身成功!&quot;</span> &lt;&lt; std::endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++多线程编程</div>
      <div>https://moonfordream.github.io/posts/C-多线程编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Moon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/C-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/" title="C++完美转发">
                        <span class="hidden-mobile">C++完美转发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://moon-twikoo.netlify.app/.netlify/functions/twikoo","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              Fluid.utils.listenDOMLoaded(function() {
                var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
                Fluid.plugins.imageCaption(imgSelector);
                Fluid.plugins.fancyBox(imgSelector);
              });
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/MoonforDream" target="_blank" rel="nofollow noopener"><span>Moon</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/scrollAnimation.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
